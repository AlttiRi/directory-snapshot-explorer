{"version":3,"file":"index.js","sources":["node-modules:///vite/modulepreload-polyfill","source-maps:///util.js","source-maps:///core/entries.js","source-maps:///core/debug.js","source-maps:///core/entry.js","source-maps:///core/search.js","source-maps:///core/scan-parser.js","source-maps:///core/folders.js","source-maps:///components/AddressBar_Base.vue","source-maps:///components/AddressBar_Folder.vue","source-maps:///components/AddressBar.vue","source-maps:///components/FileSelect.vue","source-maps:///components/Row.vue","source-maps:///components/IntersectionRow.vue","source-maps:///components/Content.vue","source-maps:///components/Status.vue","source-maps:///components/Switch.vue","source-maps:///components/Main.vue","source-maps:///main.js"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","export const setImmediate = globalThis.setImmediate || /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\nexport function sleep(ms) {\n    if (ms === undefined) {\n        return new Promise(resolve => setImmediate(resolve));\n    }\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const shuffle = () => Math.random() >= 0.5 ? -1 : 1;\n\nconst videoExtensions = [\"mp4\", \"webm\", \"mkv\", \"avi\"];\nexport function isVideo(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return videoExtensions.includes(ext);\n}\nconst imageExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"tiff\", \"webp\"];\nexport function isImage(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return imageExtensions.includes(ext);\n}\n\nexport function debounce(runnable, ms = 50) {\n    let timerId;\n    return function() {\n        // console.log({timerId});\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            runnable.apply(this, arguments);\n            timerId = null;\n        }, ms);\n    }\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\nexport function dateToDayDateString(dateValue, utc = true) {\n    const _date = new Date(dateValue);\n    if (_date.toString() === \"Invalid Date\") {\n        console.warn(\"Invalid Date value: \", dateValue);\n    }\n    function pad2(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n    const _utc = utc ? \"UTC\" : \"\";\n    const year  = _date[`get${_utc}FullYear`]();\n    const month = _date[`get${_utc}Month`]() + 1;\n    const date  = _date[`get${_utc}Date`]();\n\n    return year + \".\" + pad2(month) + \".\" + pad2(date);\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10 22:22:22Z\"\nexport function dateToDayDateTimeString(dateValue, utc = true) {\n    const _date = new Date(dateValue);\n    function pad2(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n    const _utc = utc ? \"UTC\" : \"\";\n    const hours    = _date[`get${_utc}Hours`]();\n    const minutes  = _date[`get${_utc}Minutes`]();\n    const seconds  = _date[`get${_utc}Seconds`]();\n\n    const time = pad2(hours)+ \":\" + pad2(minutes) + \":\" + pad2(seconds);\n    return dateToDayDateString(_date, utc) + \" \" + time + (utc ? \"Z\" : \"\");\n}\n\n\nexport function structuredClone(object) {\n    return new Promise(resolve => {\n        const {port1, port2} = new MessageChannel();\n        port1.onmessage = function(message) {\n            resolve(message.data);\n        };\n        port2.postMessage(object);\n    });\n}\n\nexport function appendScript(src, integrity) {\n    return new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.onload = resolve;\n        script.onerror = event => reject({message: \"Failed to load script\", src, integrity, event});\n        script.src = src;\n        script.async = true;\n        if (integrity) {\n            script.integrity = integrity;\n            script.crossOrigin = \"anonymous\";\n        }\n        document.body.append(script);\n    });\n}\n\n/**\n * `chunkSize` is 65536, ReadableStream uses the same size.\n * There is no speed difference between using of different the chunk's sizes.\n * @param {ArrayBuffer|Uint8Array} arrayBuffer\n * @param {Number} [chunkSize=65536]\n * @return {Generator<Uint8Array>}\n */\nexport function *iterateArrayBuffer(arrayBuffer, chunkSize = 65536) {\n    const buffer = new Uint8Array(arrayBuffer);\n    let index = 0;\n    while (true) {\n        const chunk = buffer.subarray(index, index + chunkSize);\n        if (!chunk.length) {\n            break;\n        }\n        yield chunk;\n        index += chunkSize;\n    }\n}\n\n/**\n * @param {Response|ReadableStream|Blob} dataSource\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateAsyncDataSource(dataSource) {\n    if (dataSource instanceof Response) {\n        dataSource = dataSource.body;\n    }\n    if (dataSource instanceof ReadableStream) {\n        yield *iterateReadableStream(dataSource);\n    } else if (dataSource instanceof Blob) {\n        for (const part of iterateBlob(dataSource)) {\n            yield await part;\n        }\n    }\n}\n\n\n/**\n * @param {ReadableStream} stream\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateReadableStream(stream) {\n    const reader = stream.getReader();\n    while (true) {\n        const {done, /** @type {Uint8Array} */ value} = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\n\n/**\n * Iterates Blob (or File).\n * Note: `chunkSize` affects the execution speed\n * @param {Blob} blob\n * @param {Number} [chunkSize=2097152]\n * @return {Generator<Promise<Uint8Array>>|AsyncGenerator<Uint8Array>}\n */\nexport function *iterateBlob(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        return new Uint8Array(await blob.arrayBuffer());\n    }\n}\n\n/**\n * Format bytes to human readable format.\n * Trims the tailing zeros.\n *\n * {@link https://stackoverflow.com/a/18650828/11468937}\n * @param {Number} bytes\n * @param {Number} [decimals=2]\n * @returns {String}\n */\nexport function bytesToSize(bytes, decimals = 2) {\n    if (bytes === 0) { return \"0 B\"; }\n    const k = 1024;\n    decimals = decimals < 0 ? 0 : decimals;\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n}\n\n/**\n * Formats bytes mostly like Windows does,\n * but in some rare cases the result is different.\n * Check the file with tests.\n * @see win-like-file-sizes.test.js\n * @param {Number} bytes\n * @return {string}\n */\nexport function bytesToSizeWinLike(bytes) {\n    if (bytes < 1024) { return bytes + \" B\"; }\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    let i = Math.floor(Math.log(bytes) / Math.log(1024));\n    let result = bytes / Math.pow(1024, i);\n    if (result >= 1000) {\n        i++;\n        result /= 1024;\n    }\n    return toTruncPrecision3(result) + \" \" + sizes[i];\n}\n\n/**\n * @see trunc-with-precision-3.test.js\n * @param {Number} number\n * @return {string}\n */\nexport function toTruncPrecision3(number) {\n    let result;\n    if (number < 10) {\n        result = Math.trunc(number * 100) / 100;\n    } else if (number < 100) {\n        result = Math.trunc(number * 10) / 10;\n    } else if (number < 1000) {\n        result = Math.trunc(number);\n    }\n    if (number < 0.1) {\n        return result.toPrecision(1);\n    } else if (number < 1) {\n        return result.toPrecision(2);\n    }\n    return result.toPrecision(3);\n}\n\n/**\n * @param {Uint8Array[]} arrays\n * @return {Uint8Array}\n */\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n\nexport function red(text) {\n    return [`%c${text}`,  \"color: #f44336; font-weight: bold;\"];\n}\nexport function orange(text) {\n    return [`%c${text}`,  \"color: #ff9800; font-weight: bold;\"];\n}\nexport function green(text) {\n    return [`%c${text}`,  \"color: #4caf50; font-weight: bold;\"];\n}\nexport function cyan(text) {\n    return [`%c${text}`,  \"color: #00bcd4; font-weight: bold;\"];\n}\nexport function blue(text) {\n    return [`%c${text}`,  \"color: #2196f3; font-weight: bold;\"];\n}\n","import {computed, ref} from \"vue\";\nimport {search, searchResult} from \"./search.js\";\nimport {openedFolder, parsingStateNumber} from \"./folders.js\";\n\n\nexport const sort = ref(true);\n\n/** @type {import(\"vue\").Ref<(\"name\"|\"size\"|\"mtime\")>} */\nexport const orderBy = ref(\"mtime\");\nexport const orders = ref({\n    name: false,\n    size: false,\n    mtime: false,\n});\nexport const reverseOrder = computed(() => orders.value[orderBy.value]);\nexport function toggleOrder() {\n    orders.value[orderBy.value] = !orders.value[orderBy.value];\n}\n\nconst {compare} = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: \"accent\",\n});\n\n// // todo create the list variable (search result -> the list), (opened dir entries -> the list)\n// export const reactiveComparator = computed(() => {\n//     const k = reverseOrder.value ? -1 : 1;\n//     if (sort.value) {\n//         if (orderBy.value === \"name\") {\n//             return (pre, cur) => compare(pre.name, cur.name) * k;\n//         } else if (orderBy.value === \"size\") {\n//             return (pre, cur) => (pre.size - cur.size) * k;\n//         } else if (orderBy.value === \"mtime\") {\n//             return (pre, cur) => (pre.mtime - cur.mtime) * k;\n//         }\n//     }\n//     return (pre, cur) => 0;\n// });\n\nexport function comparator(pre, cur) {\n    const k = reverseOrder.value ? -1 : 1;\n    if (sort.value) {\n        if (orderBy.value === \"name\") {\n            return compare(pre.name, cur.name) * k;\n        } else if (orderBy.value === \"size\") {\n            return (pre.size - cur.size) * k;\n        } else if (orderBy.value === \"mtime\") {\n            return (pre.mtime - cur.mtime) * k;\n        }\n    }\n    return 0;\n}\n\n// grouped by type\nexport const entries = computed(() => {\n    if (parsingStateNumber.value) {\n        // force recomputing on change\n    }\n    return [\n        ...openedFolder.value.folders.sort(comparator),\n        ...openedFolder.value.files.sort(comparator),\n        ...openedFolder.value.symlinks.sort(comparator),\n        ...openedFolder.value.fifos.sort(comparator),\n        ...openedFolder.value.charDevs.sort(comparator),\n        ...openedFolder.value.blockDevs.sort(comparator),\n        ...openedFolder.value.sockets.sort(comparator),\n    ]\n});\n\n\n/** @type {import(\"vue\").Ref<Number>} */\nexport const limit = ref(50);\n\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const list = computed(() => {\n    if (search.value.length) {\n        return searchResult.value;\n    }\n    return entries.value;\n});\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const listLimited = computed(() => {\n    return list.value.slice(0, limit.value);\n});\n/** @type {import(\"vue\").ComputedRef<Number>} */\nexport const count = computed(() => {\n    if (searchResult.value.length > limit.value) {\n        return searchResult.value.length;\n    }\n    return list.value.length;\n});\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nexport const hoveredEntry = ref(null);\n","import {ref, toRaw, isProxy} from \"vue\";\nimport {bytesToSizeWinLike, dateToDayDateTimeString} from \"../util.js\";\n\nexport const debugMessage = ref(\"\");\nexport function addMessage(message) {\n    debugMessage.value = message;\n}\nexport function appendMessage(message) {\n    debugMessage.value += message;\n}\n\n/**\n * @param {SimpleEntry} entry\n */\nexport function debugMessageFromEntry(entry) {\n    console.log(isProxy(entry) ? \"Proxy:\" : \"Raw:\", toRaw(entry));\n    if (entry.hasErrors) {\n        debugMessage.value = \"\";\n    } else {\n        const name = `\"` + entry.name.slice(0, 20) + (entry.name.length < 20 ? \"\" : \"...\") + `\"`;\n\n        let message = \"\";\n        message += \"mtime \" + `\"${dateToDayDateTimeString(entry.mtime, false)}\"`;\n        message += \" —  btime \" + `\"${dateToDayDateTimeString(entry.btime ?? 0, false)}\"`;\n\n        message += ` — ${name} — ${entry.size} (${bytesToSizeWinLike(entry.size)})`;\n        debugMessage.value = message;\n    }\n}\n","/** @type {ScanEntryType[]} */\nimport {sleep} from \"../util.js\";\n\nexport const entryTypes = [\"folder\", \"file\", \"symlink\", \"fifo\", \"charDev\", \"blockDev\", \"socket\"];\n\nexport class SimpleEntry {\n    // [Symbol.toStringTag] = \"SimpleEntry\"; // Disables reactivity, BTW.\n    /**\n     * @param {SerializableScanEntry} entry\n     * @param {SimpleEntry|null} parent\n     * @param {Map<Number, SimpleScanError>} [errorsIDMap]\n     */\n    constructor(entry, parent, errorsIDMap) {\n        /** @type {String} */\n        this.name = entry.name;\n        /** @type {SimpleEntry|null} */\n        this.parent = parent;\n        /** @type {ScanEntryType} */\n        this.type = entry.type;\n\n        if (entry.size) {\n            /** @type {Number|undefined} */\n            this._size = entry.size;\n        }\n        if (entry.mtime) {\n            /** @type {Number|undefined} */\n            this.mtime = entry.mtime;\n        }\n        if (entry.btime) {\n            /** @type {Number|undefined} */\n            this.btime = entry.btime;\n        }\n\n        if (entry.errors) {\n            /** @type {SimpleScanError[]}|undefined} */\n            this.errors = entry.errors.map(id => errorsIDMap.get(id));\n        }\n\n        if (entry.pathTo) {\n            /** @type {String|undefined} */\n            this.pathTo = entry.pathTo;\n        }\n        if (entry.content) {\n            /** @type {String|undefined} */\n            this.content = entry.content;\n        }\n    }\n    /** @param {SimpleEntry} entry */\n    addChild(entry) {\n        if (!this.children) {\n            /**\n             * `undefined` if there is no child\n             * @type {SimpleEntry[]|undefined}\n             */\n            this.children = [];\n        }\n        this.children.push(entry);\n        this.increaseContentSize(entry.size);\n    }\n    /** @param {SimpleEntry[]} entries\n     *  @param {Number} total */\n    addHardlinks(entries, total) {\n        /** @type {SimpleEntry[]|undefined} */\n        this.hardlinks = entries;\n        /** @type {Number|undefined} */\n        this.hardlinksTotal = total;\n    }\n\n    increaseContentSize(size) {\n        if (!size) {\n            return;\n        }\n        if (!this._contentSize) {\n            this._contentSize = 0;\n        }\n        this._contentSize += size;\n        if (this.parent && size) {\n            this.parent.increaseContentSize(size);\n        }\n    }\n\n    /**\n     * Note: the folder size is computed on the creation step.\n     * @return {Number}\n     */\n    get size() {\n        if (this.type === \"folder\") {\n            return this._contentSize || 0;\n        }\n        return this._size || 0;\n    }\n\n    /** @return {SimpleEntry[]} */\n    get folders() {\n        return this.children?.filter(e => e.type === \"folder\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get files() {\n        return this.children?.filter(e => e.type === \"file\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get symlinks() {\n        return this.children?.filter(e => e.type === \"symlink\") || [];\n    }\n\n    /** @return {SimpleEntry[]} */\n    get fifos() {\n        return this.children?.filter(e => e.type === \"fifo\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get charDevs() {\n        return this.children?.filter(e => e.type === \"charDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get blockDevs() {\n        return this.children?.filter(e => e.type === \"blockDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get sockets() {\n        return this.children?.filter(e => e.type === \"socket\") || [];\n    }\n\n    /** @return {Boolean} */\n    get isEmpty() {\n        return !Boolean(this.children?.length);\n    }\n    /** @return {Boolean} */\n    get hasErrors() {\n        return Boolean(this.errors?.length);\n    }\n    /** @return {SimpleEntry} */\n    get root() {\n        if (!this.parent) {\n            return this;\n        }\n        return this.parent.root;\n    }\n    /** @return {SimpleEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n}\n\n/**\n * Like `ScanError`, but without `path`.\n * @typedef {Object} SimpleScanError\n * @property {String} code\n * @property {String} syscall\n * @property {Number} errno\n **/\n\nexport class EntryStreamParser {\n    constructor() {\n        this.rootId = 0;\n        /** @type {Map<Number, SimpleEntry>} */\n        this.map = new Map();\n        /** @type {Map<String, SimpleEntry[]>} */\n        this.hidMap = new Map();\n    }\n\n    /** @param {ScanMeta} meta */\n    setMeta(meta) {\n        /** @type {ScanMeta} */\n        this.meta = meta;\n        /** @type {Object<String, Number>} */\n        const errorsMap = meta.errorsMap;\n        if (!errorsMap) {\n            return;\n        }\n        /** @type {Map<Number, SimpleScanError>|undefined} */\n        this.errorsIDMap = new Map(Object.entries(errorsMap)\n            .map(([k, v]) => {\n                const [code, syscall, errno] = k.split(\":\");\n                return [v, {code, syscall, errno: Number(errno)}];\n            }));\n    }\n\n    /** @param {SerializableScanEntry[]} sEntriesPart\n     * @return {{root: SimpleEntry, rootUpdated: boolean}}\n     */\n    parse(sEntriesPart) {\n        let rootUpdated = false;\n        for (const entry of sEntriesPart) {\n            /** @type {SimpleEntry|null}*/\n            const parent = this.map.get(entry.pid) ?? null;\n            const simpleEntry = new SimpleEntry(entry, parent, this.errorsIDMap);\n            if (entry.type === \"folder\") {\n                this.map.set(entry.id, simpleEntry);\n            }\n            parent?.addChild(simpleEntry);\n            if (entry.hid) {\n                const array = this.hidMap.get(entry.hid) || [];\n                this.hidMap.set(entry.hid, [...array, simpleEntry]);\n            }\n            if (entry.pid === this.rootId) {\n                rootUpdated = true;\n            }\n        }\n        return {\n            root: this.map.get(this.rootId),\n            rootUpdated\n        }\n    }\n\n    processHIDMapAsync() {\n        if (!this.hidMap.size) {\n            return;\n        }\n        console.log(\"[hidMap]:\", this.hidMap);\n        console.time(\"hidMap\");\n        processHIDMapAsync(this.hidMap)\n            .then(() => console.timeEnd(\"hidMap\"));\n    }\n}\n\nasync function processHIDMapAsync(hidMap) {\n    let i = 0;\n    let time = 0; // `0` to do `sleep` on the first iteration\n\n    for (const [hid, simpleEntries] of hidMap.entries()) {\n        if (!(i++ % 1000)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n            }\n        }\n\n        /** @type {Number}*/\n        const totalLinks = Number(hid.split(\":\")[1]);\n        simpleEntries.forEach(e => {\n            e.addHardlinks(simpleEntries, totalLinks);\n        });\n    }\n}\n\n/** @type {SimpleEntry} */\nexport const folderDummy = new SimpleEntry({\n    type: \"folder\",\n    name: \"\",\n    pid: null,\n}, null);\n","import {isReactive, ref, toRaw, watch} from \"vue\";\nimport {blue, bytesToSizeWinLike, debounce, sleep} from \"../util.js\";\nimport {openedFolder} from \"./folders.js\";\nimport {comparator, limit, orderBy,  reverseOrder} from \"./entries.js\";\nimport * as debug from \"./debug.js\";\nimport {entryTypes} from \"./entry.js\";\n\n/** @type {import(\"vue\").Ref<string>} */\nexport const search = ref(\"\"); // [v-model]\nexport function clearSearch() {\n    search.value = \"\";\n}\n\n/** @type {import(\"vue\").Ref<SimpleEntry[]>} */\nexport const searchResult = ref([]);\nfunction clearSearchResult() {\n    setSearchResult([]);\n}\n/** * @param {SimpleEntry[]} result */\nfunction setSearchResult(result) {\n    /** @type {SimpleEntry[]} */\n    const rawResult = toRaw(result);\n    searchResult.value = rawResult;\n    limit.value = 50;\n\n    addSearchResultToGlobalThis(rawResult);\n}\n\nwatch([orderBy, reverseOrder], () => {\n    if (searchResult.value.length) {\n        console.time(\"sort searchResult\");\n        searchResult.value = searchResult.value.sort(comparator);\n        console.timeEnd(\"sort searchResult\");\n        //todo sort by parts\n    }\n});\n\n/** @param {SimpleEntry[]} rawResult */\nfunction addSearchResultToGlobalThis(rawResult) {\n    /** @type {SimpleEntry[]} */\n    globalThis.search = rawResult;\n    console.log(\"globalThis.search:\", rawResult);\n    Object.defineProperty(globalThis.search, \"download\", {\n        get() {\n            console.log(\"download\"); // todo\n        }\n    });\n    Object.defineProperty(globalThis.search, \"names\", {\n        get() {\n            return globalThis.search.map(entry => entry.name);\n        }\n    });\n    Object.defineProperty(globalThis.search, \"namelist\", {\n        get() {\n            return globalThis.search.map(entry => entry.name).join(\"\\n\");\n        }\n    });\n}\n\n//todo check linked list perf for large search // do search after scan parsing ended\nconst performSearchDebounced = debounce(performSearch, 300);\nasync function performSearch() {\n    const folder = openedFolder.value;\n    const request = search.value;\n\n    // Do unProxy. Up to x40 in comparison with default reactive ref.\n    const folderRaw = isReactive(folder) ? toRaw(folder) : folder;\n\n    const time1 = performance.now();\n    const result = await searcher(folderRaw, request);\n    if (!result) {\n        return;\n    }\n    const searchTime = performance.now() - time1;\n    debug.addMessage(`Search time: ${searchTime.toFixed(2)} ms; `);\n    await sleep();\n\n    const time2 = performance.now();\n    const sortedResult = result.sort(comparator);\n    const sortTime = performance.now() - time2;\n    debug.appendMessage(`Sort time: ${sortTime.toFixed(2)} ms; `);\n    await sleep();\n\n    console.time(\"search result size computing\");\n    const resultSet = new Set(result);\n    const allSize = result.reduce((acc, val) => computeEntrySize(val, resultSet) + acc, 0);\n    const filesSize = result.filter(entry => entry.type !== \"folder\").reduce((acc, val) => val.size + acc, 0);\n    console.timeEnd(\"search result size computing\");\n    console.log(allSize, filesSize);\n\n    setSearchResult(sortedResult);\n    const searchText = result.customSearchText || request;\n    debug.appendMessage(`${result.length} items; size: ${bytesToSizeWinLike(filesSize)} (${bytesToSizeWinLike(allSize)});  search: ${searchText}`);\n}\n\n\n/**\n * The recursive size computing of an `SimpleEntry`.\n * Skips the entries of `excludeSet`.\n * @param {SimpleEntry} entry\n * @param {Set<SimpleEntry>} excludeSet\n * @return {Number}\n */\nfunction computeEntrySize(entry, excludeSet) {\n    if (entry.type !== \"folder\") {\n        return entry.size;\n    }\n    let childrenSize = 0;\n    for (const child of entry.children || []) {\n        if (excludeSet.has(entry)) {\n            continue;\n        }\n        if (child.type === \"folder\") {\n            childrenSize += computeEntrySize(child, excludeSet);\n        } else {\n            childrenSize += child.size;\n        }\n    }\n    return childrenSize;\n}\n\n/**\n * @param {SimpleEntry} folder\n * @param {string} search\n * @return {Promise<SimpleEntry[]|false>}\n */\nasync function searcher(folder, search) { // \"đ Crème Bruląśćńżółźćęéйeё\".normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\")\n    if (search.startsWith(\"//\")) {\n        return justSearch(search.slice(2));\n    }\n\n    /**\n     * @example\n     * /size:0       - find 0 byte size entries\n     * /size/120     - the same, find 120 bytes size entries\n     * /size:120+80  - find from 120 to 200\n     * /size:120+80  - find from 120 to 200\n     * /size:120+-20 - find from 100 to 120\n     * /size:120~20  - find from  80 to 140\n     * /size:120-220 - find from 120 to 220\n     * /size:220-120 - find from 120 to 220\n     * //todo\n     * /size:120~    - find from 120 -5% to 120 +5%\n     * /size:120~~   - find from 120-10% to 120+10%\n     * /size:120~~~  - find from 120-15% to 120+15%\n     */\n    if (search.startsWith(\"/size\")) {\n        const {\n            /** @type {String|undefined} */\n            size,\n            /** @type {String|undefined} */\n            plus,\n            /** @type {String|undefined} */\n            plusRange,\n            /** @type {String|undefined} */\n            range,\n        } = search.match(/\\/size[:\\/](?<size>\\d+)(\\+(?<plus>(\\d+)|(-\\d+))|~(?<plusRange>\\d+)|-(?<range>\\d+))?/)?.groups || {};\n        if (size) {\n            console.log({size, plus, plusRange, range});\n\n            let text;\n            let result;\n            const _size = Number(size);\n\n            if (plus) {\n                const _plus = _size + Number(plus);\n                const {min, max} = _size < _plus ? {min: _size, max: _plus} : {min: _plus, max: _size};\n                text = `Size search from ${bytesToSizeWinLike(min)} to ${bytesToSizeWinLike(max)}`;\n                result = await findAll(folder, entry => {\n                    return entry.size >= min && entry.size <= max;\n                });\n            } else\n            if (range) {\n                const _range = Number(range);\n                const {min, max} = _size < _range ? {min: _size, max: _range} : {min: _range, max: _size};\n                text = `Size search from ${bytesToSizeWinLike(min)} to ${bytesToSizeWinLike(max)}`;\n                result = await findAll(folder, entry => {\n                    return entry.size >= min && entry.size <= max;\n                });\n            } else\n            if (plusRange) {\n                const min = _size - Number(plusRange);\n                const max = _size + Number(plusRange);\n                text = `Size search from ${bytesToSizeWinLike(min)} to ${bytesToSizeWinLike(max)}`;\n                result = await findAll(folder, entry => {\n                    return entry.size >= min && entry.size <= max;\n                });\n            } else {\n                text = `Size search ${bytesToSizeWinLike(_size)}`;\n                result = await findAll(folder, entry => {\n                    return entry.size === _size;\n                });\n            }\n            console.log(...blue(text));\n            Object.defineProperty(result, \"customSearchText\", {\n                value: text\n            });\n            return result;\n        } else {\n            console.log(\"no size to search\");\n        }\n    }\n    if (search.startsWith(\"/\")) {\n        const {type, word} = search.match(/\\/type:(?<type>[^\\/]+)\\/?(?<word>[^\\/]*)/)?.groups || {};\n        if (type) {\n            console.log({type, word});\n            if (entryTypes.includes(type)) {\n                return findAll(folder, entry => {\n                    return entry.type === type && entry.name.includes(word);\n                });\n            }\n        }\n    } else if (search.includes(\" \")) {\n        const parts = search.split(\" \").filter(o => o);\n        if (parts.length > 1) {\n            let result = await justSearch(parts.shift());\n            let curWord;\n            while (curWord = parts.shift()) {\n                result = result.filter(entry => entry.name.includes(curWord));\n            }\n            return result;\n        }\n    }\n    return justSearch(search);\n\n    function justSearch(search) {\n        return findAll(folder, (entry) => {\n            return entry.name.includes(search);\n        });\n    }\n}\n\nwatch(search, async (newValue, oldValue) => {\n    const isEmptyString = !newValue;\n    if (isEmptyString) {\n        clearSearchResult();\n        return;\n    }\n    // In order to \"no debounce by paste event\"\n    if (newValue.length - oldValue.length > 1) {\n        await performSearch();\n    } else {\n        await performSearchDebounced();\n    }\n});\n\n/**\n * @param {SimpleEntry} folder\n * @param {function(SimpleEntry)} predicate\n * @return {Promise<SimpleEntry[]>}\n */\nasync function findAll(folder, predicate) {\n    let res = [];\n    let time = Date.now();\n    for (const entries of listAllEntries(folder)) {\n        const curTime = Date.now();\n        if (curTime - time > 15) {\n            time = curTime;\n            await sleep();\n        }\n        for (const entry of entries) {\n            if (predicate(entry)) {\n                res.push(entry);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * List all entries by parts.\n * @param {SimpleEntry} folder\n * @return {Generator<SimpleEntry[]>}\n */\nfunction *listAllEntries(folder) {\n    const partSize = 1000;\n    /** @type {SimpleEntry[]} */\n    let list = [];\n    /** @param {SimpleEntry} folderEntry */\n    function *takePart(folderEntry) {\n        for (const entry of (folderEntry.children || [])) {\n            if (entry.type === \"folder\") {\n                yield *takePart(entry);\n            }\n            list.push(entry);\n            if (list.length === partSize) {\n                yield list;\n                list = [];\n            }\n        }\n    }\n    yield *takePart(folder);\n    yield list;\n}\n","import {EntryStreamParser} from \"./entry.js\";\nimport {appendScript, iterateAsyncDataSource, sleep} from \"../util.js\";\n\n\n/**\n * @param {Blob|Response} input\n * @return {AsyncGenerator<{meta:ScanMeta, root: SimpleEntry, rootUpdated: boolean}>}\n */\nexport async function *parseScan(input) {\n    const parser = new EntryStreamParser();\n\n    let contentType;\n    if (input instanceof Response) {\n        contentType = input.headers.get(\"content-type\");\n    } else if (input instanceof Blob) {\n        contentType = input.type;\n    }\n    /** @type {ScanMeta} */\n    let meta;\n    if (isGZip(contentType)) {\n        console.log(\"parseGZippedJSONScan\");\n        for await (const obj of parseGZippedJSONScan(input)) {\n            if (!meta) {\n                meta = /** @type {ScanMeta} */ obj.shift();\n                parser.setMeta(meta);\n            }\n            yield {meta, ...parser.parse(/** @type {SerializableScanEntry[]} */ obj)};\n        }\n    } else if (isJSON(contentType)) {\n        console.log(\"streamParseJSONScan\");\n        for await (const array of streamParseJSONScan(input)) {\n            if (!meta) {\n                meta = /** @type {ScanMeta} */ array.shift();\n                parser.setMeta(meta);\n            }\n            yield {meta, ...parser.parse(/** @type {SerializableScanEntry[]} */ array)};\n        }\n    }\n    parser.processHIDMapAsync();\n}\n\n\n/**\n * @param {Response|ReadableStream|Blob} input\n * @return {AsyncGenerator<FlatScanResultEntry[]>}\n */\nasync function *streamParseJSONScan(input) {\n    const decoder = new TextDecoder();\n    const textParser = new TextParser();\n    let i = 0, time = 0;\n    for await (const uint8Array of iterateAsyncDataSource(input)) {\n        if (!(i++ % 10)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        const scanResultEntries = textParser.parsePart(textPart);\n        if (scanResultEntries.length) {\n            yield scanResultEntries;\n        }\n    }\n}\n\n/**\n * @param {Response|Blob} input\n * @return {AsyncGenerator<FlatScanResultEntry[]>}\n */\nasync function *parseGZippedJSONScan(input) {\n    const decoder = new TextDecoder();\n    const textParser = new TextParser();\n    let i = 0, time = 0;\n    for await (const uint8Array of unGZipAsyncIterator(input)) {\n        if (!(i++ % 20)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        const scanResultEntries = textParser.parsePart(textPart);\n        if (scanResultEntries.length) {\n            yield scanResultEntries;\n        }\n    }\n}\n\n/**\n * @param {Response|ReadableStream|Blob} input\n * @return {Generator<Uint8Array>}\n */\nasync function *unGZipAsyncIterator(input) {\n    if (!isPakoLoaded()) {\n        await loadPako();\n    }\n    let chunks = [];\n    const inflator = new pako.Inflate();\n    pako.Inflate.prototype.onData = function (chunk) {\n        chunks.push(chunk);\n    };\n    for await (const u8Array of iterateAsyncDataSource(input)) {\n        inflator.push(u8Array);\n        for (const chunk of chunks) {\n            yield chunk;\n        }\n        chunks = [];\n    }\n    yield inflator.result;\n    if (inflator.err) {\n        console.error(inflator.msg);\n    }\n}\n\n\nexport class TextParser {\n    buffer = \"\";\n    startHandled = false;\n    metaLines = [];\n    objects = [];\n\n    trimComma(text) {\n        return text.endsWith(\",\") ? text.slice(0, -1) : text;\n    }\n\n    handleStart(line) {\n        if (line === \"[\") { // the first line\n            return;\n        }\n        if (line === \"\") { // meta is separated from the main content by \"\\n\"\n            this.objects.push(this.metaLines.join(\"\"));\n            this.startHandled = true;\n            return;\n        }\n        this.metaLines.push(line);\n    }\n\n    /**\n     * @param {String} line\n     * @param isLastLine\n     */\n    handleLine(line, isLastLine) {\n        if (isLastLine) {\n            this.buffer += line;\n            return;\n        }\n        if (this.buffer) {\n            this.objects.push(this.buffer + line);\n            this.buffer = \"\";\n        } else {\n            this.objects.push(line);\n        }\n    }\n\n    /**\n     * May return an empty array\n     * @param {String} textPart\n     * @return {FlatScanResultEntry[]}\n     * */\n    parsePart(textPart) {\n        const isLastPart = textPart.endsWith(\"\\n]\");\n        /** @type {String[]} */\n        const lines = textPart.split(\"\\n\");\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const isLastLine = i === lines.length - 1;\n\n            if (isLastLine && isLastPart) {\n                continue;\n            }\n\n            if (!this.startHandled) {\n                this.handleStart(line, isLastLine);\n            } else {\n                this.handleLine(line, isLastLine);\n            }\n        }\n        try {\n            /** @type {FlatScanResultEntry[]} */\n            const result = JSON.parse(`[${this.trimComma(this.objects.join(\"\"))}]`);\n            this.objects = [];\n            return result;\n        } catch (e) {\n            console.log(`[${this.trimComma(this.objects.join(\"\"))}]`);\n            console.log(this.objects);\n            console.log(this, {isLastPart, textPart});\n            throw e;\n        }\n\n    }\n\n}\n\n\nlet pakoIsLoaded = false;\nasync function loadPako() {\n    if (!pakoIsLoaded) {\n        const src = \"https://cdn.jsdelivr.net/npm/pako@2.0.4/dist/pako_inflate.min.js\";\n        const integrity = \"sha256-ZIKs3+RZEULSy0dR6c/mke8V9unZm9vuh05TqvtMdGU=\";\n        await appendScript(src, integrity);\n        pakoIsLoaded = true;\n        console.log(\"pako is loaded\");\n    }\n}\nfunction isPakoLoaded() {\n    return pakoIsLoaded;\n}\n\n\n/**\n * \"application/x-gzip\"\n * \"application/gzip\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isGZip(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?gzip/));\n}\n\n/**\n * \"application/json\"\n * \"application/json; charset=utf-8\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isJSON(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?json/));\n}\n","import {computed, markRaw, ref, unref, watch, } from \"vue\";\nimport {clearSearch} from \"./search.js\";\nimport {folderDummy} from \"./entry.js\";\nimport {dateToDayDateString, sleep} from \"../util.js\";\nimport {addMessage} from \"./debug.js\";\nimport {parseScan} from \"./scan-parser.js\";\nimport {limit} from \"./entries.js\";\n\n\n/** @type {import(\"vue\").Ref<ScanMeta>} */\nexport const meta = ref(null);\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst root = ref(null);\n\n// A hack to run recomputing of a computed property\nexport const parsingStateNumber = ref(0);\n\n/**\n * @param {Blob|Response} input\n * @return {Promise<void>}\n */\nexport async function setScan(input) {\n    let metaInited = false;\n    let rootInited = false;\n\n    console.time(\"setScan\");\n    let time = Date.now();\n    for await (const {meta: scanMeta, root: rootEntry, rootUpdated: rootContentUpdated} of parseScan(input)) {\n        if (!metaInited && scanMeta) {\n            meta.value = markRaw(scanMeta);\n            metaInited = true;\n        }\n        if (!rootInited && rootEntry) {\n            root.value = markRaw(rootEntry);\n            globalThis.json = rootEntry;\n            openFolder(rootEntry);\n            rootInited = true;\n        }\n        const now = Date.now();\n        if (rootContentUpdated || now - time > 50) {\n            time = now;\n            parsingStateNumber.value++;\n            await sleep();\n        }\n    }\n    parsingStateNumber.value++;\n    console.timeEnd(\"setScan\");\n\n    clearSearch();\n}\n\n/** @type {import(\"vue\").ComputedRef<string>} */\nexport const separator = computed(() => {\n    return meta.value?.separator || \"/\";\n});\n/** @type {import(\"vue\").ComputedRef<string[]>} */\nexport const scanRootPath = computed(() => {\n    return meta.value?.path || [];\n});\n\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nexport const openedFolder = ref(folderDummy);\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const openedFolders = computed(() => {\n    return openedFolder.value.path;\n});\n\n/** @param {SimpleEntry} entry */\nexport function openFolder(entry) {\n    clearSearch();\n    openedFolder.value = markRaw(unref(entry));\n    limit.value = 50;\n\n    /** @type {SimpleEntry} */\n    globalThis.folder = entry;\n    console.log(\"globalThis.folder:\", entry);\n}\nexport function goBack() {\n    if (openedFolder.value.parent) {\n        openFolder(openedFolder.value.parent);\n    }\n}\n/** @type {import(\"vue\").ComputedRef<Boolean>} */\nexport const empty = computed(() => root.value && openedFolder.value.isEmpty);\n\n\nwatch(meta, async (newValue, oldValue) => {\n    console.log(\"[meta]:\", meta.value);\n    const {files, folders, symlinks, errors, total, scanDate} = meta.value;\n    if (meta.value.scanDate) {\n        addMessage(\n            `files: \"${files}\" folders: \"${folders}\", symlinks: \"${symlinks}\", ` +\n            `errors: \"${errors}\", total: \"${total}\", scanDate: \"${dateToDayDateString(scanDate)}\"`\n        );\n    }\n});\n","<template>\n  <span class=\"scanPath\">\n    <span class=\"parts\" @click=\"goToRoot\" :title=\"title\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"spaced separator\" v-if=\"showSep\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\n//todo title\nimport {computed} from \"vue\";\nimport {scanRootPath, openedFolders, separator, openedFolder, openFolder, meta} from \"../core/folders.js\";\nimport {dateToDayDateString} from \"../util.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst title = computed(() => {\n  if (!meta.value) {\n    return;\n  }\n\n  const {\n      files, folders, symlinks,\n      charDevs, blockDevs, fifos, sockets,\n      total,\n      platform, scanDate\n  } = meta.value;\n\n  function doString(o) {\n    function pad(str) {\n      const count = 3 - Math.trunc((str.length/4));\n      return str + \"\\t\".repeat(count);\n    }\n    return Object.entries(o)\n        .map(([k, v]) => pad(k) + \": \" + v)\n        .join(\"\\n\");\n  }\n  const commonFiles = doString({files, folders, symlinks});\n  const unusualFiles = doString({charDevs, blockDevs, fifos, sockets});\n  const additional = doString({total, platform, scanDate: dateToDayDateString(scanDate)});\n\n  let result;\n  if (platform !== \"win32\") {\n    result = [commonFiles, unusualFiles, additional].join(\"\\n\");\n  } else {\n    result = [commonFiles, additional].join(\"\\n\");\n  }\n  console.log(result);\n  return result;\n});\n\nconst root = computed(() => {\n  const scanPath = [...scanRootPath.value, openedFolder.value.root.name];\n  const str = scanPath.join(separator.value);\n  if (str.startsWith(\"//\")) { // for unix\n    return str.slice(1);\n  }\n  if (meta.value?.platform === \"win32\") { // uppercase win drive letter // todo remove as unnecessary\n    return str[0].toUpperCase() + str.slice(1);\n  }\n  return str;\n});\nconst part1 = computed(() => {\n  return [...root.value].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...root.value].slice(-1).join(\"\");\n});\nconst showSep = computed(() => {\n  return (openedFolders.value.length - 1) && root.value !== \"/\";\n});\n\nfunction goToRoot() {\n  const root = openedFolder.value.root;\n  debugMessageFromEntry(root);\n  openFolder(root);\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.scanPath {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <span class=\"opened-folder\">\n    <span class=\"parts\" @click=\"onClick\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"separator spaced\" v-if=\"!isLast\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\nimport {computed, toRefs} from \"vue\";\nimport {openFolder, separator} from \"../core/folders.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst props = defineProps([\"index\", \"count\", \"entry\"]);\nconst {index, count, entry} = toRefs(props);\n\nconst isLast = computed(() => {\n  return index.value + 1 === count.value;\n});\nconst part1 = computed(() => {\n  return [...entry.value.name].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...entry.value.name].slice(-1).join(\"\");\n});\n\nfunction onClick() {\n  debugMessageFromEntry(entry.value);\n  openFolder(entry.value);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.opened-folder {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n\n    width: 100%;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part { // to use with max-width limitation // not works with  `display: contents;`\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: pre;\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n<div class=\"address\" @contextmenu=\"onContextmenu\">\n  <AddressBar_Part>\n    <AddressBar_Base/>\n  </AddressBar_Part>\n  <AddressBar_Part\n      v-for=\"(folder, i) of openedFolders.slice(1)\"\n  >\n    <AddressBar_Folder\n        :entry=\"folder\"\n        :index=\"i\"\n        :count=\"openedFolders.slice(1).length\"\n    />\n  </AddressBar_Part>\n</div>\n</template>\n\n<script setup>\nimport AddressBar_Base from \"./AddressBar_Base.vue\";\nimport AddressBar_Folder from \"./AddressBar_Folder.vue\";\nimport AddressBar_Part from \"./AddressBar_Part.vue\";\nimport {meta, openedFolder, openedFolders, separator} from \"../core/folders.js\";\n\n/** @param {MouseEvent} event */\nasync function onContextmenu(event) {\n  event.preventDefault();\n  const folderPath = [...meta.value.path, ...openedFolder.value.path.map(entry => entry.name)].join(separator.value);\n  console.log(\"Copy to clipboard:\", folderPath);\n  await navigator.clipboard.writeText(folderPath);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.address {\n  display: flex;\n  overflow-x: scroll;\n  padding-left: 6px;\n\n  scrollbar-width: none; // firefox\n  &::-webkit-scrollbar {\n    -webkit-appearance: none;\n    width: 0;\n    height: 0;\n    background: transparent;\n    display: none;\n  }\n}\n</style>\n","<template>\n  <div class=\"file-select\">\n    <label>\n      Select file\n      <input type=\"file\" accept=\"application/json,application/gzip\" @change=\"onChange\">\n    </label>\n    <hr>\n  </div>\n</template>\n\n<script setup>\nimport {setScan} from \"../core/folders.js\";\n\nfunction onChange(event) {\n  /** @type {File} */\n  const file = event.target.files[0];\n  return setScan(file);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.file-select label {\n  cursor: pointer;\n  &:hover {\n    text-decoration: underline;\n  }\n}\ninput {\n  display: none;\n}\n</style>\n","<template>\n  <tr class=\"row\"\n      @click=\"onClick\"\n      @mousedown=\"onMousedown\"\n      @mouseover=\"onMouseover\"\n      @mouseleave=\"onMouseleave\"\n      :title=\"title\"\n      :class=\"{error}\"\n  >\n      <td class=\"icon\">{{icon}}</td>\n      <td class=\"name\">{{entry.name}}</td>\n      <td class=\"size\" :class=\"sizeClass\">{{size}}</td>\n      <td class=\"mtime\">{{mtime}}</td>\n<!--      <td class=\"type\">{{entry.type}}</td>-->\n<!--      <td class=\"filler\"></td>-->\n  </tr>\n</template>\n\n<script setup>\nimport {toRefs, computed} from \"vue\";\nimport {meta, openedFolder, openFolder, parsingStateNumber, separator} from \"../core/folders.js\";\nimport {bytesToSizeWinLike, dateToDayDateTimeString, isImage, isVideo} from \"../util.js\";\nimport {hoveredEntry} from \"../core/entries.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst props = defineProps([\"entry\"]);\n\nconst size = computed(() => {\n  if (parsingStateNumber.value) {\n    // force recomputing on change\n  }\n  return entry.value.hasErrors ? \"\" : bytesToSizeWinLike(entry.value.size);\n});\n\nconst sizeClass = computed(() => {\n  if (size.value === \"0 B\") {\n    return \"Z\";\n  }\n  return size.value.split(\" \")[1];\n});\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst entry = toRefs(props).entry;\n\n/** @type {import(\"vue\").Ref<Boolean>} */\nconst error = computed(() => {\n  return entry.value.hasErrors;\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst mtime = computed(() => {\n  if (entry.value.mtime === undefined) {\n    return \"\";\n  }\n  const time = dateToDayDateTimeString(entry.value.mtime, false);\n  return time.slice(0, -3); // trim seconds\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst title = computed(() => {\n  if (entry.value.hasErrors) {\n    return JSON.stringify(entry.value.errors[0], null, \" \");\n  }\n  if (entry.value.type === \"symlink\") {\n    return entry.value.pathTo;\n  }\n});\n\n/** @type {import(\"vue\").Ref<String>} */\nconst icon = computed(() => {\n  if (entry.value.type === \"folder\") {\n    return \"📁\";\n  } else if (entry.value.type === \"file\") {\n    if (isVideo(entry.value.name)) {\n      return \"🎦\";\n    } else if (isImage(entry.value.name)) {\n      return \"🖼\";\n    }\n    return \"📄\";\n  } else if (entry.value.type === \"symlink\") {\n    return \"🔗\";\n  }\n  return \"👾\";\n});\n\nfunction onClick(event) {\n  debugMessageFromEntry(entry.value);\n\n  if (entry.value.type === \"folder\") {\n    openFolder(entry.value);\n  }\n}\n\n/** @param {MouseEvent} event */\nfunction onMousedown(event) {\n  const MIDDLE_BUTTON = 1;\n  const RIGHT_BUTTON = 2;\n  if (event.button === MIDDLE_BUTTON) {\n    event.preventDefault();\n    console.log(\n        entry.value,\n        [...meta.value.path,...entry.value.path.map(e => e.name)].join(separator.value).replace(\"//\", \"/\")\n    );\n    \n    if (openedFolder.value !== entry.value.parent) {\n      openFolder(entry.value.parent);\n    }\n  }\n}\n\nfunction onMouseover(event) {\n  hoveredEntry.value = entry.value;\n}\nfunction onMouseleave(event) {\n  hoveredEntry.value = null;\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.row {\n  width: 100%;\n  min-height: 28px;\n  display: flex;\n  align-items: center;\n  &:hover {\n    background-color: var(--blue-2);\n  }\n  * {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n  }\n  td {\n    &.icon {\n      border-left: 2px solid transparent;\n      width: 24px;\n      text-align: center;\n      user-select: none;\n    }\n    &.name {\n      display: block;\n      //width: 880px; // gets it from the parent\n      white-space: pre; // to display tailing spaces\n    }\n    &.size {\n      text-align: end;\n      min-width: 80px;\n      &.Z {\n        color: #888;\n      }\n      &.B {\n        color: #666;\n      }\n      &.KB {\n        color: #0b0;\n      }\n      &.MB {\n        color: #0070dd;\n      }\n      &.GB {\n        color: #a335ee;\n      }\n      &.TB {\n        color: #ff8000;\n      }\n    }\n    &.mtime {\n      text-align: end;\n      width: 145px;\n      color: #777;\n    }\n    &.type {\n      text-align: end;\n      width: 58px;\n      user-select: none;\n    }\n    //&.filler {\n    //  width: inherit;\n    //}\n  }\n  &.error {\n    .icon {\n      border-left: 2px solid red;\n    }\n  }\n}\n</style>\n","<template>\n<div class=\"intersection\" ref=\"intersection\"></div>\n</template>\n\n<script setup>\nimport {onBeforeUnmount, onMounted, ref} from \"vue\";\nimport {count, limit} from \"../core/entries.js\";\n\n/** @param {IntersectionObserverEntry[]} entries */\nconst callback = (entries) => {\n  const [entry] = entries;\n  if (entry.isIntersecting) {\n    if (count.value > limit.value) {\n      limit.value = limit.value + 50;\n    }\n  }\n}\nconst observer = new IntersectionObserver(callback);\n\n/** @type {import(\"vue\").Ref<HTMLElement>} */\nconst intersection = ref(null);\n\nonMounted(() => {\n  observer.observe(intersection.value);\n});\nonBeforeUnmount(() => {\n  observer.disconnect();\n});\n</script>\n\n<style scoped>\n.intersection {\n  width: 100%;\n  position: relative;\n  bottom: 120px;\n}\n</style>\n","<template>\n  <div class=\"content\"\n       @contextmenu=\"onContextMenu\"\n  >\n    <table class=\"rows\" v-if=\"listLimited.length\">\n      <tbody>\n        <Row v-for=\"entry of listLimited\" :entry=\"entry\"/>\n        <IntersectionRow/>\n      </tbody>\n    </table>\n    <div class=\"empty-message\" v-if=\"empty && !error\">\n      <span>The folder is empty.</span>\n    </div>\n    <div class=\"error-message\" v-if=\"error\">\n      <div>\n        <h2>Error</h2>\n        <table>\n          <tr>\n            <td>syscall</td>\n            <td><pre>{{error.syscall}}</pre></td>\n          </tr>\n          <tr>\n            <td>code</td>\n            <td><pre>{{error.code}}</pre></td>\n          </tr>\n          <tr>\n            <td>errno</td>\n            <td><pre>{{error.errno}}</pre></td>\n          </tr>\n        </table>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport Row from \"./Row.vue\";\nimport IntersectionRow from \"./IntersectionRow.vue\";\nimport {goBack, empty, openedFolder} from \"../core/folders.js\";\nimport {listLimited} from \"../core/entries.js\";\nimport {computed, onMounted, ref} from \"vue\";\n\n/** @type {import(\"vue\").ComputedRef<ScanError>} */\nconst error = computed(() => {\n  if (openedFolder.value.hasErrors) {\n    return openedFolder.value.errors[0];\n  }\n  return false;\n});\n\nfunction onContextMenu(event) {\n  event.preventDefault();\n  goBack();\n}\n\nconst nameElemWidth = ref(\"880px\");\nonMounted(() => {\n  const w = document.body.offsetWidth;\n  if (w < 1280) {\n    let px = 880 - (1280 - w);\n    px = px < 140 ? 140 : px;\n    nameElemWidth.value = `${px}px`;\n  }\n});\n\n</script>\n\n\n<style lang=\"scss\" scoped>\n::v-deep(.row .name) {\n  width: v-bind(nameElemWidth);\n}\n\n.content {\n  width: 100%;\n  overflow: auto;\n  .rows {\n    width: 100%;\n    overflow: auto;\n  }\n  .empty-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--gray-2);\n  }\n  .error-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    color: var(--red-1);\n    div {\n      h2 {\n        margin: 0;\n        padding-bottom: 6px;\n        padding-left: 2px;\n      }\n      pre {\n        display: inline;\n      }\n      td {\n        padding-right: 3px;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"status\">\n    <span>Items count: {{count}}</span>\n    <span v-show=\"hoveredEntry\">. Hover item's size: {{size}}</span>\n  </div>\n</template>\n\n<script setup>\nimport {count, hoveredEntry} from \"../core/entries.js\";\nimport {computed} from \"vue\";\nimport {bytesToSizeWinLike} from \"../util.js\";\n\nconst size = computed(() => hoveredEntry.value?.size && bytesToSizeWinLike(hoveredEntry.value.size));\n</script>\n\n<style scoped>\n.status {\n  padding: 2px 2px 2px 6px;\n}\n</style>\n","<template>\n  <div class=\"switch\">\n    <button\n        class=\"order-by-name\"\n        title=\"Order by name\"\n        @click=\"onN\"\n        :class=\"{active: orderBy === 'name'}\"\n    >{{ orders.name  ? \"N\" : \"n\"}}</button>\n    <button\n        class=\"order-by-size\"\n        title=\"Order by size\"\n        @click=\"onS\"\n        :class=\"{active: orderBy === 'size'}\"\n    >{{ orders.size  ? \"S\" : \"s\"}}</button>\n    <button\n        class=\"order-by-date\"\n        title=\"Order by date\"\n        @click=\"onD\"\n        :class=\"{active: orderBy === 'mtime'}\"\n    >{{ orders.mtime ? \"D\" : \"d\"}}</button>\n  </div>\n</template>\n\n<script setup>\nimport {orderBy, toggleOrder, orders} from \"../core/entries.js\";\n\nfunction onN() {\n  if (orderBy.value === \"name\") {\n    toggleOrder();\n  }\n  orderBy.value = \"name\";\n}\nfunction onS() {\n  if (orderBy.value === \"size\") {\n    toggleOrder();\n  }\n  orderBy.value = \"size\";\n}\nfunction onD() {\n  if (orderBy.value === \"mtime\") {\n    toggleOrder();\n  }\n  orderBy.value = \"mtime\";\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.switch {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\nbutton.active {\n  font-weight: bold;\n}\n\nbutton {\n  margin: 1px 3px;\n  padding: 2px 6px;\n  outline-width: 1px;\n  outline-color: var(--blue-1);\n  border: 1px solid var(--gray-2);\n  box-sizing: border-box;\n  background-color: var(--gray-1);\n  &:hover {\n    border-bottom: var(--blue-1) solid 1px;\n    background: var(--blue-2);\n  }\n  &:active {\n    background: var(--blue-3);\n  }\n}\n</style>\n","<template>\n  <div class=\"main\">\n    <Switch     style=\"grid-area: switch;\"/>\n    <AddressBar style=\"grid-area: address;\"/>\n    <Search     style=\"grid-area: search;\"/>\n    <Tabs       style=\"grid-area: tabs;\"/>\n    <Content    style=\"grid-area: content;\"/>\n    <Status     style=\"grid-area: status;\"/>\n    <Debug      style=\"grid-area: debug;\"/>\n  </div>\n</template>\n\n<script setup>\nimport AddressBar from \"./AddressBar.vue\";\nimport Search from \"./Search.vue\";\nimport Tabs from \"./Tabs.vue\";\nimport Content from \"./Content.vue\";\nimport Status from \"./Status.vue\";\nimport Switch from \"./Switch.vue\";\nimport Debug from \"./Debug.vue\";\nimport {onMounted} from \"vue\";\nimport {setScan} from \"../core/folders.js\";\nimport {search} from \"../core/search.js\";\n\n\n// Already opened directory, no need to open with input\nonMounted(async () => {\n  const url = new URL(location.href);\n  const filepath = url.searchParams.get(\"filepath\");\n  if (filepath) {\n    /** @type {Response} */\n    const response = await fetch(filepath);\n    await setScan(response);\n  }\n  const _search = url.searchParams.get(\"search\");\n  if (_search) {\n    search.value = _search;\n  }\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.main {\n  grid-template-areas: \"switch address search \"\n                       \"tabs   content content\"\n                       \"status status  status \"\n                       \"debug  debug   debug  \";\n\n  display: grid;\n  grid-template-columns: 7em 2fr 1fr;\n  grid-template-rows:    2em 1fr;\n\n  height: 720px;\n  max-height: 100vh;\n  width: 1280px;\n  max-width: 100%;\n  box-sizing: border-box;\n\n  grid-gap: 1px;\n  border: 1px solid var(--gray-2);\n  background-color: var(--gray-2);\n  * {\n    background-color: white;\n  }\n}\n</style>\n","import {createApp} from \"vue\";\nimport App from \"./App.vue\";\n\ncreateApp(App).mount(\"#app\");\n"],"names":["relList","document","createElement","supports","link","querySelectorAll","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","ep","fetchOpts","script","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","href","p","setImmediate","globalThis","port1","port2","MessageChannel","queue","onmessage","shift","callback","postMessage","push","ms","Promise","resolve","setTimeout","videoExtensions","imageExtensions","dateValue","utc","_date","Date","str","toString","padStart","warn","_utc","year","month","date","pad2","hours","minutes","seconds","time","dateToDayDateString","async","dataSource","Response","body","ReadableStream","stream","reader","getReader","done","value","read","iterateReadableStream","Blob","part","blob","chunkSize","index","blobChunk","slice","size","blob2","Uint8Array","arrayBuffer","iterateBlob","bytes","i","Math","floor","log","result","pow","number","trunc","toPrecision","toTruncPrecision3","sort","ref","orderBy","orders","name","mtime","reverseOrder","computed","compare","Intl","Collator","numeric","sensitivity","pre","cur","k","entries","parsingStateNumber","openedFolder","folders","comparator","files","symlinks","fifos","charDevs","blockDevs","sockets","limit","list","search","length","searchResult","listLimited","count","hoveredEntry","debugMessage","message","entry","isProxy","toRaw","hasErrors","dateToDayDateTimeString","btime","bytesToSizeWinLike","entryTypes","constructor","parent","errorsIDMap","_size","errors","map","get","id","pathTo","content","addChild","this","children","increaseContentSize","addHardlinks","entries2","total","hardlinks","hardlinksTotal","_contentSize","filter","e","Boolean","root","path","rootId","Map","hidMap","setMeta","meta2","meta","errorsMap","Object","v","code","syscall","errno","split","Number","parse","sEntriesPart","rootUpdated","pid","simpleEntry","SimpleEntry","set","hid","array","processHIDMapAsync","simpleEntries","timeNow","now","sleep","totalLinks","forEach","then","console","timeEnd","folderDummy","rawResult","defineProperty","join","watch","performSearchDebounced","runnable","timerId","apply","arguments","debounce","performSearch","folder","request","folderRaw","isReactive","time1","performance","search2","startsWith","justSearch","plus","plusRange","range","match","groups","text","_plus","min","max","findAll","_range","blue","word","includes","parts","o","curWord","search3","searcher","toFixed","time2","sortedResult","resultSet","Set","allSize","reduce","acc","val","computeEntrySize","filesSize","searchText","customSearchText","excludeSet","childrenSize","child","has","predicate","res","partSize","list2","folderEntry","takePart","listAllEntries","curTime","input","parser","EntryStreamParser","contentType","headers","isGZip","obj","decoder","TextDecoder","textParser","TextParser","uint8Array","pakoIsLoaded","src","reject","onload","onerror","event","crossOrigin","append","appendScript","loadPako","chunks","inflator","pako","Inflate","prototype","onData","chunk","u8Array","iterateAsyncDataSource","err","error","msg","unGZipAsyncIterator","textPart","decode","scanResultEntries","parsePart","parseGZippedJSONScan","isJSON","streamParseJSONScan","newValue","oldValue","trimComma","endsWith","handleStart","line","objects","metaLines","startHandled","handleLine","isLastLine","buffer","isLastPart","lines","JSON","metaInited","rootInited","scanMeta","rootEntry","rootContentUpdated","parseScan","markRaw","json","separator","scanRootPath","openedFolders","unref","empty","isEmpty","scanDate","title","platform","count2","repeat","pad","commonFiles","doString","unusualFiles","additional","root2","toUpperCase","part1","part2","showSep","root3","toRefs","props","isLast","preventDefault","folderPath","navigator","clipboard","writeText","setScan","target","sizeClass","stringify","icon","filename","ext","isVideo","isImage","button","replace","observer","IntersectionObserver","isIntersecting","intersection","disconnect","nameElemWidth","w","offsetWidth","px","url","URL","location","filepath","searchParams","response","fetch","_search","createApp","mount"],"mappings":"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"}