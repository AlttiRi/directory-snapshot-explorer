{"version":3,"file":"index.js","sources":["node-modules:///vite/modulepreload-polyfill","source-maps:///util.js","source-maps:///core/entries.js","source-maps:///core/debug.js","source-maps:///core/entry.js","source-maps:///core/search.js","source-maps:///core/folders.js","source-maps:///components/AddressBar_Base.vue","source-maps:///components/AddressBar_Folder.vue","source-maps:///components/FileSelect.vue","source-maps:///components/Row.vue","source-maps:///components/Content.vue","source-maps:///components/Main.vue","source-maps:///main.js"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","export const setImmediate = globalThis.setImmediate || /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\nexport function sleep(ms) {\n    if (ms === undefined) {\n        return new Promise(resolve => setImmediate(resolve));\n    }\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const shuffle = () => Math.random() >= 0.5 ? -1 : 1;\n\nconst videoExtensions = [\"mp4\", \"webm\", \"mkv\", \"avi\"];\nexport function isVideo(filename) {\n    const {ext} = filename.match(/(?<ext>[^\\.]+)$/).groups;\n    return videoExtensions.includes(ext);\n}\nconst imageExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"tiff\", \"webp\"];\nexport function isImage(filename) {\n    const {ext} = filename.match(/(?<ext>[^\\.]+)$/).groups;\n    return imageExtensions.includes(ext);\n}\n\nexport function debounce(runnable, ms = 50) {\n    let timerId;\n    return function() {\n        // console.log({timerId});\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            runnable.apply(this, arguments);\n            timerId = null;\n        }, ms);\n    }\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\nexport function dateToDayDateString(dateValue, utc = true) {\n    const _date = new Date(dateValue);\n    function pad(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n    const _utc = utc ? \"UTC\" : \"\";\n    const year  = _date[`get${_utc}FullYear`]();\n    const month = _date[`get${_utc}Month`]() + 1;\n    const date  = _date[`get${_utc}Date`]();\n\n    // if server error (or missed)\n    if (Number(_date) === 0) {\n        console.warn(\"date is 1970.01.01\");\n        return \"\";\n    }\n\n    return year + \".\" + pad(month) + \".\" + pad(date);\n}\n\nexport function structuredClone(object) {\n    return new Promise(resolve => {\n        const {port1, port2} = new MessageChannel();\n        port1.onmessage = function(message) {\n            resolve(message.data);\n        };\n        port2.postMessage(object);\n    });\n}\n","import {computed, ref} from \"vue\";\nimport {search, searchResult} from \"./search.js\";\nimport {openedFolder} from \"./folders.js\";\n\n\nexport const sort = ref(true);\n\nconst {compare} = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: \"accent\",\n});\nexport function comparator(pre, cur) {\n    if (sort.value) {\n        return compare(pre.name, cur.name);\n    }\n    return 0;\n}\n\nexport const folders = computed(() => openedFolder.value.folders);\nexport const files = computed(() => openedFolder.value.files);\nexport const symlinks = computed(() => openedFolder.value.symlinks);\nexport const fifos = computed(() => openedFolder.value.fifos);\nexport const charDevs = computed(() => openedFolder.value.charDevs);\nexport const blockDevs = computed(() => openedFolder.value.blockDevs);\nexport const sockets = computed(() => openedFolder.value.sockets);\nexport const entries = computed(() => [\n    ...folders.value.sort(comparator),\n    ...files.value.sort(comparator),\n    ...symlinks.value.sort(comparator),\n    ...fifos.value.sort(comparator),\n    ...charDevs.value.sort(comparator),\n    ...blockDevs.value.sort(comparator),\n    ...sockets.value.sort(comparator),\n]);\n\n\n/** @type {number} */\nconst limit = 1000;\n\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const list = computed(() => {\n    if (search.value.length) {\n        return searchResult.value;\n    }\n    return entries.value;\n});\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const listLimited = computed(() => {\n    return list.value.slice(0, limit);\n});\n/** @type {import(\"vue\").ComputedRef<Number>} */\nexport const count = computed(() => {\n    if (searchResult.value.length > limit) {\n        return searchResult.value.length;\n    }\n    return list.value.length;\n});\n","import {ref} from \"vue\";\n\nexport const debugMessage = ref(\"\");\nexport function addMessage(message) {\n    debugMessage.value = message;\n}\nexport function appendMessage(message) {\n    debugMessage.value += message;\n}\n","/**\n * Meta info of a scan.\n * @typedef {Object} Meta\n * @property {String[]} path\n * @property {String} separator\n * @property {Number} scanDate\n * @property {String} platform\n * @property {Number} files\n * @property {Number} folders\n * @property {Number} symlinks\n * @property {Number} fifos\n * @property {Number} charDevs\n * @property {Number} blockDevs\n * @property {Number} sockets\n * @property {Number} unknowns\n * @property {Number} total\n * @property {Number} errors\n * @property {Error[]} unknownErrors\n */\n// scans result types: flat, tree\n\n/**\n * Scan error.\n * @typedef {Object} ScanError\n * @property {String} syscall - \"scandir\", \"readlink\", ...\n * @property {String} code    - \"EPERM\", ...\n * @property {Number} errno   - \"-4048\", ...\n * @property {String} path    - \"C:\\System Volume Information\", ...\n */\n\n/**\n * @typedef {\n * \"folder\" |\n * \"file\" |\n * \"symlink\" |\n * \"fifo\" |\n * \"charDev\" |\n * \"blockDev\" |\n * \"socket\"\n * } EntryType\n */\n\n/** @type {EntryType[]} */\nexport const entryTypes = [\"folder\", \"file\", \"symlink\", \"fifo\", \"charDev\", \"blockDev\", \"socket\"];\n\n/**\n * Additional properties.\n * @typedef {Object} EntryMeta\n * @property {String?} pathTo - where symlink goes (Absolute path)\n */\n\nexport class SimpleEntry {\n    // [Symbol.toStringTag] = \"SimpleEntry\"; // Disables reactivity, BTW.\n    /**\n     * @param {Object} init\n     * @param {String} init.name\n     * @param {SimpleEntry|null} init.parent\n     * @param {EntryType} init.type\n     * @param {EntryMeta} [init.meta]\n     * @param {ScanError[]} [init.errors]\n     */\n    constructor({name, parent, type, meta, errors}) {\n        this.name = name;\n        this.parent = parent;\n        this.type = type;\n\n        if (meta) {\n            this.meta = meta;\n        }\n        if (errors) {\n            this.errors = errors;\n        }\n    }\n    /** @param {SimpleEntry} entry */\n    addChild(entry) {\n        if (!this.children) {\n            /** @type {SimpleEntry[]|undefined} */\n            this.children = [];\n        }\n        this.children.push(entry);\n    }\n\n    /** @return {SimpleEntry[]} */\n    get folders() {\n        return this.children?.filter(e => e.type === \"folder\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get files() {\n        return this.children?.filter(e => e.type === \"file\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get symlinks() {\n        return this.children?.filter(e => e.type === \"symlink\") || [];\n    }\n\n    /** @return {SimpleEntry[]} */\n    get fifos() {\n        return this.children?.filter(e => e.type === \"fifo\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get charDevs() {\n        return this.children?.filter(e => e.type === \"charDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get blockDevs() {\n        return this.children?.filter(e => e.type === \"blockDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get sockets() {\n        return this.children?.filter(e => e.type === \"socket\") || [];\n    }\n\n    /** @return {Boolean} */\n    get isEmpty() {\n        return !Boolean(this.children?.length);\n    }\n    /** @return {Boolean} */\n    get hasErrors() {\n        return Boolean(this.errors?.length);\n    }\n    /** @return {SimpleEntry} */\n    get root() {\n        if (!this.parent) {\n            return this;\n        }\n        return this.parent.root;\n    }\n    /** @return {SimpleEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n}\n\n\n/**\n * It just a filename.\n * @typedef {String} SimpleScanEntry\n */\n\n/**\n * @typedef {String} ScanSymlink\n * @property {String} name\n * @property {String} [pathTo]\n * @property {ScanError[]} [errors]\n */\n\n/**\n * @typedef {Object} ScanFolder\n * @property {String} name\n * @property {ScanFolder[]} [folders]\n * @property {SimpleScanEntry[]} [files]\n * @property {ScanSymlink[]|SimpleScanEntry[]} [symlinks]\n * @property {SimpleScanEntry[]} [fifos]\n * @property {SimpleScanEntry[]} [charDevs]\n * @property {SimpleScanEntry[]} [blockDevs]\n * @property {SimpleScanEntry[]} [sockets]\n * @property {ScanError[]} [errors]\n */\n\n\n/**\n * The scan result as one object.\n * @typedef {ScanFolder} TreeScanResult\n * @property {Meta} meta\n */\n\n/**\n * @param {ScanFolder} rootFolder\n * @param {SimpleEntry|null} parent\n * @return {SimpleEntry}\n */\nexport function parseEntries(rootFolder, parent = null) {\n    const root = new SimpleEntry({\n        name: rootFolder.name,\n        type: \"folder\",\n        errors: rootFolder.errors,\n        parent\n    });\n    if (rootFolder.folders) {\n        rootFolder.folders.forEach(folder => {\n            root.addChild(parseEntries(folder, root));\n        });\n    }\n    /** @type {EntryType[]} */\n    const simpleTypes = [\"file\", \"fifo\", \"charDev\", \"blockDev\", \"socket\"];\n    simpleTypes.forEach(type => {\n        if (rootFolder[type+\"s\"]) {\n            rootFolder[type+\"s\"].forEach(file => {\n                root.addChild(new SimpleEntry({\n                    name: file,\n                    parent: root,\n                    type: type\n                }));\n            });\n        }\n    });\n    if (rootFolder.symlinks) {\n        rootFolder.symlinks.forEach(symlink => {\n            if (typeof symlink === \"string\") { // for old scans\n                root.addChild(new SimpleEntry({\n                    name: symlink,\n                    parent: root,\n                    type: \"symlink\"\n                }));\n                return;\n            }\n            /** @type {EntryMeta|null} */\n            const meta = symlink.pathTo ? {\n                pathTo: symlink.pathTo\n            } : null;\n            root.addChild(new SimpleEntry({\n                name: symlink.name,\n                parent: root,\n                type: \"symlink\",\n                meta,\n                errors: symlink.errors\n            }));\n        });\n    }\n    return root;\n}\n\n/** @type {SimpleEntry} */\nexport const folderDummy = new SimpleEntry({\n    name: \"\",\n    parent: null,\n    type: \"folder\"\n});\n","import {isReactive, markRaw, ref, toRaw, watch} from \"vue\";\nimport {debounce, sleep} from \"../util.js\";\nimport {openedFolder} from \"./folders.js\";\nimport {comparator} from \"./entries.js\";\nimport * as debug from \"./debug.js\";\nimport {entryTypes} from \"./entry.js\";\n\n/** @type {import(\"vue\").Ref<string>} */\nexport const search = ref(\"\"); // [v-model]\nexport function clearSearch() {\n    search.value = \"\";\n}\n\n/** @type {import(\"vue\").Ref<SimpleEntry[]>} */\nexport const searchResult = ref([]);\nfunction clearSearchResult() {\n    setSearchResult([]);\n}\n/** * @param {SimpleEntry[]} result */\nfunction setSearchResult(result) {\n    searchResult.value = markRaw(result);\n\n    console.log(\"globalThis.search:\", globalThis.search = result);\n    Object.defineProperty(globalThis.search, \"download\", {\n        get() {\n            console.log(\"download\"); // todo\n        }\n    });\n}\n\n//todo search by type\n// /type:folder/\n//todo check linked list perf for large search\nconst performSearchDebounced = debounce(performSearch, 300);\nasync function performSearch() {\n    const folder = openedFolder.value;\n    const request = search.value;\n\n    // Do unProxy. Up to x40 in comparison with default reactive ref.\n    const folderRaw = isReactive(folder) ? toRaw(folder) : folder;\n\n    const time1 = performance.now();\n    const result = await searcher(folderRaw, request);\n    if (!result) {\n        return;\n    }\n    const searchTime = performance.now() - time1;\n    debug.addMessage(`Search time: ${searchTime.toFixed(2)} ms; `);\n    await sleep();\n\n    const time2 = performance.now();\n    const sortedResult = result.sort(comparator);\n    const sortTime = performance.now() - time2;\n    debug.appendMessage(`Sort time: ${sortTime.toFixed(2)} ms; `);\n    await sleep();\n\n    setSearchResult(sortedResult);\n    debug.appendMessage(`${result.length} items; search: ${request}`);\n}\n\n/**\n * @param {SimpleEntry} folder\n * @param {string} search\n * @return {Promise<SimpleEntry[]|false>}\n */\nasync function searcher(folder, search) {\n    if (search.startsWith(\"/\")) {\n        const {type, word} = search.match(/\\/type:(?<type>[^\\/]+)\\/?(?<word>[^\\/]*)/)?.groups || {};\n        if (type) {\n            console.log({type, word});\n            if (entryTypes.includes(type)) {\n                return findAll(folder, (entry) => {\n                    return entry.type === type && entry.name.includes(word);\n                });\n            }\n        }\n    } else {\n        return findAll(folder, (entry) => {\n            return entry.name.includes(search);\n        });\n    }\n    return false;\n}\n\nwatch(search, async (newValue, oldValue) => {\n    const isEmptyString = !newValue;\n    if (isEmptyString) {\n        clearSearchResult();\n        return;\n    }\n    // In order to \"no debounce by paste event\"\n    if (newValue.length - oldValue.length > 1) {\n        await performSearch();\n    } else {\n        await performSearchDebounced();\n    }\n});\n\n/**\n * @param {SimpleEntry} folder\n * @param {function(SimpleEntry)} predicate\n * @return {Promise<SimpleEntry[]>}\n */\nasync function findAll(folder, predicate) {\n    let res = [];\n    let time = Date.now();\n    for (const entries of listAllEntries(folder)) {\n        const curTime = Date.now();\n        if (curTime - time > 15) {\n            time = curTime;\n            await sleep();\n        }\n        for (const entry of entries) {\n            if (predicate(entry)) {\n                res.push(entry);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * List all entries by parts.\n * @param {SimpleEntry} folder\n * @return {Generator<SimpleEntry[]>}\n */\nfunction *listAllEntries(folder) {\n    const partSize = 1000;\n    /** @type {SimpleEntry[]} */\n    let list = [];\n    /** @param {SimpleEntry} folderEntry */\n    function *takePart(folderEntry) {\n        for (const entry of (folderEntry.children || [])) {\n            if (entry.type === \"folder\") {\n                yield *takePart(entry);\n            }\n            list.push(entry);\n            if (list.length === partSize) {\n                yield list;\n                list = [];\n            }\n        }\n    }\n    yield *takePart(folder);\n    yield list;\n}\n","import {computed, markRaw, ref, unref, watch} from \"vue\";\nimport {clearSearch} from \"./search.js\";\nimport {folderDummy, parseEntries} from \"./entry.js\";\nimport {dateToDayDateString} from \"../util.js\";\nimport {addMessage} from \"./debug.js\";\n\n\n/** @type {import(\"vue\").Ref<Meta>} */\nexport const meta = ref(null);\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst json = ref(null);\n/** @param {TreeScanResult} object */\nexport function setJson(object) {\n    meta.value = markRaw(object.meta);\n\n    console.time(\"parseEntries\");\n    const result = parseEntries(object);\n    console.timeEnd(\"parseEntries\");\n\n    json.value = markRaw(result);\n    globalThis.json = result;\n\n    openFolder(result);\n    clearSearch();\n}\n\n/** @type {import(\"vue\").ComputedRef<string>} */\nexport const separator = computed(() => {\n    return meta.value?.separator || \"/\";\n});\n/** @type {import(\"vue\").ComputedRef<string[]>} */\nexport const scanRootPath = computed(() => {\n    return meta.value?.path || [];\n});\n\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nexport const openedFolder = ref(folderDummy);\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const openedFolders = computed(() => {\n    return openedFolder.value.path;\n});\n\n/** @param {SimpleEntry} entry */\nexport function openFolder(entry) {\n    clearSearch();\n    openedFolder.value = markRaw(unref(entry));\n}\nexport function goBack() {\n    if (openedFolder.value.parent) {\n        openFolder(openedFolder.value.parent);\n    }\n}\n/** @type {import(\"vue\").ComputedRef<Boolean>} */\nexport const empty = computed(() => json.value && openedFolder.value.isEmpty);\n\n\nwatch(meta, async (newValue, oldValue) => {\n    console.log(\"[meta]:\", meta.value);\n    const {files, folders, symlinks, errors, total, scanDate} = meta.value;\n    if (meta.value.scanDate) {\n        addMessage(\n            `files: \"${files}\" folders: \"${folders}\", symlinks: \"${symlinks}\", ` +\n            `errors: \"${errors}\", total: \"${total}\", scanDate: \"${dateToDayDateString(scanDate)}\"`\n        );\n    }\n});\n","<template>\n  <span class=\"scanPath\">\n    <span class=\"parts\" @click=\"goToRoot\" :title=\"title\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"spaced separator\" v-if=\"showSep\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\n//todo title\nimport {computed} from \"vue\";\nimport {scanRootPath, openedFolders, separator, openedFolder, openFolder, meta} from \"../core/folders.js\";\nimport {dateToDayDateString} from \"../util.js\";\n\nconst title = computed(() => {\n  if (!meta.value) {\n    return;\n  }\n\n  const {\n      files, folders, symlinks,\n      charDevs, blockDevs, fifos, sockets,\n      total,\n      platform, scanDate\n  } = meta.value;\n\n  function doString(o) {\n    function pad(str) {\n      const count = 3 - Math.trunc((str.length/4));\n      console.log(str, count);\n      return str + \"\\t\".repeat(count);\n    }\n    return Object.entries(o)\n        .map(([k, v]) => pad(k) + \": \" + v)\n        .join(\"\\n\");\n  }\n  const commonFiles = doString({files, folders, symlinks});\n  const unusualFiles = doString({charDevs, blockDevs, fifos, sockets});\n  const additional = doString({total, platform, scanDate: dateToDayDateString(scanDate)});\n\n  let result;\n  if (platform !== \"win32\") {\n    result = [commonFiles, unusualFiles, additional].join(\"\\n\");\n  } else {\n    result = [commonFiles, additional].join(\"\\n\");\n  }\n  console.log(result);\n  return result;\n});\n\nconst root = computed(() => {\n  const scanPath = [...scanRootPath.value, openedFolder.value.root.name];\n  const str = scanPath.join(separator.value);\n  if (str.startsWith(\"//\")) { // for unix\n    return str.slice(1);\n  }\n  return str;\n});\nconst part1 = computed(() => {\n  return [...root.value].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...root.value].slice(-1).join(\"\");\n});\nconst showSep = computed(() => {\n  return (openedFolders.value.length - 1) && root.value !== \"/\";\n});\n\nfunction goToRoot() {\n  openFolder(openedFolder.value.root);\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.scanPath {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <span class=\"opened-folder\">\n    <span class=\"parts\" @click=\"onClick\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"separator spaced\" v-if=\"!isLast\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\nimport {computed, toRefs} from \"vue\";\nimport {openFolder, separator} from \"../core/folders.js\";\n\nconst props = defineProps([\"index\", \"count\", \"entry\"]);\nconst {index, count, entry} = toRefs(props);\n\nconst isLast = computed(() => {\n  return index.value + 1 === count.value;\n});\nconst part1 = computed(() => {\n  return [...entry.value.name].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...entry.value.name].slice(-1).join(\"\");\n});\n\nfunction onClick() {\n  openFolder(entry.value);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.opened-folder {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n\n    width: 100%;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part { // to use with max-width limitation // not works with  `display: contents;`\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: pre;\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <div class=\"file-select\">\n    <label>\n      Select file\n      <input type=\"file\" accept=\"application/json\" @change=\"onChange\">\n    </label>\n    <hr>\n  </div>\n</template>\n\n<script setup>\nimport {setJson} from \"../core/folders.js\";\n\nasync function onChange(event) {\n  const jsonObj = JSON.parse(await event.target.files[0].text());\n  setJson(jsonObj);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.file-select label {\n  cursor: pointer;\n  &:hover {\n    text-decoration: underline;\n  }\n}\ninput {\n  display: none;\n}\n</style>\n","<template>\n  <tr class=\"row\"\n      @click=\"onClick\"\n      @mousedown=\"onMousedown\"\n      :title=\"title\"\n      :class=\"{error}\"\n  >\n      <td class=\"icon\">{{icon}}</td>\n      <td class=\"name\">{{entry.name}}</td>\n<!--      <td class=\"type\">{{entry.type}}</td>-->\n  </tr>\n</template>\n\n<script setup>\nimport {toRefs, computed} from \"vue\";\nimport {openFolder} from \"../core/folders.js\";\nimport {isImage, isVideo} from \"../util.js\";\n\nconst props = defineProps([\"entry\"]);\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst entry = toRefs(props).entry;\n\n/** @type {import(\"vue\").Ref<Boolean>} */\nconst error = computed(() => {\n  return entry.value.hasErrors;\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst title = computed(() => {\n  if (entry.value.hasErrors) {\n    return JSON.stringify(entry.value.errors[0], null, \" \");\n  }\n  if (entry.value.type === \"symlink\") {\n    return entry.value.meta?.pathTo;\n  }\n});\n\n/** @type {import(\"vue\").Ref<String>} */\nconst icon = computed(() => {\n  if (entry.value.type === \"folder\") {\n    return \"📁\";\n  } else if (entry.value.type === \"file\") {\n    if (isVideo(entry.value.name)) {\n      return \"🎦\";\n    } else if (isImage(entry.value.name)) {\n      return \"🖼\";\n    }\n    return \"📄\";\n  } else if (entry.value.type === \"symlink\") {\n    return \"🔗\";\n  }\n  return \"👾\";\n});\n\nfunction onClick(event) {\n  if (entry.value.type === \"folder\") {\n    console.log(\"openFolder\", entry.value);\n    openFolder(entry.value);\n  } else {\n    console.log(entry.value);\n  }\n}\n\nfunction onMousedown(event) {\n  const MIDDLE_BUTTON = 2;\n  if (event.which === MIDDLE_BUTTON && entry.value.type === \"folder\") {\n    console.log(\"MIDDLE_BUTTON on a folder\");\n  }\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.row {\n  width: 100%;\n  &:hover {\n    background-color: var(--blue-2);\n  }\n  * {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n  }\n  td {\n    max-width: 0; // no scroll for long names\n    &.icon {\n      border-left: 2px solid transparent;\n      width: 2.5%;\n      min-width: 22px;\n      user-select: none;\n    }\n    &.name {\n      width: 100%;\n      white-space: pre; // to display tailing spaces\n    }\n    &.type {\n      min-width: 58px;\n      user-select: none;\n    }\n  }\n  &.error {\n    .icon {\n      border-left: 2px solid red;\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"content\"\n       @contextmenu=\"onContextMenu\"\n  >\n    <table class=\"rows\" v-if=\"listLimited.length\">\n      <Row v-for=\"entry of listLimited\" :entry=\"entry\"/>\n    </table>\n    <div class=\"empty-message\" v-if=\"empty && !error\">\n      <span>The folder is empty.</span>\n    </div>\n    <div class=\"error-message\" v-if=\"error\">\n      <div>\n        <h2>Error</h2>\n        <table>\n          <tr>\n            <td>syscall</td>\n            <td><pre>{{error.syscall}}</pre></td>\n          </tr>\n          <tr>\n            <td>code</td>\n            <td><pre>{{error.code}}</pre></td>\n          </tr>\n          <tr>\n            <td>errno</td>\n            <td><pre>{{error.errno}}</pre></td>\n          </tr>\n        </table>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport Row from \"./Row.vue\";\nimport {goBack, empty, openedFolder} from \"../core/folders.js\";\nimport {listLimited} from \"../core/entries.js\";\nimport {computed} from \"vue\";\n\n/** @type {ComputedRef<ScanError>} */\nconst error = computed(() => {\n  if (openedFolder.value.hasErrors) {\n    return openedFolder.value.errors[0];\n  }\n  return false;\n});\n\nfunction onContextMenu(event) {\n  event.preventDefault();\n  goBack();\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.content {\n  width: 100%;\n  overflow: auto;\n  .rows {\n    width: 100%;\n    overflow: auto;\n  }\n  .empty-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--gray-2);\n  }\n  .error-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    color: var(--red-1);\n    div {\n      h2 {\n        margin: 0;\n        padding-bottom: 6px;\n        padding-left: 2px;\n      }\n      pre {\n        display: inline;\n      }\n      td {\n        padding-right: 3px;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"main\">\n    <div        style=\"grid-area: switch;\"></div>\n    <AddressBar style=\"grid-area: address;\"/>\n    <Search     style=\"grid-area: search;\"/>\n    <Tabs       style=\"grid-area: tabs;\"/>\n    <Content    style=\"grid-area: content;\"/>\n    <Status     style=\"grid-area: status;\"/>\n    <Debug      style=\"grid-area: debug;\"/>\n  </div>\n</template>\n\n<script setup>\nimport AddressBar from \"./AddressBar.vue\";\nimport Search from \"./Search.vue\";\nimport Tabs from \"./Tabs.vue\";\nimport Content from \"./Content.vue\";\nimport Status from \"./Status.vue\";\nimport Debug from \"./Debug.vue\";\nimport {onMounted} from \"vue\";\nimport {setJson} from \"../core/folders.js\";\n\n\n// Already opened directory, no need to open with input\nonMounted(async () => {\n  const filepath = new URL(location.href).searchParams.get(\"filepath\");\n  if (filepath) {\n    const response = await fetch(filepath);\n    const data = await response.json();\n    setJson(data);\n  }\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.main {\n  grid-template-areas: \"switch address search \"\n                       \"tabs   content content\"\n                       \"status status  status \"\n                       \"debug  debug   debug  \";\n\n  display: grid;\n  grid-template-columns: 7em 2fr 1fr;\n  grid-template-rows:    2em 1fr;\n\n  height: 720px;\n  max-height: 100vh;\n  width: 1280px;\n  max-width: 100%;\n  box-sizing: border-box;\n\n  grid-gap: 1px;\n  border: 1px solid var(--gray-2);\n  background-color: var(--gray-2);\n  * {\n    background-color: white;\n  }\n}\n</style>\n","import {createApp} from \"vue\";\nimport App from \"./App.vue\";\n\ncreateApp(App).mount(\"#app\");\n"],"names":["p","relList","document","createElement","supports","link","querySelectorAll","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","script","fetchOpts","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","ep","getFetchOpts","href","setImmediate","globalThis","port1","port2","MessageChannel","queue","onmessage","callback","shift","postMessage","push","ms","Promise","resolve","setTimeout","videoExtensions","filename","ext","match","groups","includes","imageExtensions","runnable","timerId","apply","this","arguments","dateValue","utc","_date","Date","str","toString","padStart","_utc","year","month","date","Number","warn","pad","sort","ref","compare","Intl","Collator","numeric","sensitivity","pre","cur","value","name","folders","computed","openedFolder","files","symlinks","fifos","charDevs","blockDevs","sockets","entries","comparator","limit","list","search","length","searchResult","listLimited","slice","count","debugMessage","message","entryTypes","constructor","parent","meta","errors","meta2","addChild","entry","children","filter","e","Boolean","root","path","rootFolder","SimpleEntry","forEach","parseEntries","folder","simpleTypes","file","symlink","pathTo","folderDummy","result","markRaw","log","defineProperty","get","performSearchDebounced","debounce","performSearch","async","request","folderRaw","isReactive","toRaw","time1","performance","now","searcher","searchTime","toFixed","sleep","time2","sortedResult","sortTime","search2","startsWith","word","findAll","watch","newValue","oldValue","isEmptyString","predicate","res","time","entries2","listAllEntries","curTime","partSize","list2","folderEntry","takePart","json","object","timeEnd","separator","scanRootPath","openedFolders","unref","empty","isEmpty","total","scanDate","files2","folders2","symlinks2","dateToDayDateString","title","platform","o","count2","Math","trunc","repeat","Object","map","k","v","join","commonFiles","doString","unusualFiles","additional","scanPath","part1","part2","showSep","index","toRefs","props","isLast","event","jsonObj","JSON","parse","target","text","error","hasErrors","stringify","icon","isVideo","isImage","MIDDLE_BUTTON","which","preventDefault","filepath","URL","location","searchParams","response","fetch","data","createApp","App","mount"],"mappings":"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"}