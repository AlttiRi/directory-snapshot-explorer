{"version":3,"file":"index.js","sources":["node-modules:///vite/modulepreload-polyfill","source-maps:///util.js","source-maps:///core/entries.js","source-maps:///core/debug.js","source-maps:///core/entry.js","source-maps:///core/search.js","source-maps:///core/scan-parser.js","source-maps:///core/folders.js","source-maps:///components/AddressBar_Base.vue","source-maps:///components/AddressBar_Folder.vue","source-maps:///components/FileSelect.vue","source-maps:///components/Row.vue","source-maps:///components/Content.vue","source-maps:///components/Main.vue","source-maps:///main.js"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","export const setImmediate = globalThis.setImmediate || /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\nexport function sleep(ms) {\n    if (ms === undefined) {\n        return new Promise(resolve => setImmediate(resolve));\n    }\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const shuffle = () => Math.random() >= 0.5 ? -1 : 1;\n\nconst videoExtensions = [\"mp4\", \"webm\", \"mkv\", \"avi\"];\nexport function isVideo(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return videoExtensions.includes(ext);\n}\nconst imageExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\", \"tiff\", \"webp\"];\nexport function isImage(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return imageExtensions.includes(ext);\n}\n\nexport function debounce(runnable, ms = 50) {\n    let timerId;\n    return function() {\n        // console.log({timerId});\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            runnable.apply(this, arguments);\n            timerId = null;\n        }, ms);\n    }\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\nexport function dateToDayDateString(dateValue, utc = true) {\n    const _date = new Date(dateValue);\n    function pad(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n    const _utc = utc ? \"UTC\" : \"\";\n    const year  = _date[`get${_utc}FullYear`]();\n    const month = _date[`get${_utc}Month`]() + 1;\n    const date  = _date[`get${_utc}Date`]();\n\n    // if server error (or missed)\n    if (Number(_date) === 0) {\n        console.warn(\"date is 1970.01.01\");\n        return \"\";\n    }\n\n    return year + \".\" + pad(month) + \".\" + pad(date);\n}\n\nexport function structuredClone(object) {\n    return new Promise(resolve => {\n        const {port1, port2} = new MessageChannel();\n        port1.onmessage = function(message) {\n            resolve(message.data);\n        };\n        port2.postMessage(object);\n    });\n}\n\nexport function appendScript(src, integrity) {\n    return new Promise(resolve => {\n        const script = document.createElement(\"script\");\n        script.onload = resolve;\n        script.src = src;\n        script.setAttribute(\"async\", \"\");\n        if (integrity) {\n            script.integrity = integrity;\n            script.setAttribute(\"crossorigin\", \"anonymous\");\n        }\n        document.querySelector(\"body\").append(script);\n    });\n}\n\n/**\n * @param {ReadableStream} stream\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateReadableStream(stream) {\n    const reader = stream.getReader();\n    while (true) {\n        const {done, /** @type {Uint8Array} */ value} = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\n\n/**\n * `chunkSize` is 65536, ReadableStream uses the same size.\n * There is no speed difference between using of different the chunk's sizes.\n * @param {ArrayBuffer|Uint8Array} arrayBuffer\n * @param {Number} [chunkSize=65536]\n * @return {Generator<Uint8Array>}\n */\nexport function *iterateArrayBuffer(arrayBuffer, chunkSize = 65536) {\n    const buffer = new Uint8Array(arrayBuffer);\n    let index = 0;\n    while (true) {\n        const chunk = buffer.subarray(index, index + chunkSize);\n        if (!chunk.length) {\n            break;\n        }\n        yield chunk;\n        index += chunkSize;\n    }\n}\n\n/**\n * Iterates Blob (or File).\n * Note: `chunkSize` affects the execution speed\n * @param {Blob} blob\n * @param {Number} [chunkSize=2097152]\n * @return {Generator<Promise<Uint8Array>>|AsyncGenerator<Uint8Array>}\n */\nexport function *iterateBlob(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        return new Uint8Array(await blob.arrayBuffer());\n    }\n}\n\n/**\n * Format bytes to human readable format.\n * Trims the tailing zeros.\n *\n * {@link https://stackoverflow.com/a/18650828/11468937}\n * @param {Number} bytes\n * @param {Number} [decimals=2]\n * @returns {String}\n */\nexport function bytesToSize(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return \"0 B\";\n    }\n    const k = 1024;\n    decimals = decimals < 0 ? 0 : decimals;\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n}\n\n/**\n * @param {Uint8Array[]} arrays\n * @return {Uint8Array}\n */\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n","import {computed, ref} from \"vue\";\nimport {search, searchResult} from \"./search.js\";\nimport {openedFolder} from \"./folders.js\";\n\n\nexport const sort = ref(true);\n\nconst {compare} = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: \"accent\",\n});\nexport function comparator(pre, cur) {\n    if (sort.value) {\n        return compare(pre.name, cur.name);\n    }\n    return 0;\n}\n\n// grouped by type\nexport const entries = computed(() => [\n    ...openedFolder.value.folders.sort(comparator),\n    ...openedFolder.value.files.sort(comparator),\n    ...openedFolder.value.symlinks.sort(comparator),\n    ...openedFolder.value.fifos.sort(comparator),\n    ...openedFolder.value.charDevs.sort(comparator),\n    ...openedFolder.value.blockDevs.sort(comparator),\n    ...openedFolder.value.sockets.sort(comparator),\n]);\n\n\n/** @type {number} */\nconst limit = 1000;\n\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const list = computed(() => {\n    if (search.value.length) {\n        return searchResult.value;\n    }\n    return entries.value;\n});\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const listLimited = computed(() => {\n    return list.value.slice(0, limit);\n});\n/** @type {import(\"vue\").ComputedRef<Number>} */\nexport const count = computed(() => {\n    if (searchResult.value.length > limit) {\n        return searchResult.value.length;\n    }\n    return list.value.length;\n});\n","import {ref} from \"vue\";\n\nexport const debugMessage = ref(\"\");\nexport function addMessage(message) {\n    debugMessage.value = message;\n}\nexport function appendMessage(message) {\n    debugMessage.value += message;\n}\n","/** @type {ScanEntryType[]} */\nimport {sleep} from \"../util.js\";\n\nexport const entryTypes = [\"folder\", \"file\", \"symlink\", \"fifo\", \"charDev\", \"blockDev\", \"socket\"];\n\nexport class SimpleEntry {\n    // [Symbol.toStringTag] = \"SimpleEntry\"; // Disables reactivity, BTW.\n    /**\n     * @param {SerializableScanEntry} entry\n     * @param {SimpleEntry|null} parent\n     */\n    constructor(entry, parent) {\n        /** @type {String} */\n        this.name = entry.name;\n        /** @type {SimpleEntry|null} */\n        this.parent = parent;\n        /** @type {ScanEntryType} */\n        this.type = entry.type;\n\n        if (entry.size) {\n            /** @type {Number|undefined} */\n            this._size = entry.size;\n        }\n        if (entry.mtime) {\n            /** @type {Number|undefined} */\n            this.mtime = entry.mtime;\n        }\n        if (entry.btime) {\n            /** @type {Number|undefined} */\n            this.btime = entry.btime;\n        }\n\n        if (entry.errors) {\n            /** @type {ScanError[]|undefined} */\n            this.errors = entry.errors;\n        }\n\n        if (entry.pathTo) {\n            /** @type {String|undefined} */\n            this.pathTo = entry.pathTo;\n        }\n        if (entry.content) {\n            /** @type {String|undefined} */\n            this.content = entry.content;\n        }\n    }\n    /** @param {SimpleEntry} entry */\n    addChild(entry) {\n        if (!this.children) {\n            /** @type {SimpleEntry[]|undefined} */\n            this.children = [];\n        }\n        this.children.push(entry);\n    }\n    /** @param {SimpleEntry[]} entries\n     *  @param {Number} total */\n    addHardlinks(entries, total) {\n        /** @type {SimpleEntry[]|undefined} */\n        this.hardlinks = entries;\n        /** @type {Number|undefined} */\n        this.hardlinksTotal = total;\n    }\n\n    get size() {\n        if (this.type === \"folder\") {\n            return -0; // todo\n        }\n        return this._size || 0;\n    }\n\n    /** @return {SimpleEntry[]} */\n    get folders() {\n        return this.children?.filter(e => e.type === \"folder\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get files() {\n        return this.children?.filter(e => e.type === \"file\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get symlinks() {\n        return this.children?.filter(e => e.type === \"symlink\") || [];\n    }\n\n    /** @return {SimpleEntry[]} */\n    get fifos() {\n        return this.children?.filter(e => e.type === \"fifo\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get charDevs() {\n        return this.children?.filter(e => e.type === \"charDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get blockDevs() {\n        return this.children?.filter(e => e.type === \"blockDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get sockets() {\n        return this.children?.filter(e => e.type === \"socket\") || [];\n    }\n\n    /** @return {Boolean} */\n    get isEmpty() {\n        return !Boolean(this.children?.length);\n    }\n    /** @return {Boolean} */\n    get hasErrors() {\n        return Boolean(this.errors?.length);\n    }\n    /** @return {SimpleEntry} */\n    get root() {\n        if (!this.parent) {\n            return this;\n        }\n        return this.parent.root;\n    }\n    /** @return {SimpleEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n}\n\n/**\n * @param {SerializableScanEntry[]} sEntries\n * @return {SimpleEntry}\n * */\nexport async function parseFlatScan(sEntries) {\n    /** @type {Map<Number, SimpleEntry>} */\n    const map = new Map();\n    /** @type {Map<String, SimpleEntry[]>} */\n    const hidMap = new Map();\n\n    let i = 0;\n    let time = Date.now();\n\n    const rootId = 0;\n    for (const entry of sEntries) {\n        if (!(i++ % 1000)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n            }\n        }\n\n        /** @type {SimpleEntry|null}*/\n        const parent = map.get(entry.pid) ?? null;\n        const simpleEntry = new SimpleEntry(entry, parent);\n        if (entry.type === \"folder\") {\n            map.set(entry.id, simpleEntry);\n        }\n        parent?.addChild(simpleEntry);\n        if (entry.hid) {\n            const array = hidMap.get(entry.hid) || [];\n            hidMap.set(entry.hid, [...array, simpleEntry]);\n        }\n    }\n\n    console.log(\"[hidMap]:\", hidMap);\n    console.time(\"hidMap\");\n    processHIDMapAsync(hidMap).then(() => console.timeEnd(\"hidMap\"));\n\n    return map.get(rootId);\n}\n\nasync function processHIDMapAsync(hidMap) {\n    let i = 0;\n    let time = 0; // `0` to do `sleep` on the first iteration\n\n    for (const [hid, simpleEntries] of hidMap.entries()) {\n        if (!(i++ % 1000)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n            }\n        }\n\n        /** @type {Number}*/\n        const totalLinks = Number(hid.split(\":\")[1]);\n        simpleEntries.forEach(e => {\n            e.addHardlinks(simpleEntries, totalLinks);\n        });\n    }\n}\n\n/** @type {SimpleEntry} */\nexport const folderDummy = new SimpleEntry({\n    type: \"folder\",\n    name: \"\",\n    pid: null,\n}, null);\n","import {isReactive, markRaw, ref, toRaw, watch} from \"vue\";\nimport {debounce, sleep} from \"../util.js\";\nimport {openedFolder} from \"./folders.js\";\nimport {comparator} from \"./entries.js\";\nimport * as debug from \"./debug.js\";\nimport {entryTypes} from \"./entry.js\";\n\n/** @type {import(\"vue\").Ref<string>} */\nexport const search = ref(\"\"); // [v-model]\nexport function clearSearch() {\n    search.value = \"\";\n}\n\n/** @type {import(\"vue\").Ref<SimpleEntry[]>} */\nexport const searchResult = ref([]);\nfunction clearSearchResult() {\n    setSearchResult([]);\n}\n/** * @param {SimpleEntry[]} result */\nfunction setSearchResult(result) {\n    searchResult.value = markRaw(result);\n\n    console.log(\"globalThis.search:\", globalThis.search = result);\n    Object.defineProperty(globalThis.search, \"download\", {\n        get() {\n            console.log(\"download\"); // todo\n        }\n    });\n}\n\n//todo search by type\n// /type:folder/\n//todo check linked list perf for large search\nconst performSearchDebounced = debounce(performSearch, 300);\nasync function performSearch() {\n    const folder = openedFolder.value;\n    const request = search.value;\n\n    // Do unProxy. Up to x40 in comparison with default reactive ref.\n    const folderRaw = isReactive(folder) ? toRaw(folder) : folder;\n\n    const time1 = performance.now();\n    const result = await searcher(folderRaw, request);\n    if (!result) {\n        return;\n    }\n    const searchTime = performance.now() - time1;\n    debug.addMessage(`Search time: ${searchTime.toFixed(2)} ms; `);\n    await sleep();\n\n    const time2 = performance.now();\n    const sortedResult = result.sort(comparator);\n    const sortTime = performance.now() - time2;\n    debug.appendMessage(`Sort time: ${sortTime.toFixed(2)} ms; `);\n    await sleep();\n\n    setSearchResult(sortedResult);\n    debug.appendMessage(`${result.length} items; search: ${request}`);\n}\n\n/**\n * @param {SimpleEntry} folder\n * @param {string} search\n * @return {Promise<SimpleEntry[]|false>}\n */\nasync function searcher(folder, search) {\n    if (search.startsWith(\"/\")) {\n        const {type, word} = search.match(/\\/type:(?<type>[^\\/]+)\\/?(?<word>[^\\/]*)/)?.groups || {};\n        if (type) {\n            console.log({type, word});\n            if (entryTypes.includes(type)) {\n                return findAll(folder, (entry) => {\n                    return entry.type === type && entry.name.includes(word);\n                });\n            }\n        }\n    } else {\n        return findAll(folder, (entry) => {\n            return entry.name.includes(search);\n        });\n    }\n    return false;\n}\n\nwatch(search, async (newValue, oldValue) => {\n    const isEmptyString = !newValue;\n    if (isEmptyString) {\n        clearSearchResult();\n        return;\n    }\n    // In order to \"no debounce by paste event\"\n    if (newValue.length - oldValue.length > 1) {\n        await performSearch();\n    } else {\n        await performSearchDebounced();\n    }\n});\n\n/**\n * @param {SimpleEntry} folder\n * @param {function(SimpleEntry)} predicate\n * @return {Promise<SimpleEntry[]>}\n */\nasync function findAll(folder, predicate) {\n    let res = [];\n    let time = Date.now();\n    for (const entries of listAllEntries(folder)) {\n        const curTime = Date.now();\n        if (curTime - time > 15) {\n            time = curTime;\n            await sleep();\n        }\n        for (const entry of entries) {\n            if (predicate(entry)) {\n                res.push(entry);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * List all entries by parts.\n * @param {SimpleEntry} folder\n * @return {Generator<SimpleEntry[]>}\n */\nfunction *listAllEntries(folder) {\n    const partSize = 1000;\n    /** @type {SimpleEntry[]} */\n    let list = [];\n    /** @param {SimpleEntry} folderEntry */\n    function *takePart(folderEntry) {\n        for (const entry of (folderEntry.children || [])) {\n            if (entry.type === \"folder\") {\n                yield *takePart(entry);\n            }\n            list.push(entry);\n            if (list.length === partSize) {\n                yield list;\n                list = [];\n            }\n        }\n    }\n    yield *takePart(folder);\n    yield list;\n}\n","import {parseFlatScan} from \"./entry.js\";\nimport {appendScript, iterateArrayBuffer, sleep} from \"../util.js\";\n\nlet pakoIsLoaded = false;\nasync function loadPako() {\n    if (!pakoIsLoaded) {\n        const src = \"https://cdn.jsdelivr.net/npm/pako@2.0.4/dist/pako_inflate.min.js\";\n        const integrity = \"sha256-ZIKs3+RZEULSy0dR6c/mke8V9unZm9vuh05TqvtMdGU=\";\n        await appendScript(src, integrity);\n        pakoIsLoaded = true;\n        console.log(\"pako is loaded\");\n    }\n}\n\n/**\n * @param {ArrayBuffer} arrayBuffer\n * @return {Generator<Uint8Array>}\n */\nfunction *unZipIterator(arrayBuffer) {\n    const inflator = new pako.Inflate();\n    for (const u8Array of iterateArrayBuffer(arrayBuffer, 65536/2)) {\n        inflator.push(u8Array);\n        for (const chunk of inflator.chunks) {\n            yield chunk;\n        }\n        inflator.chunks = [];\n    }\n    yield inflator.result;\n    if (inflator.err) {\n        console.error(inflator.msg);\n    }\n}\n\n/**\n * @param {Response|Blob} input\n * @return {Promise<*>}\n */\nasync function unGZipJSON(input) {\n    await loadPako();\n    const ab = await input.arrayBuffer();\n\n    const decoder = new TextDecoder();\n    let partObjects = [];\n\n    const parser = new Parser();\n    let i = 0, time = 0;\n    for (const uint8Array of unZipIterator(ab)) {\n        if (!(i++ % 20)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        partObjects.push(parser.parse(textPart));\n    }\n    return partObjects.flat();\n}\n\nexport class Parser {\n    buffer = null;\n    startHandled = false;\n    metaLines = [];\n    objects = [];\n\n    handleStart(line) {\n        if (line === \"[\") { // the first line\n            return;\n        }\n        if (line === \"\") { // meta is separated from the main content by \"\\n\"\n            this.objects.push(this.metaLines.join(\"\"));\n            this.startHandled = true;\n            return;\n        }\n        this.metaLines.push(line);\n    }\n\n    trimComma(text) {\n        return text.endsWith(\",\") ? text.slice(0, -1) : text;\n    }\n\n    handleEntry(line, isLastLine) {\n        if (isLastLine) {\n            this.buffer = line;\n            return;\n        }\n        if (this.buffer) {\n            this.objects.push(this.buffer + line);\n            this.buffer = null;\n        } else {\n            this.objects.push(line);\n        }\n    }\n\n    parse(textPart) {\n        const isLastPart = textPart.endsWith(\"\\n]\");\n        /** @type {String[]} */\n        const lines = textPart.split(\"\\n\");\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const isLastLine = i === lines.length - 1;\n\n            if (isLastLine && isLastPart) {\n                continue;\n            }\n\n            if (!this.startHandled) {\n                this.handleStart(line, isLastLine);\n            } else {\n                this.handleEntry(line, isLastLine);\n            }\n        }\n        const result = JSON.parse(`[${this.trimComma(this.objects.join(\"\"))}]`);\n        this.objects = [];\n        return result;\n    }\n\n}\n\n/**\n * @param {Blob|Response} input\n * @return {Promise<{meta: ScanMeta, root: SimpleEntry}>}\n */\nexport async function parseScan(input) {\n    /**\n     * @see FlatScanResult\n     * @type {Object[]} flatScan */\n    let flatScan;\n\n    console.time(\"parse-json\");\n    if (input instanceof Response) {\n        /** @type {Response} */\n        const response = input;\n\n        // If \"content-type\" is \"application/json\" or \"application/json; charset=utf-8\"\n        // and \"content-encoding\" is \"gzip\"\n        // the browser will unGZip it itself.\n        /* const contentEncoding = response.headers.get(\"content-encoding\"); */\n        const contentType = response.headers.get(\"content-type\");\n        if (isGZip(contentType)/* && contentEncoding === null */) {\n            flatScan = await unGZipJSON(response);\n        } else if (isJSON(contentType)) {\n            flatScan = await response.json();\n        }\n    } else if (input instanceof Blob) {\n        /** @type {Blob} */\n        const blob = input;\n\n        if (isGZip(blob.type)) {\n            flatScan = await unGZipJSON(blob);\n        } else if (isJSON(blob.type)) {\n            flatScan = JSON.parse(await blob.text());\n        }\n    }\n    console.timeEnd(\"parse-json\");\n\n    /** @type {ScanMeta} */\n    const meta = flatScan[0];\n    /** @type {SerializableScanEntry[]} */\n    const sEntries = flatScan.slice(1);\n\n\n    console.time(\"parseEntries\");\n    /** @type {SimpleEntry} */\n    const root = await parseFlatScan(sEntries);\n    console.timeEnd(\"parseEntries\");\n\n    return {meta, root};\n}\n\n/**\n * \"application/x-gzip\"\n * \"application/gzip\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isGZip(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?gzip/));\n}\n/**\n * \"application/json\"\n * \"application/json; charset=utf-8\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isJSON(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?json/));\n}\n","import {computed, markRaw, ref, unref, watch} from \"vue\";\nimport {clearSearch} from \"./search.js\";\nimport {folderDummy, parseFlatScan} from \"./entry.js\";\nimport {dateToDayDateString} from \"../util.js\";\nimport {addMessage} from \"./debug.js\";\nimport {parseScan} from \"./scan-parser.js\";\n\n\n/** @type {import(\"vue\").Ref<ScanMeta>} */\nexport const meta = ref(null);\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst root = ref(null);\n\n/**\n * @param {Blob|Response} input\n * @return {Promise<void>}\n */\nexport async function setScan(input) {\n    const {\n        meta: scanMeta,\n        root: rootEntry\n    } = await parseScan(input);\n\n    meta.value = markRaw(scanMeta);\n    root.value = markRaw(rootEntry);\n    globalThis.json = rootEntry;\n\n    openFolder(rootEntry);\n    clearSearch();\n}\n\n/** @type {import(\"vue\").ComputedRef<string>} */\nexport const separator = computed(() => {\n    return meta.value?.separator || \"/\";\n});\n/** @type {import(\"vue\").ComputedRef<string[]>} */\nexport const scanRootPath = computed(() => {\n    return meta.value?.path || [];\n});\n\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nexport const openedFolder = ref(folderDummy);\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const openedFolders = computed(() => {\n    return openedFolder.value.path;\n});\n\n/** @param {SimpleEntry} entry */\nexport function openFolder(entry) {\n    clearSearch();\n    openedFolder.value = markRaw(unref(entry));\n}\nexport function goBack() {\n    if (openedFolder.value.parent) {\n        openFolder(openedFolder.value.parent);\n    }\n}\n/** @type {import(\"vue\").ComputedRef<Boolean>} */\nexport const empty = computed(() => root.value && openedFolder.value.isEmpty);\n\n\nwatch(meta, async (newValue, oldValue) => {\n    console.log(\"[meta]:\", meta.value);\n    const {files, folders, symlinks, errors, total, scanDate} = meta.value;\n    if (meta.value.scanDate) {\n        addMessage(\n            `files: \"${files}\" folders: \"${folders}\", symlinks: \"${symlinks}\", ` +\n            `errors: \"${errors}\", total: \"${total}\", scanDate: \"${dateToDayDateString(scanDate)}\"`\n        );\n    }\n});\n","<template>\n  <span class=\"scanPath\">\n    <span class=\"parts\" @click=\"goToRoot\" :title=\"title\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"spaced separator\" v-if=\"showSep\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\n//todo title\nimport {computed} from \"vue\";\nimport {scanRootPath, openedFolders, separator, openedFolder, openFolder, meta} from \"../core/folders.js\";\nimport {dateToDayDateString} from \"../util.js\";\n\nconst title = computed(() => {\n  if (!meta.value) {\n    return;\n  }\n\n  const {\n      files, folders, symlinks,\n      charDevs, blockDevs, fifos, sockets,\n      total,\n      platform, scanDate\n  } = meta.value;\n\n  function doString(o) {\n    function pad(str) {\n      const count = 3 - Math.trunc((str.length/4));\n      return str + \"\\t\".repeat(count);\n    }\n    return Object.entries(o)\n        .map(([k, v]) => pad(k) + \": \" + v)\n        .join(\"\\n\");\n  }\n  const commonFiles = doString({files, folders, symlinks});\n  const unusualFiles = doString({charDevs, blockDevs, fifos, sockets});\n  const additional = doString({total, platform, scanDate: dateToDayDateString(scanDate)});\n\n  let result;\n  if (platform !== \"win32\") {\n    result = [commonFiles, unusualFiles, additional].join(\"\\n\");\n  } else {\n    result = [commonFiles, additional].join(\"\\n\");\n  }\n  console.log(result);\n  return result;\n});\n\nconst root = computed(() => {\n  const scanPath = [...scanRootPath.value, openedFolder.value.root.name];\n  const str = scanPath.join(separator.value);\n  if (str.startsWith(\"//\")) { // for unix\n    return str.slice(1);\n  }\n  return str;\n});\nconst part1 = computed(() => {\n  return [...root.value].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...root.value].slice(-1).join(\"\");\n});\nconst showSep = computed(() => {\n  return (openedFolders.value.length - 1) && root.value !== \"/\";\n});\n\nfunction goToRoot() {\n  openFolder(openedFolder.value.root);\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.scanPath {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <span class=\"opened-folder\">\n    <span class=\"parts\" @click=\"onClick\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"separator spaced\" v-if=\"!isLast\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\nimport {computed, toRefs} from \"vue\";\nimport {openFolder, separator} from \"../core/folders.js\";\n\nconst props = defineProps([\"index\", \"count\", \"entry\"]);\nconst {index, count, entry} = toRefs(props);\n\nconst isLast = computed(() => {\n  return index.value + 1 === count.value;\n});\nconst part1 = computed(() => {\n  return [...entry.value.name].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...entry.value.name].slice(-1).join(\"\");\n});\n\nfunction onClick() {\n  openFolder(entry.value);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.opened-folder {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n\n    width: 100%;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part { // to use with max-width limitation // not works with  `display: contents;`\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: pre;\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <div class=\"file-select\">\n    <label>\n      Select file\n      <input type=\"file\" accept=\"application/json,application/gzip\" @change=\"onChange\">\n    </label>\n    <hr>\n  </div>\n</template>\n\n<script setup>\nimport {setScan} from \"../core/folders.js\";\n\nfunction onChange(event) {\n  /** @type {File} */\n  const file = event.target.files[0];\n  return setScan(file);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.file-select label {\n  cursor: pointer;\n  &:hover {\n    text-decoration: underline;\n  }\n}\ninput {\n  display: none;\n}\n</style>\n","<template>\n  <tr class=\"row\"\n      @click=\"onClick\"\n      @mousedown=\"onMousedown\"\n      :title=\"title\"\n      :class=\"{error}\"\n  >\n      <td class=\"icon\">{{icon}}</td>\n      <td class=\"name\">{{entry.name}}</td>\n<!--      <td class=\"type\">{{entry.type}}</td>-->\n  </tr>\n</template>\n\n<script setup>\nimport {toRefs, computed} from \"vue\";\nimport {meta, openFolder, separator} from \"../core/folders.js\";\nimport {isImage, isVideo} from \"../util.js\";\n\nconst props = defineProps([\"entry\"]);\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst entry = toRefs(props).entry;\n\n/** @type {import(\"vue\").Ref<Boolean>} */\nconst error = computed(() => {\n  return entry.value.hasErrors;\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst title = computed(() => {\n  if (entry.value.hasErrors) {\n    return JSON.stringify(entry.value.errors[0], null, \" \");\n  }\n  if (entry.value.type === \"symlink\") {\n    return entry.value.pathTo;\n  }\n});\n\n/** @type {import(\"vue\").Ref<String>} */\nconst icon = computed(() => {\n  if (entry.value.type === \"folder\") {\n    return \"📁\";\n  } else if (entry.value.type === \"file\") {\n    if (isVideo(entry.value.name)) {\n      return \"🎦\";\n    } else if (isImage(entry.value.name)) {\n      return \"🖼\";\n    }\n    return \"📄\";\n  } else if (entry.value.type === \"symlink\") {\n    return \"🔗\";\n  }\n  return \"👾\";\n});\n\nfunction onClick(event) {\n  if (entry.value.type === \"folder\") {\n    console.log(\"openFolder\", entry.value);\n    openFolder(entry.value);\n  } else {\n    console.log(entry.value);\n  }\n}\n\n/** @param {MouseEvent} event */\nfunction onMousedown(event) {\n  const MIDDLE_BUTTON = 1;\n  const RIGHT_BUTTON = 2;\n  if (event.button === MIDDLE_BUTTON) {\n    event.preventDefault();\n    console.log(\n        entry.value,\n        [...meta.value.path,...entry.value.path.map(e => e.name)].join(separator.value).replace(\"//\", \"/\")\n    );\n  }\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.row {\n  width: 100%;\n  &:hover {\n    background-color: var(--blue-2);\n  }\n  * {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n  }\n  td {\n    max-width: 0; // no scroll for long names\n    &.icon {\n      border-left: 2px solid transparent;\n      width: 2.5%;\n      min-width: 22px;\n      user-select: none;\n    }\n    &.name {\n      width: 100%;\n      white-space: pre; // to display tailing spaces\n    }\n    &.type {\n      min-width: 58px;\n      user-select: none;\n    }\n  }\n  &.error {\n    .icon {\n      border-left: 2px solid red;\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"content\"\n       @contextmenu=\"onContextMenu\"\n  >\n    <table class=\"rows\" v-if=\"listLimited.length\">\n      <Row v-for=\"entry of listLimited\" :entry=\"entry\"/>\n    </table>\n    <div class=\"empty-message\" v-if=\"empty && !error\">\n      <span>The folder is empty.</span>\n    </div>\n    <div class=\"error-message\" v-if=\"error\">\n      <div>\n        <h2>Error</h2>\n        <table>\n          <tr>\n            <td>syscall</td>\n            <td><pre>{{error.syscall}}</pre></td>\n          </tr>\n          <tr>\n            <td>code</td>\n            <td><pre>{{error.code}}</pre></td>\n          </tr>\n          <tr>\n            <td>errno</td>\n            <td><pre>{{error.errno}}</pre></td>\n          </tr>\n        </table>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport Row from \"./Row.vue\";\nimport {goBack, empty, openedFolder} from \"../core/folders.js\";\nimport {listLimited} from \"../core/entries.js\";\nimport {computed} from \"vue\";\n\n/** @type {ComputedRef<ScanError>} */\nconst error = computed(() => {\n  if (openedFolder.value.hasErrors) {\n    return openedFolder.value.errors[0];\n  }\n  return false;\n});\n\nfunction onContextMenu(event) {\n  event.preventDefault();\n  goBack();\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.content {\n  width: 100%;\n  overflow: auto;\n  .rows {\n    width: 100%;\n    overflow: auto;\n  }\n  .empty-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--gray-2);\n  }\n  .error-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    color: var(--red-1);\n    div {\n      h2 {\n        margin: 0;\n        padding-bottom: 6px;\n        padding-left: 2px;\n      }\n      pre {\n        display: inline;\n      }\n      td {\n        padding-right: 3px;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"main\">\n    <div        style=\"grid-area: switch;\"></div>\n    <AddressBar style=\"grid-area: address;\"/>\n    <Search     style=\"grid-area: search;\"/>\n    <Tabs       style=\"grid-area: tabs;\"/>\n    <Content    style=\"grid-area: content;\"/>\n    <Status     style=\"grid-area: status;\"/>\n    <Debug      style=\"grid-area: debug;\"/>\n  </div>\n</template>\n\n<script setup>\nimport AddressBar from \"./AddressBar.vue\";\nimport Search from \"./Search.vue\";\nimport Tabs from \"./Tabs.vue\";\nimport Content from \"./Content.vue\";\nimport Status from \"./Status.vue\";\nimport Debug from \"./Debug.vue\";\nimport {onMounted} from \"vue\";\nimport {setScan} from \"../core/folders.js\";\n\n\n// Already opened directory, no need to open with input\nonMounted(async () => {\n  //todo search\n  const filepath = new URL(location.href).searchParams.get(\"filepath\");\n  if (filepath) {\n    /** @type {Response} */\n    const response = await fetch(filepath);\n    return setScan(response);\n  }\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.main {\n  grid-template-areas: \"switch address search \"\n                       \"tabs   content content\"\n                       \"status status  status \"\n                       \"debug  debug   debug  \";\n\n  display: grid;\n  grid-template-columns: 7em 2fr 1fr;\n  grid-template-rows:    2em 1fr;\n\n  height: 720px;\n  max-height: 100vh;\n  width: 1280px;\n  max-width: 100%;\n  box-sizing: border-box;\n\n  grid-gap: 1px;\n  border: 1px solid var(--gray-2);\n  background-color: var(--gray-2);\n  * {\n    background-color: white;\n  }\n}\n</style>\n","import {createApp} from \"vue\";\nimport App from \"./App.vue\";\n\ncreateApp(App).mount(\"#app\");\n"],"names":["relList","document","createElement","supports","link","querySelectorAll","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","ep","fetchOpts","script","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","href","p","setImmediate","globalThis","port1","port2","MessageChannel","queue","onmessage","shift","callback","postMessage","push","ms","Promise","resolve","setTimeout","videoExtensions","imageExtensions","dateValue","utc","_date","Date","str","toString","padStart","_utc","year","month","date","Number","warn","pad","sort","ref","compare","Intl","Collator","numeric","sensitivity","pre","cur","value","name","entries","computed","openedFolder","folders","comparator","files","symlinks","fifos","charDevs","blockDevs","sockets","list","search","length","searchResult","listLimited","slice","count","debugMessage","message","entryTypes","constructor","entry","parent","size","_size","mtime","btime","errors","pathTo","content","addChild","this","children","addHardlinks","entries2","total","hardlinks","hardlinksTotal","filter","e","Boolean","root","path","async","sEntries","map","Map","hidMap","i","time","now","timeNow","sleep","get","pid","simpleEntry","SimpleEntry","set","id","hid","array","log","simpleEntries","totalLinks","split","forEach","then","console","timeEnd","folderDummy","result","markRaw","defineProperty","performSearchDebounced","runnable","timerId","apply","arguments","debounce","performSearch","folder","request","folderRaw","isReactive","toRaw","time1","performance","search2","startsWith","findAll","includes","word","match","groups","searcher","toFixed","time2","sortedResult","predicate","res","partSize","list2","folderEntry","takePart","listAllEntries","curTime","watch","newValue","oldValue","pakoIsLoaded","src","onload","setAttribute","querySelector","append","appendScript","arrayBuffer","inflator","pako","Inflate","u8Array","chunkSize","buffer","Uint8Array","index","chunk","subarray","iterateArrayBuffer","chunks","err","error","msg","input","loadPako","ab","decoder","TextDecoder","partObjects","parser","Parser","uint8Array","unZipIterator","textPart","decode","stream","parse","flat","handleStart","line","objects","metaLines","join","startHandled","trimComma","text","endsWith","handleEntry","isLastLine","isLastPart","lines","JSON","contentType","meta","scanMeta","rootEntry","flatScan","Response","response","headers","isGZip","unGZipJSON","isJSON","json","Blob","blob","meta2","root2","parseFlatScan","parseScan","separator","scanRootPath","openedFolders","unref","empty","isEmpty","scanDate","dateToDayDateString","title","platform","o","Object","k","v","count2","Math","trunc","repeat","commonFiles","doString","unusualFiles","additional","part1","part2","showSep","toRefs","props","isLast","event","setScan","target","hasErrors","stringify","icon","filename","ext","isVideo","isImage","button","preventDefault","replace","filepath","URL","location","searchParams","fetch","createApp","mount"],"mappings":"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"}