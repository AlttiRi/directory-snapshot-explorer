{"version":3,"mappings":"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","names":["relList","document","createElement","supports","link","querySelectorAll","processPreload","mutations","mutation","type","addedNodes","node","tagName","rel","observe","childList","subtree","ep","script","fetchOpts","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","fetch","href","setImmediate","globalThis","port1","port2","MessageChannel","queue","onmessage","shift","callback","postMessage","push","sleep","ms","Promise","resolve","setTimeout","videoExtensions","imageExtensions","audioExtensions","async","iterateAsyncDataSource","dataSource","Response","body","ReadableStream","stream","getReader","done","value","reader","read","iterateReadableStream","Blob","blob","chunkSize","index","blobChunk","slice","size","Uint8Array","arrayBuffer","iterateBlob","part","tripleSizeGroups","num","toString","str","padStart","length","match","join","trimStart","bytesToSize","bytes","decimals","i","Math","floor","log","Number","parseFloat","pow","toFixed","bytesToSizeWinLike","result","number","trunc","toPrecision","toTruncPrecision3","blue","text","dateToDayDateString","dateValue","utc","dateToDayDateTimeString","formatDate","Date","pattern","count","input","String","replace","date","console","formatter","constructor","this","SS","pad0","mm","HH","MM","DD","YYYY","YY","replaceAll","args","sort","ref","selectedTime","orderBy","orders","name","time","reverseOrder","computed","toggleOrder","compare","Intl","Collator","numeric","sensitivity","comparator","pre","cur","k","timeName","entries","openedFolder","folders","files","symlinks","fifos","charDevs","blockDevs","sockets","limit","list","search","searchResult","listLimited","hoveredEntry","Object","defineProperty","get","map","entry","debugMessage","addMessage","message","appendMessage","debugMessageFromEntry","isProxy","toRaw","hasErrors","messages","mtime","btime","filter","m","entryTypes","SimpleEntry","parent","errorsIDMap","_size","_mtime","errors","id","pathTo","content","addChild","children","addHardlinks","total","hardlinks","hardlinksTotal","addMeta","meta","increaseContentSize","_contentSize","MIN_SAFE_INTEGER","child","_a","e","isEmpty","Boolean","root","path","contentTypesStats","getContentTypesStats","_getContentTypesStats","deep","target","timeEnd","Symbol","iterator","flat","static","pathString","getPathString","names","pathStr","separator","startsWith","EntryStreamParser","rootId","Map","setMeta","errorsMap","v","code","syscall","errno","split","parse","sEntriesPart","rootUpdated","pid","simpleEntry","set","hid","array","hidMap","processed","processHIDMapAsync","simpleEntries","now","timeNow","totalLinks","forEach","then","folderDummy","WebFileEntryType","WebFileEntry","file","_name","nativePath","lastModified","dt","recursive","dtItems","items","fileSystemEntries","dtItemToFileSystemEntry","dtItemsToFileSystemEntries","fileSystemEntry","fromFileSystemEntry","fsEntry","isFile","isDirectory","fsDirEntry","createReader","reject","readEntries","readFileSystemDirectoryEntry","dirEntry","fsFileEntry","error","webkitGetAsEntry","isNW","nw","allScansReady","scansCount","currentScansNum","scanParsingProgress","searching","searchAwaiting","fileInputState","fileEntries","inputElem","parsing","dataTransfer","dropHover","dropHoverItemCount","dropHoverTypes","isNwDirectory","watchEffect","fromDataTransfer","fromFiles","filelist","resetDataTransfer","_files","readonly","clearInput","private","setDataTransferHover","allTypes","item","types","Set","resetDataTransferHover","setDataTransfer","setFiles","_dtItems","kind","_setDtItems","getStateInstance","handleMegaUrl","url","__vitePreload","import","Mega","parseMegaNode","_url","special","_id","ownerId","_ownerId","emptyRootFolder","openFolder","megaNode","creationDate","modificationDate","parentId","sEntry","ssEntry","toSEntry","mNode","clearSearch","shallowRef","setSearchResult","rawResult","addSearchResultToGlobalThis","sortSearch","timeTotal","triggerRef","watch","scanParsingCompleted","simplify","toLowerCase","r","window","addEventListener","event","key","querySelector","newValue","dispatchEvent","Event","performSearchDebounced","runnable","timerId","clearTimeout","arguments","debounce","performSearch","URL","location","searchParams","searchSync","localStorage","title","folder","request","folderRaw","isReactive","time1","performance","searchText","strict","normalized","searchHelp","subStringMatcher","subSearch","starts","ends","endsWith","stringMatcher","string","substring","justSearch","some","prefix","hostname","pathname","resourceFullName","pathnameEndsWithSlash","resName","ext","resExt","r1","RegExp","regex","defaultPrefix","caret","dollar","percent","sizeString1","decimal1","prefix1","exclamations","plus","minus","tildes","sizeString2","decimal2","prefix2","groups","multiplyByPrefix","prefixes","indexOf","extra1","extra2","sizeNum","size2Num","size2","dec1","dec2","a","b","_min","max","min","findAll","includes","rangeSearch","diff","from","to","word","parts","o","curWord","searcher","debug.addMessage","debug.appendMessage","allSize","reduce","acc","val","computeEntrySize","resultSet","filesSize","excludeSet","childrenSize","has","predicate","res","partSize","takePart","folderEntry","listAllEntries","curTime","parseScan","contentType","headers","isGZip","TextDecoder","textParser","TextParser","pakoIsLoaded","src","onload","crossOrigin","append","appendScript","loadPako","chunks","pako","Inflate","prototype","onData","chunk","inflator","u8Array","err","msg","unGZipAsyncIterator","textPart","decoder","decode","uint8Array","scanResultEntries","parsePart","parseGZippedJSONScan","obj","parser","isJSON","streamParseJSONScan","oldValue","__publicField","trimComma","handleStart","line","objects","metaLines","startHandled","handleLine","isLastLine","buffer","lines","isLastPart","JSON","rootMeta","_rootMeta","shallowReadonly","home","super","isHomeOpened","clearHome","_home","_isHomeOpened","updateParsingState","execution","abortRequested","_resolve","abort","_promise","start","abortIfRequested","setScan","keepSearch","scanParsing","metaInited","rootInited","processedTotal","scanMeta","rootEntry","rootContentUpdated","percentStr","startTime","scanRootPath","openedFolders","empty","scanDate","platform","doString","repeat","pad","commonFiles","unusualFiles","additional","toUpperCase","part1","part2","showSep","goToRoot","toRefs","props","isLast","onClick","onContextmenu","preventDefault","folderPath","navigator","clipboard","writeText","inputRef","onClearClick","focus","onContextMenu","readText","shiftTime","doubleShiftHandler","onMounted","onUnmounted","removeEventListener","state","postfix","templateInputElem","globalDropZone","dropZoneSelector","nwdirectory","onFileInputChange","fileElem","dropZone","fileInputElem","stopEvent","stopPropagation","onDrop","onDragOver","dropEffect","onDragEnter","onDragLeave","contains","relatedTarget","dragOverCallback","onKeyDown","click","onBeforeUnmount","webFileEntry","sizeClass","stringify","icon","filename","isVideo","isImage","isAudio","clicked","onMousedown","button","onMouseover","onMouseleave","fullPath","hoveredLink","noHardlinks","observer","IntersectionObserver","isIntersecting","intersection","disconnect","nameElemWidth","resizeNameElem","offsetWidth","w","px","onBeforeMount","toggleTimeType","_hoisted_3","_openBlock","memory","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","over100","showHint","formattedSize","isSupported","clear","intervalId","setInterval","clearInterval","show100","showGuide","filepath","response","hash","_search","createApp","mount"],"sources":["node-modules:///vite/modulepreload-polyfill","source-maps:///util.js","source-maps:///core/entries.js","source-maps:///core/debug.js","source-maps:///core/entry.js","source-maps:///components/file-input/WebFileEntry.js","source-maps:///components/file-input/file-input-state.ts","source-maps:///core/state.ts","source-maps:///core/mega-nz.js","source-maps:///core/search.js","source-maps:///core/scan-parser.js","source-maps:///core/folders.js","source-maps:///components/AddressBar_Base.vue","source-maps:///components/AddressBar_Folder.vue","source-maps:///components/AddressBar.vue","source-maps:///components/Search.vue","source-maps:///components/file-input/FileInputDefaultHoverText.vue","source-maps:///components/file-input/FileInputDefaultText.vue","source-maps:///components/file-input/FileInput.vue","source-maps:///core/file-input-handler.ts","source-maps:///components/Home.vue","source-maps:///components/Row.vue","source-maps:///components/IntersectionRow.vue","source-maps:///components/Content.vue","source-maps:///components/Status.vue","source-maps:///components/Switch.vue","source-maps:///components/Guide.vue","source-maps:///components/InnerModal.vue","source-maps:///components/MemoryConsuming.vue","source-maps:///components/ScanProgressBar.vue","source-maps:///components/Main.vue","source-maps:///main.js"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","export const setImmediate = globalThis.setImmediate || /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\nexport function sleep(ms) {\n    if (ms === undefined) {\n        return new Promise(resolve => setImmediate(resolve));\n    }\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const shuffle = () => Math.random() >= 0.5 ? -1 : 1;\n\n// todo: use Set\nconst videoExtensions = [\"mp4\", \"webm\", \"mkv\", \"avi\", \"mov\", \"m4v\", \"m4v\", \"mpg\", \"mpeg\", \"wmv\", \"flv\"];\nexport function isVideo(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return videoExtensions.includes(ext.toLowerCase());\n}\nconst imageExtensions = [\"jpg\", \"png\", \"jpeg\", \"gif\", \"webp\", \"jfif\", \"jpe\", \"tiff\"];\nexport function isImage(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return imageExtensions.includes(ext.toLowerCase());\n}\nconst audioExtensions = [\"mp3\", \"flac\", \"wav\", \"wma\", \"aac\"];\nexport function isAudio(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return audioExtensions.includes(ext.toLowerCase());\n}\n\nexport function debounce(runnable, ms = 50) {\n    let timerId;\n    return function() {\n        // console.log({timerId});\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            runnable.apply(this, arguments);\n            timerId = null;\n        }, ms);\n    }\n}\n\n\nexport function structuredClone(object) {\n    return new Promise(resolve => {\n        const {port1, port2} = new MessageChannel();\n        port1.onmessage = function(message) {\n            resolve(message.data);\n        };\n        port2.postMessage(object);\n    });\n}\n\nexport function appendScript(src, integrity) {\n    return new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.onload = resolve;\n        script.onerror = event => reject({message: \"Failed to load script\", src, integrity, event});\n        script.src = src;\n        script.async = true;\n        if (integrity) {\n            script.integrity = integrity;\n            script.crossOrigin = \"anonymous\";\n        }\n        document.body.append(script);\n    });\n}\n\n/**\n * `chunkSize` is 65536, ReadableStream uses the same size.\n * There is no speed difference between using of different the chunk's sizes.\n * @param {ArrayBuffer|Uint8Array} arrayBuffer\n * @param {Number} [chunkSize=65536]\n * @return {Generator<Uint8Array>}\n */\nexport function *iterateArrayBuffer(arrayBuffer, chunkSize = 65536) {\n    const buffer = new Uint8Array(arrayBuffer);\n    let index = 0;\n    while (true) {\n        const chunk = buffer.subarray(index, index + chunkSize);\n        if (!chunk.length) {\n            break;\n        }\n        yield chunk;\n        index += chunkSize;\n    }\n}\n\n/**\n * @param {Response|ReadableStream|Blob} dataSource\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateAsyncDataSource(dataSource) {\n    if (dataSource instanceof Response) {\n        dataSource = dataSource.body;\n    }\n    if (dataSource instanceof ReadableStream) {\n        yield *iterateReadableStream(dataSource);\n    } else if (dataSource instanceof Blob) {\n        for (const part of iterateBlob(dataSource)) {\n            yield await part;\n        }\n    }\n}\n\n\n/**\n * @param {ReadableStream} stream\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateReadableStream(stream) {\n    const reader = stream.getReader();\n    while (true) {\n        const {done, /** @type {Uint8Array} */ value} = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\n\n/**\n * Iterates Blob (or File).\n * Note: `chunkSize` affects the execution speed\n * @param {Blob} blob\n * @param {Number} [chunkSize=2097152]\n * @return {Generator<Promise<Uint8Array>>|AsyncGenerator<Uint8Array>}\n */\nexport function *iterateBlob(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        return new Uint8Array(await blob.arrayBuffer());\n    }\n}\n\n/**\n * Useful for file byte size formatting\n * 34456909 -> 34 456 909\n * @param {number} num */\nexport function tripleSizeGroups(num) {\n    const str = num.toString();\n    return str.padStart(str.length + (3 - str.length % 3)).match(/(.{3})/g).join(\" \").trimStart();\n}\n\n/**\n * Format bytes to human readable format.\n * Trims the tailing zeros.\n *\n * {@link https://stackoverflow.com/a/18650828/11468937}\n * @param {Number} bytes\n * @param {Number} [decimals=2]\n * @returns {String}\n */\nexport function bytesToSize(bytes, decimals = 2) {\n    if (bytes === 0) { return \"0 B\"; }\n    const k = 1024;\n    decimals = decimals < 0 ? 0 : decimals;\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n}\n\n/**\n * Formats bytes mostly like Windows does,\n * but in some rare cases the result is different.\n * Check the file with tests.\n * @see win-like-file-sizes.test.js\n * @param {Number} bytes\n * @return {string}\n */\nexport function bytesToSizeWinLike(bytes) {\n    if (bytes < 1024) { return bytes + \" B\"; }\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    let i = Math.floor(Math.log(bytes) / Math.log(1024));\n    let result = bytes / Math.pow(1024, i);\n    if (result >= 1000) {\n        i++;\n        result /= 1024;\n    }\n    return toTruncPrecision3(result) + \" \" + sizes[i];\n}\n\n/**\n * @see trunc-with-precision-3.test.js\n * @param {Number} number\n * @return {string}\n */\nexport function toTruncPrecision3(number) {\n    let result;\n    if (number < 10) {\n        result = Math.trunc(number * 100) / 100;\n    } else if (number < 100) {\n        result = Math.trunc(number * 10) / 10;\n    } else if (number < 1000) {\n        result = Math.trunc(number);\n    }\n    if (number < 0.1) {\n        return result.toPrecision(1);\n    } else if (number < 1) {\n        return result.toPrecision(2);\n    }\n    return result.toPrecision(3);\n}\n\n/**\n * @param {Uint8Array[]} arrays\n * @return {Uint8Array}\n */\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n\nexport function red(text) {\n    return [`%c${text}`,  \"color: #f44336; font-weight: bold;\"];\n}\nexport function orange(text) {\n    return [`%c${text}`,  \"color: #ff9800; font-weight: bold;\"];\n}\nexport function green(text) {\n    return [`%c${text}`,  \"color: #4caf50; font-weight: bold;\"];\n}\nexport function cyan(text) {\n    return [`%c${text}`,  \"color: #00bcd4; font-weight: bold;\"];\n}\nexport function blue(text) {\n    return [`%c${text}`,  \"color: #2196f3; font-weight: bold;\"];\n}\n\n\n\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\nexport function dateToDayDateString(dateValue, utc = true) {\n    return formatDate(dateValue, \"YYYY.MM.DD\", utc);\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10 22:22:22Z\"\nexport function dateToDayDateTimeString(dateValue, utc = true) {\n    return formatDate(dateValue, \"YYYY.MM.DD HH:mm:SS\", utc) + (utc ? \"Z\" : \"\");\n}\n\n/**\n * Formats date. Supports: YY.YYYY.MM.DD HH:mm:SS.\n * Default format: \"YYYY.MM.DD\". formatDate() -> \"2022.01.07\"\n * @param {Date|String|Number?} dateValue\n * @param {String?} pattern\n * @param {Boolean?} utc\n */\nexport function formatDate(dateValue = new Date(), pattern = \"YYYY.MM.DD\", utc = true) {\n    function isString(input) {\n        return typeof input === \"string\" || input instanceof String;\n    }\n    function firefoxDateFix(dateValue) {\n        return isString(dateValue) ? dateValue.replace(/(?<y>\\d{4})\\.(?<m>\\d{2})\\.(?<d>\\d{2})/, \"$<y>-$<m>-$<d>\") : dateValue;\n    }\n    function pad0(value, count = 2) {\n        return value.toString().padStart(count, \"0\");\n    }\n    class DateFormatter {\n        constructor(date = new Date(), utc = true) {\n            this.date = date;\n            this.utc = utc ? \"UTC\" : \"\";\n        }\n        get SS()   {return pad0(this.date[`get${this.utc}Seconds`]())}\n        get mm()   {return pad0(this.date[`get${this.utc}Minutes`]())}\n        get HH()   {return pad0(this.date[`get${this.utc}Hours`]())}\n\n        get MM()   {return pad0(this.date[`get${this.utc}Month`]() + 1)}\n        get DD()   {return pad0(this.date[`get${this.utc}Date`]())}\n        get YYYY() {return pad0(this.date[`get${this.utc}FullYear`](), 4)}\n        get YY()   {return this.YYYY.slice(2);}\n    }\n    dateValue = firefoxDateFix(dateValue);\n    const date = new Date(dateValue);\n    if (date.toString() === \"Invalid Date\") {\n        console.warn(\"Invalid Date value: \", dateValue);\n    }\n    const formatter = new DateFormatter(date, utc);\n    return pattern.replaceAll(/YYYY|YY|MM|DD|HH|mm|SS/g, (...args) => formatter[args[0]]);\n}\n","import {computed, ref} from \"vue\";\nimport {search, searchResult} from \"./search.js\";\nimport {openedFolder} from \"./folders.js\";\n\n\nexport const sort = ref(true);\n\n/** @type {import(\"vue\").Ref<(\"mtime\"|\"btime\")>} */\nexport const selectedTime = ref(\"mtime\");\n/** @type {import(\"vue\").Ref<(\"name\"|\"size\"|\"time\")>} */\nexport const orderBy = ref(\"name\");\nexport const orders = ref({\n    name: false,\n    size: false,\n    time: false,\n});\nexport const reverseOrder = computed(() => orders.value[orderBy.value]);\nexport function toggleOrder() {\n    orders.value[orderBy.value] = !orders.value[orderBy.value];\n}\n\n// todo tag:COMPUTED_TIME\n// export const computedFolderTime = ref(true);\n// globalThis.computedFolderTime = computedFolderTime;\n\nconst {compare} = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: \"accent\",\n});\n\n// // todo create the list variable (search result -> the list), (opened dir entries -> the list)\n// export const reactiveComparator = computed(() => {\n//     const k = reverseOrder.value ? -1 : 1;\n//     if (sort.value) {\n//         if (orderBy.value === \"name\") {\n//             return (pre, cur) => compare(pre.name, cur.name) * k;\n//         } else if (orderBy.value === \"size\") {\n//             return (pre, cur) => (pre.size - cur.size) * k;\n//         } else if (orderBy.value === \"mtime\") {\n//             return (pre, cur) => (pre.mtime - cur.mtime) * k;\n//         }\n//     }\n//     return (pre, cur) => 0;\n// });\n\nexport function comparator(pre, cur) {\n    const k = reverseOrder.value ? -1 : 1;\n    if (sort.value) {\n        if (orderBy.value === \"name\") {\n            return compare(pre.name, cur.name) * k;\n        } else if (orderBy.value === \"size\") {\n            return (pre.size - cur.size) * k;\n        } else if (orderBy.value === \"time\") {\n            const timeName = selectedTime.value;\n            return (pre[timeName] - cur[timeName]) * k;\n        }\n    }\n    return 0;\n}\n\n// grouped by type\nexport const entries = computed(() => {\n    return [\n        ...openedFolder.value.folders.sort(comparator),\n        ...openedFolder.value.files.sort(comparator),\n        ...openedFolder.value.symlinks.sort(comparator),\n        ...openedFolder.value.fifos.sort(comparator),\n        ...openedFolder.value.charDevs.sort(comparator),\n        ...openedFolder.value.blockDevs.sort(comparator),\n        ...openedFolder.value.sockets.sort(comparator),\n    ];\n});\n\n\n/** @type {import(\"vue\").Ref<Number>} */\nexport const limit = ref(50);\n\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const list = computed(() => {\n    if (search.value.length) {\n        return searchResult.value;\n    }\n    return entries.value;\n});\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const listLimited = computed(() => {\n    return list.value.slice(0, limit.value);\n});\n/** @type {import(\"vue\").ComputedRef<Number>} */\nexport const count = computed(() => {\n    if (searchResult.value.length > limit.value) {\n        return searchResult.value.length;\n    }\n    return list.value.length;\n});\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nexport const hoveredEntry = ref(null);\n\n\nObject.defineProperty(globalThis, \"list\", {\n    get() {\n        return list.value;\n    }\n});\nObject.defineProperty(globalThis, \"names\", {\n    get() {\n        return list.value.map(entry => entry.name);\n    }\n});\n","import {ref, toRaw, isProxy} from \"vue\";\nimport {bytesToSizeWinLike, dateToDayDateTimeString, tripleSizeGroups} from \"../util.js\";\n\nexport const debugMessage = ref(\"\");\nexport function addMessage(message) {\n    debugMessage.value = message;\n}\nexport function appendMessage(message) {\n    debugMessage.value += message;\n}\n\n/**\n * @param {SimpleEntry} entry\n */\nexport function debugMessageFromEntry(entry) {\n    console.log(isProxy(entry) ? \"Proxy:\" : \"Raw:\", toRaw(entry));\n    if (entry.hasErrors) {\n        debugMessage.value = \"\";\n    } else {\n        const name = entry.name ? (`\"` + entry.name.slice(0, 20) + (entry.name.length < 20 ? \"\" : \"…\") + `\"`) : \"\";\n\n        let messages = [];\n        if (entry.mtime !== undefined) {\n            messages.push(\"mtime \" + `\"${dateToDayDateTimeString(entry.mtime, false)}\"`);\n        }\n        if (entry.btime !== undefined) {\n            messages.push(\"btime \" + `\"${dateToDayDateTimeString(entry.btime, false)}\"`);\n        }\n        messages = [...messages, name, `${tripleSizeGroups(entry.size)} (${bytesToSizeWinLike(entry.size)})`];\n        debugMessage.value = messages.filter(m => m).join(\" — \");\n    }\n}\n","import {sleep} from \"../util.js\";\n\n/** @type {ScanEntryType[]} */\nexport const entryTypes = [\"folder\", \"file\", \"symlink\", \"fifo\", \"charDev\", \"blockDev\", \"socket\"];\n\nexport class SimpleEntry {\n    // [Symbol.toStringTag] = \"SimpleEntry\"; // Disables reactivity, BTW.\n    /**\n     * @param {SerializableScanEntry} entry\n     * @param {SimpleEntry|null} parent\n     * @param {Map<Number, SimpleScanError>} [errorsIDMap]\n     */\n    constructor(entry, parent, errorsIDMap) {\n        /** @type {String} */\n        this.name = entry.name;\n        /** @type {SimpleEntry|null} */\n        this.parent = parent;\n        /** @type {ScanEntryType} */\n        this.type = entry.type;\n\n        if (entry.size) {\n            /** @type {Number|undefined} */\n            this._size = entry.size;\n        }\n        if (entry.mtime) {\n            /** @type {Number|undefined} */\n            this._mtime = entry.mtime;\n        }\n        if (entry.btime) {\n            /** @type {Number|undefined} */\n            this.btime = entry.btime;\n\n            // todo tag:COMPUTED_TIME\n            // this._btime = entry.btime;\n        }\n\n        if (entry.errors) {\n            /** @type {SimpleScanError[]}|undefined} */\n            this.errors = entry.errors.map(id => errorsIDMap.get(id));\n        }\n\n        if (entry.pathTo) {\n            /** @type {String|undefined} */\n            this.pathTo = entry.pathTo;\n        }\n        if (entry.content) {\n            /** @type {String|undefined} */\n            this.content = entry.content;\n        }\n\n        parent?.addChild(this);\n    }\n    /** @param {SimpleEntry} entry */\n    addChild(entry) {\n        if (!this.children) {\n            /**\n             * `undefined` if there is no child\n             * @type {SimpleEntry[]|undefined}\n             */\n            this.children = [];\n        }\n        this.children.push(entry);\n        this.increaseContentSize(entry.size);\n    }\n    /** @param {SimpleEntry[]} entries\n     *  @param {Number} total */\n    addHardlinks(entries, total) {\n        /** @type {SimpleEntry[]|undefined} */\n        this.hardlinks = entries;\n        /** @type {Number|undefined} */\n        this.hardlinksTotal = total;\n    }\n\n    /** @param {ScanMeta|Object} meta */\n    addMeta(meta) {\n        /** @type {ScanMeta|Object|undefined} */\n        this.meta = meta;\n    }\n\n    increaseContentSize(size) {\n        if (!size) {\n            return;\n        }\n        if (!this._contentSize) {\n            this._contentSize = 0;\n        }\n        this._contentSize += size;\n        if (this.parent && size) {\n            this.parent.increaseContentSize(size);\n        }\n    }\n\n\n    // todo tag:COMPUTED_TIME\n    // /** @return {Number|undefined} */\n    // get mtime() {\n    //     if (this._mtime !== undefined) {\n    //         return this._mtime;\n    //     }\n    //     return getMaxChildPropertyValue(this, \"_mtime\", 16);\n    // }\n    //\n    // /** @return {Number|undefined} */\n    // get btime() {\n    //     if (this._btime !== undefined) {\n    //         return this._btime;\n    //     }\n    //     return getMaxChildPropertyValue(this, \"_btime\", 16);\n    // }\n\n    /** @return {Number|undefined} */\n    get mtime() {\n        if (this._mtime !== undefined) {\n            return this._mtime;\n        }\n        if (this.type === \"folder\" && this.children) { // Note: it's recursive // todo: an optional deep limit\n            let time = Number.MIN_SAFE_INTEGER;\n            for (const child of this.children) {\n                if (child.mtime > time) { // `child.mtime !== undefined` is not necessary\n                    time = child.mtime;\n                }\n            }\n            if (time !== Number.MIN_SAFE_INTEGER) {\n                return time;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Note: the folder size is computed on the creation step.\n     * @return {Number}\n     */\n    get size() {\n        if (this.type === \"folder\") {\n            return this._contentSize || 0;\n        }\n        return this._size || 0;\n    }\n\n    /** @return {SimpleEntry[]} */\n    get folders() {\n        return this.children?.filter(e => e.type === \"folder\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get files() {\n        return this.children?.filter(e => e.type === \"file\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get symlinks() {\n        return this.children?.filter(e => e.type === \"symlink\") || [];\n    }\n\n    /** @return {SimpleEntry[]} */\n    get fifos() {\n        return this.children?.filter(e => e.type === \"fifo\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get charDevs() {\n        return this.children?.filter(e => e.type === \"charDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get blockDevs() {\n        return this.children?.filter(e => e.type === \"blockDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get sockets() {\n        return this.children?.filter(e => e.type === \"socket\") || [];\n    }\n\n    /** @return {Boolean} */\n    get isEmpty() {\n        return !Boolean(this.children?.length);\n    }\n    /** @return {Boolean} */\n    get hasErrors() {\n        return Boolean(this.errors?.length);\n    }\n    /** @return {SimpleEntry} */\n    get root() {\n        if (!this.parent) {\n            return this;\n        }\n        return this.parent.root;\n    }\n    /** @return {SimpleEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n\n    get contentTypesStats() {\n        return this.getContentTypesStats();\n    }\n    _getContentTypesStats(deep = true, result = {}, target = this) {\n        if (target.type === \"folder\" && target.children) {\n            for (const child of target.children) {\n                if (!result[child.type]) {\n                    result[child.type] = 1;\n                } else {\n                    result[child.type]++;\n                }\n                if (child.type === \"folder\" && deep) {\n                    this._getContentTypesStats(deep, result, child);\n                }\n            }\n            return result;\n        }\n    }\n    getContentTypesStats(deep = true) {\n        console.time(\"getContentTypesStats\");\n        const result = this._getContentTypesStats(deep);\n        console.timeEnd(\"getContentTypesStats\");\n        return result;\n    }\n\n    /** @return {Generator<SimpleEntry>} */\n    *[Symbol.iterator]() {\n        yield this;\n        if (this.children) {\n            for (const child of this.children) {\n                yield * child;\n            }\n        }\n    }\n\n    /** @return {SimpleEntry[]} */\n    flat() {\n        return [...this];\n    }\n\n    /**\n     * @param {SimpleEntry[]} entries\n     * @return {SimpleEntry[]}\n     */\n    static flat(entries) {\n        return entries.map(e => [...e]).flat();\n    }\n\n    get pathString() {\n        return this.getPathString();\n    }\n\n    /**\n     * @param {ScanMeta|null} [meta]\n     * @return {string}\n     */\n    getPathString(meta) {\n        const names = this.path.map(e => e.name);\n        let pathStr;\n        if (meta?.path) {\n            pathStr = [...meta.path, ...names].join(meta.separator || \"/\");\n        } else {\n            pathStr = names.join(\"/\");\n        }\n        if (pathStr.startsWith(\"//\")) {\n            return pathStr.slice(1);\n        }\n        return pathStr;\n    }\n\n    // todo tag:COMPUTED_TIME\n    // getChildTime() {\n    //     if (this.type !== \"folder\") {\n    //         return this.mtime;\n    //     }\n    // }\n}\n\n// todo tag:COMPUTED_TIME\n// export function getMaxChildPropertyValue(object, property, deep = 1) {\n//     if (object.type === \"folder\" && object.children && deep) {\n//         deep--;\n//         let maxTime = Number.MIN_SAFE_INTEGER;\n//         for (const child of object.children) {\n//             const time = getMaxChildPropertyValue(child, property, deep);\n//             if (time > maxTime) {\n//                 maxTime = time;\n//             }\n//         }\n//         if (maxTime !== Number.MIN_SAFE_INTEGER) {\n//             return maxTime;\n//         }\n//     } else {\n//         return object[property];\n//     }\n// }\n\n/**\n * Like `ScanError`, but without `path`.\n * @typedef {Object} SimpleScanError\n * @property {String} code\n * @property {String} syscall\n * @property {Number} errno\n **/\n\nexport class EntryStreamParser {\n    constructor() {\n        this.rootId = 0;\n        /** @type {Map<Number, SimpleEntry>} */\n        this.map = new Map();\n        /** @type {Map<String, SimpleEntry[]>} */\n        this.hidMap = new Map();\n    }\n\n    /** @param {ScanMeta} meta */\n    setMeta(meta) {\n        /** @type {ScanMeta} */\n        this.meta = meta;\n        /** @type {Object<String, Number>} */\n        const errorsMap = meta.errorsMap;\n        if (!errorsMap) {\n            return;\n        }\n        /** @type {Map<Number, SimpleScanError>|undefined} */\n        this.errorsIDMap = new Map(Object.entries(errorsMap)\n            .map(([k, v]) => {\n                const [code, syscall, errno] = k.split(\":\");\n                return [v, {code, syscall, errno: Number(errno)}];\n            }));\n    }\n\n    /** @param {SerializableScanEntry[]} sEntriesPart\n     * @return {{root: SimpleEntry, rootUpdated: boolean, processed: number}}\n     */\n    parse(sEntriesPart) {\n        let rootUpdated = false;\n        for (const entry of sEntriesPart) {\n            /** @type {SimpleEntry|null}*/\n            const parent = this.map.get(entry.pid) ?? null;\n            const simpleEntry = new SimpleEntry(entry, parent, this.errorsIDMap);\n            if (entry.type === \"folder\") {\n                this.map.set(entry.id, simpleEntry);\n            }\n            if (entry.hid) {\n                const array = this.hidMap.get(entry.hid) || [];\n                this.hidMap.set(entry.hid, [...array, simpleEntry]);\n            }\n            if (entry.pid === this.rootId) {\n                rootUpdated = true;\n            }\n        }\n        return {\n            root: this.map.get(this.rootId),\n            rootUpdated,\n            processed: sEntriesPart.length,\n        }\n    }\n\n    processHIDMapAsync() {\n        if (!this.hidMap.size) {\n            return;\n        }\n        console.log(\"[hidMap]:\", this.hidMap);\n        console.time(\"hidMap\");\n        processHIDMapAsync(this.hidMap)\n            .then(() => console.timeEnd(\"hidMap\"));\n    }\n}\n\nasync function processHIDMapAsync(hidMap) {\n    let i = 0;\n    let time = 0; // `0` to do `sleep` on the first iteration\n\n    for (const [hid, simpleEntries] of hidMap.entries()) {\n        if (!(i++ % 1000)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n            }\n        }\n\n        /** @type {Number}*/\n        const totalLinks = Number(hid.split(\":\")[1]);\n        simpleEntries.forEach(e => {\n            e.addHardlinks(simpleEntries, totalLinks);\n        });\n    }\n}\n\n/** @type {SimpleEntry} */\nexport const folderDummy = new SimpleEntry({\n    type: \"folder\",\n    name: \"\",\n    pid: null,\n}, null);\n\n\nexport class SimpleBucketEntry extends SimpleEntry {\n    constructor({name} = {name: \"\"}) {\n        super({\n            name,\n            type: \"folder\",\n            pid: null\n        }, null);\n        this.addMeta({\n            // path: [\"\"]\n        });\n    }\n    get size() {\n        // Since _contentSize is wrong because of it's not a parent of children\n        // (It takes the child's size only once while child is being parsed)\n        return this.children.reduce((acc, child) => acc + child.size, 0);\n    }\n}\n","export const WebFileEntryType = {\n    file:   \"file\",\n    folder: \"folder\",\n};\n\nexport class WebFileEntry {\n    /**\n     * @param {Object} init\n     * @param {\"file\"|\"folder\"} init.type\n     * @param {FileWithPath|File?} init.file\n     * @param {WebFileEntry?} init.parent\n     * @param {String?} init.name\n     */\n    constructor({file, parent, type, name}) {\n        if (file) {\n            /** @type {FileWithPath|File|undefined} */\n            this.file = file;\n        }\n        if (parent) {\n            /** @type {WebFileEntry|undefined} */\n            this.parent = parent;\n            parent.addChild(this);\n        }\n        if (name) {\n            /** @type {String}\n             *  @private  */\n            this._name = name;\n        }\n        /** @type {\"file\"|\"folder\"} */\n        this.type = type;\n    }\n\n    /** @return {String|undefined} */\n    get nativePath() {\n        return this.file?.path;\n    }\n\n    /** @return {String} */\n    get name() {\n        return this._name || this.file?.name;\n    }\n\n    /** @private\n     *  @param {WebFileEntry} entry  */\n    addChild(entry) {\n        if (!this.children) {\n            /**\n             * `undefined` if there is no child\n             * @type {WebFileEntry[]|undefined}\n             */\n            this.children = [];\n        }\n        this.children.push(entry);\n        this.increaseContentSize(entry.size);\n    }\n\n    /** @private\n     *  @param {Number} size  */\n    increaseContentSize(size) {\n        if (!size) {\n            return;\n        }\n        if (!this._contentSize) {\n            /** @type {Number}\n             *  @private  */\n            this._contentSize = 0;\n        }\n        this._contentSize += size;\n        if (this.parent/* && size*/) {\n            this.parent.increaseContentSize(size);\n        }\n    }\n\n    /**\n     * Note: the folder size is computed on the creation step.\n     * @return {Number}\n     */\n    get size() {\n        if (this.type === \"folder\") {\n            return this._contentSize || 0;\n        }\n        return this.file?.size || 0;\n    }\n\n    /** @return {Number} */\n    get mtime() {\n        return this.file?.lastModified || 0;\n    }\n\n    /** @return {WebFileEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n\n    /** @return {Generator<WebFileEntry>} */\n    *[Symbol.iterator]() {\n        yield this;\n        if (this.children) {\n            for (const child of this.children) {\n                yield * child;\n            }\n        }\n    }\n\n    /** @return {WebFileEntry[]} */\n    flat() {\n        return [...this];\n    }\n\n    /**\n     * @param {WebFileEntry[]} entries\n     * @return {WebFileEntry[]}\n     */\n    static flat(entries) {\n        return entries.map(e => [...e]).flat();\n    }\n\n    /**\n     * @param {DataTransfer} dt\n     * @param {boolean} recursive\n     * @return {Promise<WebFileEntry[]>}\n     */\n    static async fromDataTransfer(dt, recursive) {\n        /** @type {DataTransferItem[]} */\n        const dtItems = [...dt.items];\n        /** @type {File[]} */\n        const files = [...dt.files];\n\n        /** @type {FileSystemEntry[]} */\n        const fileSystemEntries = await dtItemsToFileSystemEntries(dtItems);\n        console.log(\"[fileSystemEntries]:\", fileSystemEntries);\n\n        /** @type {WebFileEntry[]} */\n        const result = [];\n        for (const fileSystemEntry of fileSystemEntries) {\n            result.push(await fromFileSystemEntry(fileSystemEntry, null, recursive, files.shift()));\n        }\n        return result;\n    }\n\n    /**\n     * @param {File[]} files\n     * @param {\"file\"|\"folder\"} type\n     * @return {WebFileEntry[]}\n     */\n    static fromFiles(files, type = \"file\") {\n        /** @type {WebFileEntry[]} */\n        const result = [];\n        for (const file of files) {\n            result.push(new WebFileEntry({file, type}));\n        }\n        return result;\n    }\n}\n\n/**\n * @param {FileSystemEntry} fsEntry\n * @param {WebFileEntry|null} parent\n * @param {boolean} recursive=false\n * @param {File} [file]\n * @return {Promise<WebFileEntry|null>}\n */\nasync function fromFileSystemEntry(fsEntry, parent = null, recursive = false, file) {\n    if (fsEntry.isFile) {\n        try {\n            const file = await toFile(/** @type {FileSystemFileEntry} */ fsEntry);\n            return new WebFileEntry({file, type: \"file\", parent});\n        } catch (e) { // For example, for long path \\\\?\\M:\\...\n            console.error(\"[fromFileSystemEntry][error]\", fsEntry.name, e);\n            return null;\n        }\n    } else if (fsEntry.isDirectory && recursive) {\n        const dirEntry = new WebFileEntry({type: \"folder\", parent, name: fsEntry.name, file});\n        /** @type {AsyncGenerator<FileSystemEntry>} */\n        const entries = readFileSystemDirectoryEntry(/** @type {FileSystemDirectoryEntry} */ fsEntry);\n        for await (const entry of entries) {\n            // The entries will be attached to the parent (`dirEntry`).\n            await fromFileSystemEntry(entry, dirEntry, recursive);\n        }\n        return dirEntry;\n    } else {\n        return new WebFileEntry({type: \"folder\", parent, name: fsEntry.name, file});\n    }\n}\n\n/**\n * Works only with a http server\n * @param {FileSystemFileEntry} fsFileEntry\n * @return {Promise<File>}\n */\nfunction toFile(fsFileEntry) {\n    return new Promise((resolve, reject) => fsFileEntry.file(resolve, reject));\n}\n\n/**\n * @param {FileSystemDirectoryEntry} fsDirEntry\n * @return {AsyncGenerator<FileSystemEntry>}\n */\nasync function * readFileSystemDirectoryEntry(fsDirEntry) {\n    const reader = fsDirEntry.createReader();\n    let part = [];\n    do {\n        part = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));\n        for (const entry of part) {\n            yield entry;\n        }\n    } while (part.length);\n}\n\n/**\n * @param {DataTransferItem[]} dtItems\n * @return {Promise<FileSystemEntry[]>}\n */\nasync function dtItemsToFileSystemEntries(dtItems) {\n    const result = [];\n    for (const entry of dtItems) {\n        result.push(await dtItemToFileSystemEntry(entry));\n    }\n    return result;\n}\n\n/**\n * @param {DataTransferItem} entry\n * @return {Promise<FileSystemEntry>}\n */\nasync function dtItemToFileSystemEntry(entry) {\n    return entry.webkitGetAsEntry();\n}\n","import {computed, ComputedRef, DeepReadonly, readonly, Ref, ref, toRaw, watchEffect} from \"vue\";\nimport {WebFileEntry, WebFileEntryType} from \"./WebFileEntry.js\";\n\nexport type FileInputStatePrivate = {\n    inputElem:   Ref<HTMLInputElement>,\n    fileEntries: Ref<WebFileEntry[]>,\n    file:  ComputedRef<WebFileEntry>,\n    count: ComputedRef<number>,\n\n    dropHover: Ref<boolean>,\n    dropHoverItemCount: Ref<number>,\n    dropHoverTypes: Ref<string[]>,\n    parsing: Ref<boolean>,\n\n    setDataTransferHover(dt: DataTransfer): void,\n    resetDataTransferHover(): void,\n    setDataTransfer(dt: DataTransfer): void,\n    setFiles(filelist: FileList, resetDataTransfer?: boolean): void,\n\n    isNwDirectory: Ref<boolean>,\n}\n\nexport type FileInputState = {\n    fileEntries: DeepReadonly<Ref<WebFileEntry[]>>,\n    clearInput(): void,\n    private: FileInputStatePrivate,\n}\n\ndeclare const nw: any\nconst isNW: boolean = typeof nw !== \"undefined\" && nw[\"process\"]?.[\"__nwjs\"] === 1;\n\nexport function getStateInstance({recursive} = {recursive: false}): FileInputState {\n    const fileEntries:  Ref<WebFileEntry[]>     = ref([]);\n    const files:        Ref<File[]>             = ref([]);\n    const inputElem:    Ref<HTMLInputElement>   = ref(null);\n    const parsing:      Ref<boolean>            = ref(false);\n    const dtItems:      Ref<DataTransferItem[]> = ref([]);\n    const dataTransfer: Ref<DataTransfer>    = ref(null);\n    const dropHover:    Ref<boolean>         = ref(false);\n    const dropHoverItemCount: Ref<number>    = ref(0);\n    const dropHoverTypes:     Ref<string[]>  = ref([]);\n    const isNwDirectory:      Ref<boolean>   = ref(false);\n\n    watchEffect(async () => {\n        const time: number = Date.now();\n        parsing.value = true;\n        if (dataTransfer.value) {\n            console.log(\"[fromDataTransferItems]\");\n            fileEntries.value = await WebFileEntry.fromDataTransfer(dataTransfer.value, recursive);\n        } else\n        if (isNW && isNwDirectory.value) {\n            console.log(\"[isNwDirectory]\");\n            fileEntries.value = WebFileEntry.fromFiles(files.value, WebFileEntryType.folder);\n        } else {\n            console.log(\"[fromFiles]\");\n            fileEntries.value = WebFileEntry.fromFiles(files.value);\n        }\n        parsing.value = false;\n        console.log(\"[WebFileEntry parsing][time]:\", Date.now() - time, \"ms\");\n        console.log(\"[fileEntries]\", toRaw(fileEntries.value));\n    });\n\n    const file: ComputedRef<WebFileEntry> = computed(() => {\n        return fileEntries.value[0];\n    });\n\n    const count: ComputedRef<number> = computed(() => {\n        return fileEntries.value.length;\n    });\n\n    function setDataTransferHover(dt: DataTransfer) {\n        const count:    number   = dt.items.length;\n        const allTypes: string[] = [...dt.items].map(item => item.type);\n        const types:    string[] = [...new Set(allTypes)];\n\n        dropHoverItemCount.value = count;\n        dropHoverTypes.value = types;\n        console.log(\"[setDataTransferHover]:\", count, types);\n    }\n    function resetDataTransferHover() {\n        dropHoverItemCount.value = 0;\n        dropHoverTypes.value = [];\n    }\n\n    function setDataTransfer(dt: DataTransfer) {\n        console.log(\"setDataTransfer\", dt);\n        setFiles(dt.files, false);\n        _setDtItems(dt.items);\n        dataTransfer.value = dt;\n    }\n    function setFiles(filelist: FileList, resetDataTransfer: boolean = true) {\n        const _files: File[] = [...filelist];\n        files.value = _files;\n        console.log(\"[setFiles]:\", _files);\n        if (resetDataTransfer) {\n            dataTransfer.value = null;\n            dtItems.value = [];\n        }\n    }\n    function _setDtItems(items: DataTransferItemList) {\n        const _dtItems: DataTransferItem[] = [...items];\n        dtItems.value = _dtItems;\n        console.log(\"[_setDtItems]:\", _dtItems); // bug in chromium: `type` and `kind` is \"\" in the console when expand the array.\n        console.log(\"[_setDtItems][0]:\", {\n            kind: _dtItems[0].kind, type: _dtItems[0].type\n        });\n    }\n\n    function clearInput() {\n        inputElem.value.value = null;\n        files.value = [];\n        dataTransfer.value = null;\n        dtItems.value = [];\n    }\n\n    return {\n        fileEntries: readonly(fileEntries),\n        clearInput,\n        private: {\n            dropHover, dropHoverItemCount, dropHoverTypes,\n            fileEntries, parsing,\n            file, count,\n            setDataTransferHover, resetDataTransferHover,\n            setDataTransfer, setFiles,\n            isNwDirectory,\n            inputElem,\n        }\n    };\n}\n","import {ref, Ref} from \"vue\";\nimport {FileInputState, getStateInstance} from \"../components/file-input/file-input-state.js\";\n\nexport const scanParsing:         Ref<boolean> = ref(false);\nexport const allScansReady:       Ref<boolean> = ref(true);\nexport const scansCount:          Ref<number>  = ref(0);\nexport const currentScansNum:     Ref<number>  = ref(0);\nexport const scanParsingProgress: Ref<number>  = ref(0);\nexport const searching:           Ref<boolean> = ref(false);\nexport const searchAwaiting:      Ref<boolean> = ref(false);\n\nexport const fileInputState: FileInputState = getStateInstance({recursive: false});\n","import {SimpleEntry} from \"./entry.js\";\nimport {openFolder} from \"./folders.js\";\nimport {addMessage} from \"./debug.js\";\nimport {dateToDayDateTimeString} from \"../util.js\";\n\n// Some special\nexport async function handleMegaUrl(url) {\n    addMessage(url);\n\n    globalThis.Mega = await import(\"https://alttiri.github.io/meganz-api/meganz-api.standalone.es.js\");\n    // globalThis.Mega.MegaApi.encryptedName = true;\n\n    let node;\n    try {\n        node = await globalThis.Mega.node(url);\n    } catch (e) {\n        addMessage(e);\n        return;\n    }\n    node = node.root;\n    console.log(node);\n\n    /** @type {SimpleEntry} */\n    let result = parseMegaNode(node);\n    result._url = url;\n    console.log(result);\n\n    const special = {\n        url,\n        id: result._id,\n        ownerId: result._ownerId,\n        btime: result.btime && dateToDayDateTimeString(result.btime),\n        mtime: result.mtime && dateToDayDateTimeString(result.mtime),\n    };\n\n    if (result.type !== \"folder\") { // if it's a share of 1 file\n        const emptyRootFolder = new SimpleEntry({\n            type: \"folder\",\n            name: \"\",\n            pid: null\n        }, null);\n        emptyRootFolder.addChild(result);\n        result = emptyRootFolder;\n    }\n\n    result.root.addMeta({\n        special\n    });\n    openFolder(result);\n}\n\n/** @return {SerializableScanEntry} */\nfunction nodeToSEntry(node) {\n    return {\n        /**@type {string} */\n        name: node.name === null ? \"[encrypted]\" : node.name,\n        /**@type {number} */\n        size: node.size,\n        /**@type {number} */\n        btime: node.creationDate * 1000,\n        /**@type {number} */\n        mtime: node.modificationDate * 1000,\n        /**@type {String} */\n        id: node.id,\n        /**@type {ScanEntryType} */\n        type: (node.type === \"rootFolder\" || node.type === \"folder\") ? \"folder\" : \"file\",\n        /**@type {String} */\n        pid: node.parentId,\n    };\n}\n\nfunction toSEntry(megaNode, parent) {\n    /** @type {SerializableScanEntry}   */\n    const ssEntry = nodeToSEntry(megaNode);\n    const sEntry = new SimpleEntry(ssEntry, parent);\n    sEntry._id = megaNode.id;\n    sEntry._ownerId = megaNode.ownerId;\n    return sEntry;\n}\n\nfunction parseMegaNode(megaNode, parent = null) {\n    const sEntry = toSEntry(megaNode, parent);\n    if (sEntry.type === \"folder\") {\n        for (const mNode of [...megaNode.folders, ...megaNode.files]) {\n            parseMegaNode(mNode, sEntry);\n        }\n    }\n    return sEntry;\n}\n","import {isReactive, ref, shallowRef, toRaw, watch, watchEffect, triggerRef} from \"vue\";\nimport {blue, bytesToSizeWinLike, debounce, sleep} from \"../util.js\";\nimport {openedFolder} from \"./folders.js\";\nimport {comparator, limit, orderBy, reverseOrder, selectedTime} from \"./entries.js\";\nimport * as debug from \"./debug.js\";\nimport {entryTypes} from \"./entry.js\";\nimport {allScansReady, searchAwaiting, searching} from \"./state\";\nimport {handleMegaUrl} from \"./mega-nz.js\";\n\n/** @type {import(\"vue\").Ref<string>} */\nexport const search = ref(\"\"); // [v-model]\nexport function clearSearch() {\n    console.log(\"[clearSearch]\");\n    search.value = \"\";\n}\n\n/** @type {import(\"vue\").ShallowRef<SimpleEntry[]>} */\nexport const searchResult = shallowRef([]);\nfunction clearSearchResult() {\n    setSearchResult([]);\n}\n/** * @param {SimpleEntry[]} result */\nfunction setSearchResult(result) {\n    /** @type {SimpleEntry[]} */\n    const rawResult = toRaw(result);\n    searchResult.value = rawResult;\n    limit.value = 50;\n\n    addSearchResultToGlobalThis(rawResult);\n}\n\nwatch([orderBy, reverseOrder, selectedTime], () => {\n    sortSearch();\n});\n\nexport function sortSearch() {\n    //todo sort by parts\n    const time = Date.now();\n    searchResult.value.sort(comparator);\n    const timeTotal = Date.now() - time;\n    console.log(\"[search][sort][time]\", timeTotal, \"ms\");\n    triggerRef(searchResult);\n    return timeTotal;\n}\n\n/** @param {SimpleEntry[]} rawResult */\nfunction addSearchResultToGlobalThis(rawResult) {\n    /** @type {SimpleEntry[]} */\n    globalThis.search = rawResult;\n    console.log(\"globalThis.search:\", rawResult);\n    Object.defineProperty(globalThis.search, \"download\", {\n        get() {\n            console.log(\"download\"); // todo\n        }\n    });\n    Object.defineProperty(globalThis.search, \"names\", {\n        get() {\n            return globalThis.search.map(entry => entry.name);\n        }\n    });\n    Object.defineProperty(globalThis.search, \"namelist\", {\n        get() {\n            return globalThis.search.map(entry => entry.name).join(\"\\n\");\n        }\n    });\n}\n\nlet resolve = () => {};\nlet scanParsingCompleted = Promise.resolve(true);\nwatchEffect(() => {\n    if (!allScansReady.value) {\n        resolve(false);\n        scanParsingCompleted = new Promise(r => resolve = r);\n    } else {\n        resolve(true);\n    }\n});\n\nfunction simplify(input) {\n    // todo .normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\")\n    //  (It required to use a cache since it's a slow operation, and\n    //   only for the normalized values (not just lower cased) in order to save the memory consuming.)\n    // \"đ Crème Bruląśćńżółźćęéйeё\".normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\")\n    return input\n        .toLowerCase();\n}\n\nwindow.addEventListener(\"storage\", event => {\n    if (event.key !== \"search-sync\") {\n        return;\n    }\n    document.querySelector(\"input\").value = event.newValue;\n    document.querySelector(\"input\").dispatchEvent(new Event(\"input\"));\n});\n\n// todo? cancel an already in run if a new search available\n// todo check a linked list perf for large search\nconst performSearchDebounced = debounce(performSearch, 300);\nasync function performSearch() {\n    if (searching.value) {\n        console.log(\"[return][already searching]\");\n        return;\n    }\n\n    const searchSync = new URL(location.href).searchParams.get(\"searchSync\");\n    if (searchSync) {\n        localStorage.setItem(\"search-sync\", search.value);\n        document.title = `Search...`;\n    }\n\n    searching.value = true;\n\n    // Await while the scan parsing is completed, return `false` if there is a new `performSearch` call while parsing.\n    if (false === await scanParsingCompleted) {\n        console.log(\"[return][scan parsing completed]\");\n        return;\n    } else {\n        console.log(\"[next][scan parsing completed]\");\n    }\n\n    const folder = openedFolder.value;\n    const request = search.value;\n\n    if (request === \"\") { // was reset while scans setting\n        searching.value = false;\n        searchAwaiting.value = false;\n        return;\n    }\n\n    // Do unProxy. Up to x40 in comparison with default reactive ref.\n    const folderRaw = isReactive(folder) ? toRaw(folder) : folder;\n\n    const time1 = performance.now();\n    const {result, search: searchText} = await searcher(folderRaw, request);\n    searching.value = false;\n\n    if (search.value !== request) {\n        console.log(\"[return][new search requested]\");\n        return performSearch();\n    }\n\n    searchAwaiting.value = false;\n    if (!result) {\n        return;\n    }\n    const searchTime = performance.now() - time1;\n    debug.addMessage(`Search time: ${searchTime.toFixed(2)} ms; `);\n    await sleep();\n\n    setSearchResult(result);\n    const sortTime = sortSearch();\n    debug.appendMessage(`Sort time: ${sortTime.toFixed(2)} ms; `);\n    await sleep();\n\n    console.time(\"search result size computing\");\n    const resultSet = new Set(result);\n    const allSize = result.reduce((acc, val) => computeEntrySize(val, resultSet) + acc, 0);\n    const filesSize = result.filter(entry => entry.type !== \"folder\").reduce((acc, val) => val.size + acc, 0);\n    console.timeEnd(\"search result size computing\");\n    console.log({allSize, filesSize});\n\n    debug.appendMessage(`${result.length} items; size: ${bytesToSizeWinLike(filesSize)} (${bytesToSizeWinLike(allSize)});  search: ${searchText}`);\n\n    if (searchSync) {\n        document.title = `[${result.length}] found`;\n    }\n}\n\n\n/**\n * The recursive size computing of an `SimpleEntry`.\n * Skips the entries of `excludeSet`.\n * @param {SimpleEntry} entry\n * @param {Set<SimpleEntry>} excludeSet\n * @return {Number}\n */\nfunction computeEntrySize(entry, excludeSet) {\n    if (entry.type !== \"folder\") {\n        return entry.size;\n    }\n    let childrenSize = 0;\n    for (const child of entry.children || []) {\n        if (excludeSet.has(child)) {\n            continue;\n        }\n        if (child.type === \"folder\") {\n            childrenSize += computeEntrySize(child, excludeSet);\n        } else {\n            childrenSize += child.size;\n        }\n    }\n    return childrenSize;\n}\n\n/**\n * @param {SimpleEntry} folder\n * @param {string} search\n * @return {Promise<{result: SimpleEntry[], search: string}>}\n */\nasync function searcher(folder, search) {\n    console.log(\"[search]      \", search);\n\n    let strict;\n    if (search.startsWith(\"//\")) {\n        strict = true;\n        search = search.slice(2);\n    } else {\n        strict = false;\n        const normalized = simplify(search);\n        // todo? \"red_cat\" -> \"red cat\"\n        if (normalized !== search) {\n            console.log(\"[search][norm]\", normalized);\n            search = normalized;\n        }\n    }\n\n    let searchHelp = null;\n\n    /** @type {\"includes\"|\"startsWith\"|\"endsWith\"|\"===\"} */\n    let subStringMatcher = \"includes\";\n\n    // Simplified glob search.\n    // For \"startsWith\", \"endsWith\" and \"full match\" search.\n    // /*/*.html     - ends with \".html\"\n    // ///*/*.html   - ends with \".html\" case sensitive\n    // /*/.*         - starts with \".\"\n    // /8/.*         - starts with \".\" (the same, just to no need to use Shift key)\n    // /*/index.html - matches \"index.html\"\n    const isSimpleGlobSearch = search.startsWith(\"/*/\") || search.startsWith(\"/8/\");\n    if (isSimpleGlobSearch) {\n        const subSearch = search.slice(\"/*/\".length);\n        const starts = subSearch.startsWith(\"*\");\n        const ends = subSearch.endsWith(\"*\");\n\n        if (starts && ends) {\n            subStringMatcher = \"includes\";\n            search = subSearch.slice(1, -1);\n            searchHelp = `includes \"${search}\"`;\n        } else\n        if (starts) {\n            subStringMatcher = \"endsWith\";\n            search = subSearch.slice(1);\n            searchHelp = `ends with \"${search}\"`;\n        } else\n        if (ends) {\n            subStringMatcher = \"startsWith\";\n            search = subSearch.slice(0, -1);\n            searchHelp = `starts with \"${search}\"`;\n        } else {\n            subStringMatcher = \"===\";\n            search = subSearch;\n            searchHelp = `matches \"${search}\"`;\n        }\n    }\n\n    /** @type {function(String, String): Boolean} */\n    let stringMatcher;\n    if (strict) {\n        if (subStringMatcher === \"===\") {\n            stringMatcher = (string, substring) => string === substring;\n        } else {\n            stringMatcher = (string, substring) => string[subStringMatcher](substring);\n        }\n    } else {\n        if (subStringMatcher === \"===\") {\n            stringMatcher = (string, substring) => simplify(string) === substring;\n        } else {\n            stringMatcher = (string, substring) => simplify(string)[subStringMatcher](substring);\n        }\n    }\n\n    function justSearch(substring) {\n        return findAll(folder, (entry) => {\n            return stringMatcher(entry.name, substring);\n        });\n    }\n\n    if ([\"https://\", \"http://\"].some(prefix => search.startsWith(prefix))) {\n        const url = new URL(search);\n\n        if (url.hostname === \"www.youtube.com\" && url.pathname === \"/watch\") {\n            search = url.searchParams.get(\"v\");\n        } else {\n            const pathnameEndsWithSlash = url.pathname.length > 1 && url.pathname.endsWith(\"/\");\n            const pathname = pathnameEndsWithSlash ? url.pathname.slice(0, -1) : url.pathname;\n            const resourceFullName = pathname.match(/[^\\/]+$/)?.[0];\n            if (!resourceFullName) {\n                return {result: [], search};\n            }\n            const {\n                name: resName,\n                ext: resExt, // [note] it can be not the file extension, but a part of a nickname (inst url, for example)\n            } = resourceFullName.match(/(?<name>.+)(\\.(?<ext>.+))$/)?.groups || {name: resourceFullName};\n            search = resName + ((pathnameEndsWithSlash && resExt) ? `.${resExt}` : \"\");\n        }\n\n        const result = await justSearch(search);\n        return {result, search};\n    }\n\n\n    /**\n     * @example\n     * /size:0       - find 0 byte size entries\n     * /size/120     - the same, find 120 bytes size entries\n     * /size:120+80  - find from 120 to 200\n     * /size:120+-20 - find from 100 to 120\n     * /size:120~20  - find from  80 to 140\n     * /size:120-220 - find from 120 to 220\n     * /size:220-120 - find from 120 to 220\n     * /size:^2      - size.toString() starts with \"2\"\n     * /size:%2      - size.toString() includes    \"2\"\n     * /size:$0      - size.toString() ends with   \"0\"\n     * /s/0          - find 0 byte size entries, just a short form\n     * /s/120 900    - find 120900 bytes size entries\n     * /s/120,900    - find 120900 bytes size entries\n     *\n     * /size:120~    - find from 120 -5% to 120 +5%\n     * /size:120~~   - find from 120-10% to 120+10%\n     * /size:120~~~  - find from 120-15% to 120+15%\n     *\n     * /sizek:5      - find 5 KB ± 0.1 KB\n     * /sizek:50     - find 50 KB  ± 1 KB\n     * /sizek:500    - find 500 KB ± 1 KB\n     * /sizem:5      - find 5 MB ± 0.1 MB\n     * /sizeg/50     - find 50 GB ± 1 GB\n     *\n     * /size:5m      - find 5 MB ± 0.1 MB\n     *\n     * /s/12.9       - find 12 bytes size entries\n     * /sk/12.9      - find 12.9 KB ± 1 KB\n     *\n     * /sizek:5!     - find 5 KB + (0 - 0.01) KB\n     * /sizek:5!!    - find 5 KB + (0 - 0.001) KB\n     * /s/5k!!       - find 5 KB + (0 - 0.001) KB\n     * /sizem:50!    - find 50 MB + (0 - 0.1) MB\n     * /sizem:50!!   - find 50 MB + (0 - 0.01) MB\n     */\n    const r1 = `\\\\/s(ize)?(?<defaultPrefix>b|k|m|g|t)?[:\\\\/]`;\n    if (search.match(new RegExp(r1))) {\n        const r2   = `(?<extra1>(?<caret>\\\\^)|(?<dollar>\\\\$)|(?<percent>%))?`;\n        const r3   = `((?<sizeString1>\\\\s*\\\\d[\\\\d\\\\s\\\\,]*)((?<dotDecimal1>\\\\.(?<decimal1>\\\\d+)?))?(?<prefix1>b|k|m|g|t)?(?<exclamations>!+)?)`;\n\n        const r4_1 = `(?<extra2>(?<plus>\\\\+)|(?<minus>\\\\-)|(?<tildes>\\\\~+))`;\n        const r4_2 = `((?<sizeString2>\\\\s*-?\\\\s*\\\\d[\\\\d\\\\s\\\\,]*)((?<dotDecimal2>\\\\.(?<decimal2>\\\\d+)?))?(?<prefix2>b|k|m|g|t)?)?`;\n        const r4   = `(?<range>${r4_1}${r4_2})?`;\n\n        const regex = new RegExp(r1 + r2 + r3 + r4);\n\n        const {\n            /** @type {\"b\"|\"k\"|\"m\"|\"g\"|\"t\"|undefined} */\n            defaultPrefix,\n\n            /** @type {String|undefined} */\n            caret,\n            /** @type {String|undefined} */\n            dollar,\n            /** @type {String|undefined} */\n            percent,\n\n            /** @type {String|undefined} */\n            sizeString1,\n            /** @type {String|undefined} */\n            decimal1,\n            /** @type {String|undefined} */\n            prefix1,\n            /** @type {String|undefined} */\n            exclamations,\n\n            /** @type {String|undefined} */\n            plus,\n            /** @type {String|undefined} */\n            minus,\n            /** @type {String|undefined} */\n            tildes,\n\n            /** @type {String|undefined} */\n            sizeString2,\n            /** @type {String|undefined} */\n            decimal2,\n            /** @type {String|undefined} */\n            prefix2,\n\n        } = search.match(regex)?.groups || {};\n\n        if (sizeString1) {\n            console.log({\n                defaultPrefix,\n                extra1: {caret, dollar, percent},\n                sizeString1, decimal1, prefix1, exclamations,\n                extra2: {plus, minus, tildes, sizeString2, decimal2, prefix2},\n            });\n\n            let text;\n            let result;\n\n            let sizeNum = Number(sizeString1.replaceAll(/[\\s,]/g, \"\"));\n            const size = sizeNum.toString();\n\n            let size2Num = sizeString2 && Number(sizeString2.replaceAll(/[\\s,]/g, \"\"));\n            const size2 = size2Num?.toString();\n\n\n            const dec1 = decimal1 ? Number(\"0.\" + decimal1) : 0;\n            const dec2 = decimal2 ? Number(\"0.\" + decimal2) : 0;\n            sizeNum  = multiplyByPrefix(sizeNum  + dec1, prefix1 || defaultPrefix);\n            size2Num = multiplyByPrefix(size2Num + dec2, prefix2 || defaultPrefix);\n\n\n            /**\n             * @param {Number} a\n             * @param {Number} b\n             * @return {Promise<void>}\n             */\n            async function rangeSearch(a, b) {\n                const {_min, max} = a < b ? {_min: a, max: b} : {_min: b, max: a};\n                const min = Math.max(0, _min);\n                text = `Size search from ${bytesToSizeWinLike(min)} to ${bytesToSizeWinLike(max)}`;\n                result = await findAll(folder, entry => {\n                    return entry.size >= min && entry.size <= max;\n                });\n            }\n            function multiplyByPrefix(value, prefix = \"b\") {\n                if (value === undefined) {\n                    return;\n                }\n                const prefixes = [\"b\", \"k\", \"m\", \"g\", \"t\"];\n                return Math.trunc(value * (1024 ** prefixes.indexOf(prefix)));\n            }\n\n\n            if (caret) { // ^\n                text = `Size search starts with \"${size}\"`;\n                result = await findAll(folder, entry => {\n                    return entry.size.toString().startsWith(size);\n                });\n            } else\n            if (dollar) { // $\n                text = `Size search ends with \"${size}\"`;\n                result = await findAll(folder, entry => {\n                    return entry.size.toString().endsWith(size);\n                });\n            } else\n            if (percent) { // %\n                text = `Size search includes \"${size}\"`;\n                result = await findAll(folder, entry => {\n                    return entry.size.toString().includes(size);\n                });\n            } else\n            if (plus && size2) { // +\n                await rangeSearch(sizeNum, sizeNum + size2Num);\n            } else\n            if (minus && size2) { // -\n                await rangeSearch(sizeNum, size2Num);\n            } else\n            if (tildes) {  // ~ // ~~ // ~~~\n                if (size2) {\n                    await rangeSearch(sizeNum - size2Num, sizeNum + size2Num);\n                } else {\n                    const count = tildes.length;\n                    const diff = Math.trunc(sizeNum * 5 * count / 100);\n                    await rangeSearch(sizeNum - diff, sizeNum + diff);\n                }\n            } else { // Default\n                const prefix = prefix1 || defaultPrefix;\n                if (prefix && prefix !== \"b\") {\n\n                    let orders = size.length;\n                    let diff = multiplyByPrefix(1, prefix);\n                    if (orders === 1) {\n                        diff = Math.trunc(diff / 10);\n                    }\n\n                    let from = sizeNum - diff;\n                    let to   = sizeNum + diff;\n                    if (exclamations) {\n                        from = sizeNum;\n                        if (exclamations.length > 1) {\n                            to = sizeNum + Math.trunc(diff / 10);\n                        }\n                    }\n                    await rangeSearch(from, to);\n                } else {\n                    text = `Size search ${bytesToSizeWinLike(sizeNum)}`;\n                    result = await findAll(folder, entry => {\n                        return entry.size === sizeNum;\n                    });\n                }\n            }\n            console.log(...blue(text));\n            return {result, search: text};\n        } else {\n            const text = \"No size to search\";\n            console.log(...blue(text));\n            return {result: [], search: text};\n        }\n    }\n    if (search.startsWith(\"/\")) {\n        const {type, word} = search.match(/\\/type:(?<type>[^\\/]+)\\/?(?<word>[^\\/]*)/)?.groups || {};\n        if (type) {\n            console.log({type, word});\n            if (entryTypes.includes(type)) {\n                const result = await findAll(folder, entry => {\n                    return entry.type === type && stringMatcher(entry.name, word);\n                });\n                return {result, search};\n            }\n        }\n    } else\n    if (search.includes(\" \")) {\n        const parts = search.split(\" \").filter(o => o);\n        if (parts.length > 1) {\n            let result = await justSearch(parts.shift());\n            let curWord;\n            while (curWord = parts.shift()) {\n                result = result.filter(entry => stringMatcher(entry.name, curWord));\n            }\n            return {result, search};\n        }\n    }\n    return {result: await justSearch(search), search: (searchHelp || search)};\n}\n\nwatch(search, async (newValue, oldValue) => {\n    const isEmptyString = !newValue;\n    if (isEmptyString) {\n        clearSearchResult();\n        return;\n    }\n    searchAwaiting.value = true;\n\n    // In order to \"no debounce by paste event\"\n    if (newValue.length - oldValue.length > 1) {\n        if (newValue.startsWith(\"https://mega.nz/\")) {\n            await handleMegaUrl(newValue);\n            return;\n        }\n        await performSearch();\n    } else {\n        await performSearchDebounced();\n    }\n});\n\n/**\n * @param {SimpleEntry} folder\n * @param {function(SimpleEntry)} predicate\n * @return {Promise<SimpleEntry[]>}\n */\nasync function findAll(folder, predicate) {\n    let res = [];\n    let time = Date.now();\n    for (const entries of listAllEntries(folder)) {\n        const curTime = Date.now();\n        if (curTime - time > 15) {\n            time = curTime;\n            await sleep();\n        }\n        for (const entry of entries) {\n            if (predicate(entry)) {\n                res.push(entry);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * List all entries by parts.\n * @param {SimpleEntry} folder\n * @return {Generator<SimpleEntry[]>}\n */\nfunction *listAllEntries(folder) {\n    const partSize = 1000;\n    /** @type {SimpleEntry[]} */\n    let list = [];\n    /** @param {SimpleEntry} folderEntry */\n    function *takePart(folderEntry) {\n        for (const entry of (folderEntry.children || [])) {\n            if (entry.type === \"folder\") {\n                yield *takePart(entry);\n            }\n            list.push(entry);\n            if (list.length === partSize) {\n                yield list;\n                list = [];\n            }\n        }\n    }\n    yield *takePart(folder);\n    yield list;\n}\n","import {EntryStreamParser} from \"./entry.js\";\nimport {appendScript, iterateAsyncDataSource, sleep} from \"../util.js\";\n\n\n/**\n * @param {Blob|Response} input\n * @return {AsyncGenerator<{meta:ScanMeta, root: SimpleEntry, rootUpdated: boolean, processed: number}>}\n */\nexport async function *parseScan(input) {\n    const parser = new EntryStreamParser();\n\n    let contentType;\n    if (input instanceof Response) {\n        contentType = input.headers.get(\"content-type\");\n    } else if (input instanceof Blob) {\n        contentType = input.type;\n    }\n    /** @type {ScanMeta} */\n    let meta;\n    if (isGZip(contentType)) {\n        console.log(\"parseGZippedJSONScan\");\n        for await (const obj of parseGZippedJSONScan(input)) {\n            if (!meta) {\n                meta = /** @type {ScanMeta} */ obj.shift();\n                parser.setMeta(meta);\n            }\n            yield {meta, ...parser.parse(/** @type {SerializableScanEntry[]} */ obj)};\n        }\n    } else if (isJSON(contentType)) {\n        console.log(\"streamParseJSONScan\");\n        for await (const array of streamParseJSONScan(input)) {\n            if (!meta) {\n                meta = /** @type {ScanMeta} */ array.shift();\n                parser.setMeta(meta);\n            }\n            yield {meta, ...parser.parse(/** @type {SerializableScanEntry[]} */ array)};\n        }\n    }\n    parser.processHIDMapAsync();\n}\n\n\n/**\n * @param {Response|ReadableStream|Blob} input\n * @return {AsyncGenerator<FlatScanResultEntry[]>}\n */\nasync function *streamParseJSONScan(input) {\n    const decoder = new TextDecoder();\n    const textParser = new TextParser();\n    let i = 0, time = 0;\n    for await (const uint8Array of iterateAsyncDataSource(input)) {\n        if (!(i++ % 10)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        const scanResultEntries = textParser.parsePart(textPart);\n        if (scanResultEntries.length) {\n            yield scanResultEntries;\n        }\n    }\n}\n\n/**\n * @param {Response|Blob} input\n * @return {AsyncGenerator<FlatScanResultEntry[]>}\n */\nasync function *parseGZippedJSONScan(input) {\n    const decoder = new TextDecoder();\n    const textParser = new TextParser();\n    let i = 0, time = 0;\n    for await (const uint8Array of unGZipAsyncIterator(input)) {\n        if (!(i++ % 20)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        const scanResultEntries = textParser.parsePart(textPart);\n        if (scanResultEntries.length) {\n            yield scanResultEntries;\n        }\n    }\n}\n\n/**\n * @param {Response|ReadableStream|Blob} input\n * @return {Generator<Uint8Array>}\n */\nasync function *unGZipAsyncIterator(input) {\n    if (!isPakoLoaded()) {\n        await loadPako();\n    }\n    let chunks = [];\n    const inflator = new pako.Inflate();\n    pako.Inflate.prototype.onData = function (chunk) {\n        chunks.push(chunk);\n    };\n    for await (const u8Array of iterateAsyncDataSource(input)) {\n        inflator.push(u8Array);\n        for (const chunk of chunks) {\n            yield chunk;\n        }\n        chunks = [];\n    }\n    yield inflator.result;\n    if (inflator.err) {\n        console.error(inflator.msg);\n    }\n}\n\n\nexport class TextParser {\n    buffer = \"\";\n    startHandled = false;\n    metaLines = [];\n    objects = [];\n\n    trimComma(text) {\n        return text.endsWith(\",\") ? text.slice(0, -1) : text;\n    }\n\n    handleStart(line) {\n        if (line === \"[\") { // the first line\n            return;\n        }\n        if (line === \"\") { // meta is separated from the main content by \"\\n\"\n            this.objects.push(this.metaLines.join(\"\"));\n            this.startHandled = true;\n            return;\n        }\n        this.metaLines.push(line);\n    }\n\n    /**\n     * @param {String} line\n     * @param isLastLine\n     */\n    handleLine(line, isLastLine) {\n        if (isLastLine) {\n            this.buffer += line;\n            return;\n        }\n        if (this.buffer) {\n            this.objects.push(this.buffer + line);\n            this.buffer = \"\";\n        } else {\n            this.objects.push(line);\n        }\n    }\n\n    /**\n     * May return an empty array\n     * @param {String} textPart\n     * @return {FlatScanResultEntry[]}\n     * */\n    parsePart(textPart) {\n        const isLastPart = textPart.endsWith(\"\\n]\");\n        /** @type {String[]} */\n        const lines = textPart.split(\"\\n\");\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const isLastLine = i === lines.length - 1;\n\n            if (isLastLine && isLastPart) {\n                continue;\n            }\n\n            if (!this.startHandled) {\n                this.handleStart(line, isLastLine);\n            } else {\n                this.handleLine(line, isLastLine);\n            }\n        }\n        try {\n            /** @type {FlatScanResultEntry[]} */\n            const result = JSON.parse(`[${this.trimComma(this.objects.join(\"\"))}]`);\n            this.objects = [];\n            return result;\n        } catch (e) {\n            console.log(`[${this.trimComma(this.objects.join(\"\"))}]`);\n            console.log(this.objects);\n            console.log(this, {isLastPart, textPart});\n            throw e;\n        }\n\n    }\n\n}\n\n\nlet pakoIsLoaded = false;\nasync function loadPako() {\n    if (!pakoIsLoaded) {\n        const src = \"https://cdn.jsdelivr.net/npm/pako@2.0.4/dist/pako_inflate.min.js\";\n        const integrity = \"sha256-ZIKs3+RZEULSy0dR6c/mke8V9unZm9vuh05TqvtMdGU=\";\n        await appendScript(src, integrity);\n        pakoIsLoaded = true;\n        console.log(\"pako is loaded\");\n    }\n}\nfunction isPakoLoaded() {\n    return pakoIsLoaded;\n}\n\n\n/**\n * \"application/x-gzip\"\n * \"application/gzip\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isGZip(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?gzip/));\n}\n\n/**\n * \"application/json\"\n * \"application/json; charset=utf-8\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isJSON(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?json/));\n}\n","import {computed, watch, shallowRef, triggerRef, shallowReadonly, ref, readonly} from \"vue\";\nimport {clearSearch} from \"./search.js\";\nimport {folderDummy, SimpleBucketEntry, SimpleEntry} from \"./entry.js\";\nimport {dateToDayDateString, sleep} from \"../util.js\";\nimport {addMessage} from \"./debug.js\";\nimport {parseScan} from \"./scan-parser.js\";\nimport {limit} from \"./entries.js\";\nimport {scanParsing, scanParsingProgress} from \"./state\";\n\n\n/**\n * @typedef {Object} SpecialMeta\n * @property {Object} [special]\n */\n/**\n * @typedef {ScanMeta & SpecialMeta} FolderMeta\n */\n// Well, IDEA does not support `{ScanMeta & SpecialMeta}` correctly\n// todo make a class for it\n\n/** @type {import(\"vue\").ShallowRef<FolderMeta|null>} */\nconst rootMeta  = shallowRef(null);\n/** @type {import(\"vue\").ShallowRef<SimpleEntry>} */\nconst root      = shallowRef(null);\n\nconst _rootMeta = shallowReadonly(rootMeta);\nconst _root     = shallowReadonly(root);\nexport {_rootMeta as rootMeta, _root as root};\n\n/** @type {import(\"vue\").ShallowRef<SimpleBucketEntry>} */\nconst home = shallowRef(new SimpleBucketEntry());\nglobalThis.home = home.value;\nconst isHomeOpened = ref(false);\nexport function clearHome() {\n    console.log(\"clearHome\");\n    resetFolderState();\n    home.value.children = [];\n    triggerRef(openedFolder);\n}\n\nconst _home = shallowReadonly(home);\nconst _isHomeOpened = readonly(isHomeOpened);\nexport {_home as home, _isHomeOpened as isHomeOpened};\n\nfunction updateParsingState() {\n    triggerRef(openedFolder);\n}\n\nclass ExecutionState {\n    constructor() {\n        this.abortRequested = false;\n        this._promise = Promise.resolve();\n        this._resolve = () => {};\n    }\n    abort() {\n        this.abortRequested = true;\n        return this._promise;\n    }\n    start() {\n        this._promise = new Promise(r => this._resolve = r);\n    }\n    abortIfRequested() {\n        if (!execution.abortRequested) {\n            return false;\n        }\n        this.abortRequested = false;\n        this._resolve();\n        return true;\n    }\n}\nconst execution = new ExecutionState();\n/**\n * @param {Blob|Response} input\n * @param {Boolean} keepSearch\n * @return {Promise<Boolean>}\n */\nexport async function setScan(input, keepSearch = false) {\n    if (scanParsing.value) {\n        await execution.abort();\n    }\n    scanParsingProgress.value = 0;\n    scanParsing.value = true;\n    execution.start();\n\n    let metaInited = false;\n    let rootInited = false;\n\n    const startTime = Date.now();\n    let time = Date.now();\n    let processedTotal = 0;\n    let total;\n    for await (const {meta: scanMeta, root: rootEntry, rootUpdated: rootContentUpdated, processed} of parseScan(input)) {\n        processedTotal += processed;\n        if (total) {\n            const percentStr = (processedTotal / total * 100).toPrecision(3);\n            scanParsingProgress.value = Number(percentStr);\n        }\n\n        if (execution.abortIfRequested()) {\n            console.log(`[setScan][time][aborted]`, Date.now() - startTime, \"ms\");\n            return false;\n        }\n        if (!rootInited && rootEntry) {\n            if (!metaInited && scanMeta) {\n                rootEntry.meta = scanMeta;\n                metaInited = true;\n                total = scanMeta.total;\n                processedTotal -= 1;\n            }\n            openFolder(rootEntry, keepSearch);\n            rootInited = true;\n        }\n        const now = Date.now();\n        if (rootContentUpdated || now - time > 50) {\n            time = now;\n            updateParsingState();\n            await sleep();\n        }\n    }\n    updateParsingState();\n    console.log(`[setScan][time]:`, Date.now() - startTime, \"ms\");\n\n    scanParsing.value = false;\n    return true;\n}\n\n/** @type {import(\"vue\").ComputedRef<string>} */\nexport const separator = computed(() => {\n    return rootMeta.value?.separator || \"/\";\n});\n/** @type {import(\"vue\").ComputedRef<string[]>} */\nexport const scanRootPath = computed(() => {\n    return rootMeta.value?.path || [];\n});\n\n\n/** @type {import(\"vue\").ShallowRef<SimpleEntry>} */\nexport const openedFolder = shallowRef(folderDummy);\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const openedFolders = computed(() => {\n    return openedFolder.value.path;\n});\n\nexport function resetFolderState() {\n    clearSearch();\n    openFolder(folderDummy);\n    root.value = null;\n    rootMeta.value = null;\n    globalThis.root = null;\n    globalThis.folder = null;\n}\n\n/** @param {SimpleEntry} entry\n *  @param {Boolean} keepSearch  */\nexport function openFolder(entry, keepSearch = false) {\n    if (!keepSearch) {\n        clearSearch();\n    }\n    openedFolder.value = entry;\n    limit.value = 50;\n\n    const root = entry.root;\n    globalThis.root = root;\n    root.value = root;\n    rootMeta.value = root.meta || {};\n\n    if (entry !== home.value) {\n        if (!home.value.children?.includes(root)) {\n            home.value.addChild(root);\n            triggerRef(home);\n        }\n    }\n    isHomeOpened.value = entry === home.value;\n\n    /** @type {SimpleEntry} */\n    globalThis.folder = entry;\n    console.log(\"globalThis.folder:\", entry);\n}\nObject.defineProperty(globalThis, \"flat\", {\n    get() {\n        return globalThis.folder?.flat();\n    }\n});\n\nexport function goBack() {\n    if (openedFolder.value.parent) {\n        openFolder(openedFolder.value.parent);\n    }\n}\n/** @type {import(\"vue\").ComputedRef<Boolean>} */\nexport const empty = computed(() => root.value && openedFolder.value.isEmpty);\n\n\nwatch(rootMeta, async (newValue, oldValue) => {\n    console.log(\"[meta]:\", rootMeta.value);\n    if (!rootMeta.value) {\n        return;\n    }\n    const {files, folders, symlinks, errors, total, scanDate} = rootMeta.value;\n    if (rootMeta.value.scanDate) {\n        addMessage(\n            `files: \"${files}\" folders: \"${folders}\", symlinks: \"${symlinks}\", ` +\n            `errors: \"${errors}\", total: \"${total}\", scanDate: \"${dateToDayDateString(scanDate)}\"`\n        );\n    }\n});\n","<template>\n  <span class=\"scanPath\">\n    <span class=\"parts\" @click=\"goToRoot\" :title=\"title\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"spaced separator\" v-if=\"showSep\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\n//todo title\nimport {computed} from \"vue\";\nimport {scanRootPath, openedFolders, separator, openedFolder, openFolder, rootMeta} from \"../core/folders.js\";\nimport {dateToDayDateString} from \"../util.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst title = computed(() => {\n  if (!rootMeta.value) {\n    return;\n  }\n\n  const {\n      files, folders, symlinks,\n      charDevs, blockDevs, fifos, sockets,\n      total,\n      platform, scanDate\n  } = rootMeta.value;\n\n  function doString(o) {\n    function pad(str) {\n      const count = 3 - Math.trunc((str.length/4));\n      return str + \"\\t\".repeat(count);\n    }\n    return Object.entries(o)\n        .filter(([k, v]) => v !== undefined)\n        .map(([k, v]) => pad(k) + \": \" + v)\n        .join(\"\\n\");\n  }\n  const commonFiles = doString({files, folders, symlinks});\n  const unusualFiles = doString({charDevs, blockDevs, fifos, sockets});\n  const additional = doString({total, platform, scanDate: (scanDate ? dateToDayDateString(scanDate) : undefined)});\n  const special = doString(rootMeta.value.special || {});\n\n  let result;\n  if (platform !== \"win32\") {\n    result = [commonFiles, unusualFiles, additional, special].filter(v => v).join(\"\\n\");\n  } else {\n    result = [commonFiles, additional, special].filter(v => v).join(\"\\n\");\n  }\n  console.log(result);\n  return result;\n});\n\nconst root = computed(() => {\n  const scanPath = [...scanRootPath.value, openedFolder.value.root.name];\n  const str = scanPath.join(separator.value);\n  if (str.startsWith(\"//\")) { // for unix\n    return str.slice(1);\n  }\n  if (rootMeta.value?.platform === \"win32\") { // uppercase win drive letter // todo remove as unnecessary\n    return str[0].toUpperCase() + str.slice(1);\n  }\n  return str;\n});\nconst part1 = computed(() => {\n  return [...root.value].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...root.value].slice(-1).join(\"\");\n});\nconst showSep = computed(() => {\n  return (openedFolders.value.length - 1) && root.value !== \"/\";\n});\n\nfunction goToRoot() {\n  const root = openedFolder.value.root;\n  debugMessageFromEntry(root);\n  openFolder(root);\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.scanPath {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <span class=\"opened-folder\">\n    <span class=\"parts\" @click=\"onClick\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"separator spaced\" v-if=\"!isLast\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\nimport {computed, toRefs} from \"vue\";\nimport {openFolder, separator} from \"../core/folders.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst props = defineProps([\"index\", \"count\", \"entry\"]);\nconst {index, count, entry} = toRefs(props);\n\nconst isLast = computed(() => {\n  return index.value + 1 === count.value;\n});\nconst part1 = computed(() => {\n  return [...entry.value.name].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...entry.value.name].slice(-1).join(\"\");\n});\n\nfunction onClick() {\n  debugMessageFromEntry(entry.value);\n  openFolder(entry.value);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.opened-folder {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n\n    width: 100%;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part { // to use with max-width limitation // not works with  `display: contents;`\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: pre;\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n<div class=\"address\" @contextmenu=\"onContextmenu\">\n  <AddressBar_Part>\n    <AddressBar_Base/>\n  </AddressBar_Part>\n  <AddressBar_Part\n      v-for=\"(folder, i) of openedFolders.slice(1)\"\n  >\n    <AddressBar_Folder\n        :entry=\"folder\"\n        :index=\"i\"\n        :count=\"openedFolders.slice(1).length\"\n    />\n  </AddressBar_Part>\n</div>\n</template>\n\n<script setup>\nimport AddressBar_Base from \"./AddressBar_Base.vue\";\nimport AddressBar_Folder from \"./AddressBar_Folder.vue\";\nimport AddressBar_Part from \"./AddressBar_Part.vue\";\nimport {rootMeta, openedFolder, openedFolders, separator} from \"../core/folders.js\";\n\n/** @param {MouseEvent} event */\nasync function onContextmenu(event) {\n  event.preventDefault();\n  const folderPath = [...rootMeta.value.path, ...openedFolder.value.path.map(entry => entry.name)].join(separator.value);\n  console.log(\"Copy to clipboard:\", folderPath);\n  await navigator.clipboard.writeText(folderPath);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.address {\n  display: flex;\n  overflow-x: scroll;\n  padding-left: 6px;\n\n  scrollbar-width: none; // firefox\n  &::-webkit-scrollbar {\n    -webkit-appearance: none;\n    width: 0;\n    height: 0;\n    background: transparent;\n    display: none;\n  }\n  &:active { // todo only on onContextmenu event do it\n    border-right: var(--blue-1) solid 1px;\n  }\n}\n</style>\n","<template>\n  <div class=\"search-wrapper\">\n    <div class=\"search\">\n      <input id=\"json-scan-search-input\" type=\"text\"\n             v-model=\"search\"\n             ref=\"inputRef\"\n      >\n      <button\n          @click=\"onClearClick\"\n          @contextmenu.prevent=\"onContextMenu\"\n          title=\"Right click to clear and paste\"\n      >Clear</button>\n    </div>\n    <label for=\"json-scan-search-input\" class=\"fuck-off-lighthouse\">.</label>\n  </div>\n</template>\n\n<script setup>\nimport {search, clearSearch} from \"../core/search.js\";\nimport {ref, onMounted, onUnmounted} from \"vue\";\n\nconst inputRef = ref();\nfunction onClearClick() {\n  clearSearch();\n  inputRef.value.focus();\n}\n\nasync function onContextMenu() {\n  try {\n    const text = await navigator.clipboard.readText();\n    console.log(\"[clipboard] readText:\", text);\n    search.value = text;\n  } catch (err) {\n    console.error(\"[clipboard] read failed\", err);\n  }\n}\n\nlet shiftTime = 0;\nfunction doubleShiftHandler(event) {\n  if (event.key !== \"Shift\") {\n    return;\n  }\n  const now = Date.now();\n  if (now - shiftTime < 250) {\n    inputRef.value.focus();\n  } else {\n    shiftTime = now;\n  }\n}\nonMounted(() => document.addEventListener(\"keydown\", doubleShiftHandler));\nonUnmounted(() => document.removeEventListener(\"keydown\", doubleShiftHandler));\n\n</script>\n\n<style lang=\"scss\" scoped>\n/** reset */\ninput { padding: 0 0; }\nbutton { padding: 0 0; }\n\n.fuck-off-lighthouse {\n  position: absolute;\n  top:-1000px;\n  left:-1000px;\n}\n\n.search {\n  display: flex;\n  height: 100%;\n  label {\n    display: contents;\n  }\n  input {\n    height: 100%;\n    flex-grow: 2;\n    border: none;\n    padding-left: 6px;\n    border-bottom: transparent solid 1px;\n    box-sizing: border-box;\n    &:focus, &:hover {\n      outline: none;\n      border-bottom: var(--blue-1) solid 1px;\n    }\n  }\n  button {\n    height: 100%;\n    padding: 0 6px;\n    //outline: none;\n    outline-width: 1px;\n    outline-color: var(--blue-1);\n    border: none;\n    border-bottom: transparent solid 1px;\n    border-left: var(--gray-2) solid 1px;\n    box-sizing: border-box;\n    background-color: var(--gray-1);\n    &:hover {\n      border-bottom: var(--blue-1) solid 1px;\n      background: var(--blue-2);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"default-hover-text\">{{text}}</div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from \"vue\";\nimport {FileInputState} from \"./file-input-state\";\n\nconst props = defineProps<{state: FileInputState}>();\nconst {\n  dropHoverItemCount\n} = props.state.private;\n\nconst text = computed(() => {\n  const postfix = dropHoverItemCount.value > 1 ? \"s\" : \"\";\n  return `Drop ${dropHoverItemCount.value} file${postfix}`;\n});\n</script>\n\n<style scoped>\n.default-hover-text {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n","<template>\n  <div class=\"default-prompt-text\" :title=\"names\">\n    <div class=\"parsing\" v-if=\"parsing\">Parsing...</div>\n    <div v-else-if=\"count\">{{count}} file{{count > 1 ? \"s\" : \"\"}}</div>\n    <div v-else style=\"display: contents\">\n      <slot>Select file</slot>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from \"vue\";\nimport {FileInputState} from \"./file-input-state\";\n\nconst props = defineProps<{state: FileInputState}>();\nconst {\n  count, fileEntries, parsing\n} = props.state.private;\n\nconst names = computed(() => {\n  /** @type {WebFileEntry[]} */\n  const entries = fileEntries.value;\n  return entries.slice(0, 50).map(file => file.name).join(\"\\n\");\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.default-prompt-text {\n  width: inherit;\n  height: inherit;\n  max-width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  cursor: pointer;\n\n  &:hover {\n    //text-decoration: underline;\n  }\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n</style>\n","<template>\n<div\n    class=\"file-input\"\n    ref=\"fileInputElem\"\n    :class=\"{'drop-hover': dropHover}\"\n    tabindex=\"0\"\n    @keydown=\"onKeyDown\"\n>\n  <label>\n    <input type=\"file\"\n           :accept=\"accept\"\n           :multiple=\"multiple\"\n           @change=\"onFileInputChange\"\n           style=\"display: none\"\n           :nwdirectory=\"nwdirectory\"\n           ref=\"templateInputElem\"\n    >\n\n    <span class=\"content hover\" v-if=\"dropHover\">\n      <slot name=\"hover\"><FileInputDefaultHoverText :state=\"state\"/></slot>\n    </span>\n    <span class=\"content selected\" v-else-if=\"file && !parsing\">\n      <slot name=\"selected\"><FileInputDefaultText :state=\"state\"/></slot>\n    </span>\n    <span class=\"content prompt\" v-else>\n      <slot name=\"prompt\"><FileInputDefaultText :state=\"state\"/></slot>\n    </span>\n\n  </label>\n  <teleport to=\"body\">\n    <div class=\"file-input-hover-modal\" :class=\"{'drop-hover': dropHover}\"></div>\n  </teleport>\n</div>\n</template>\n\n<script setup lang=\"ts\">\nimport FileInputDefaultHoverText from \"./FileInputDefaultHoverText.vue\";\nimport FileInputDefaultText from \"./FileInputDefaultText.vue\";\nimport {FileInputState} from \"./file-input-state\";\n\nimport {\n  ref, toRefs, onMounted, computed, onBeforeUnmount, watchEffect,\n  PropType, Ref, ComputedRef\n} from \"vue\";\n\nconst templateInputElem: Ref<HTMLInputElement> = ref(null);\n\nconst props = defineProps({\n  globalDropZone: {\n    type: Boolean,\n    default: true\n  },\n  dropZoneSelector: {\n    type: String\n  },\n  accept: {\n    type: String,\n    default: \"*/*\"\n  },\n  multiple: {\n    type: Boolean,\n    default: true\n  },\n  state: {\n    type: Object as PropType<FileInputState>,\n    required: true\n  },\n  nwdirectory: {\n    type: Boolean,\n    default: false\n  }\n});\n\nconst {\n  globalDropZone,\n  dropZoneSelector,\n  nwdirectory,\n} = toRefs(props);\n\nconst {\n  parsing,\n  file,\n  dropHover,\n  setFiles,\n  setDataTransfer,\n  setDataTransferHover,\n  resetDataTransferHover,\n  isNwDirectory,\n  inputElem,\n} = props.state.private;\n\n\nwatchEffect(() => {\n  isNwDirectory.value = nwdirectory.value;\n});\nwatchEffect(() => {\n  inputElem.value = templateInputElem.value;\n});\n\nfunction onFileInputChange(event: Event) {\n  const fileElem = event.target as HTMLInputElement;\n  setFiles(fileElem.files);\n}\n\nconst fileInputElem: Ref<HTMLElement> = ref(null);\n\nconst dropZone: ComputedRef<HTMLElement> = computed(() => {\n  if (dropZoneSelector.value) {\n    return document.querySelector(dropZoneSelector.value);\n  } else\n  if (globalDropZone.value) {\n    return document.body;\n  } else\n  return fileInputElem.value;\n});\n\nonMounted(() => {\n  initListeners();\n});\nonBeforeUnmount(() => {\n  removeListeners();\n});\n\nfunction initListeners() {\n  dropZone.value.addEventListener(\"drop\", onDrop);\n  dropZone.value.addEventListener(\"dragover\", onDragOver);\n  dropZone.value.addEventListener(\"dragleave\", onDragLeave);\n  dropZone.value.addEventListener(\"dragenter\", onDragEnter);\n\n  document.body.addEventListener(\"dragover\", dragOverCallback);\n}\nfunction removeListeners() {\n  dropZone.value.removeEventListener(\"drop\", onDrop);\n  dropZone.value.removeEventListener(\"dragover\", onDragOver);\n  dropZone.value.removeEventListener(\"dragleave\", onDragLeave);\n  dropZone.value.removeEventListener(\"dragenter\", onDragEnter);\n\n  document.body.removeEventListener(\"dragover\", dragOverCallback);\n}\n\nfunction stopEvent(event: Event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nfunction onDrop(event: DragEvent) {\n  stopEvent(event);\n  dropHover.value = false;\n  setDataTransfer(event.dataTransfer);\n}\nfunction onDragOver(event: DragEvent) {\n  stopEvent(event);\n  event.dataTransfer.dropEffect = \"copy\";\n}\nfunction onDragEnter(event: DragEvent) {\n  stopEvent(event);\n  if (!dropHover.value) {\n    dropHover.value = true;\n  } else {\n    return;\n  }\n  setDataTransferHover(event.dataTransfer);\n}\nfunction onDragLeave(event: DragEvent) {\n  stopEvent(event);\n  if (!dropZone.value.contains(event.relatedTarget as Node)) {\n    dropHover.value = false;\n    resetDataTransferHover();\n  }\n}\n\nfunction dragOverCallback(event: DragEvent) {\n  if (!dropZone.value.contains(event.target as Node)) {\n    stopEvent(event);\n    event.dataTransfer.dropEffect = \"none\";\n  }\n}\n\nfunction onKeyDown(event: KeyboardEvent) {\n  if (event.key === \"Enter\") {\n    fileInputElem.value.querySelector(\"label\").click();\n  }\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.file-input {\n  transition: background-color 0.1s;\n  border: solid 1px var(--file-input-border);\n  box-sizing: border-box;\n  &.drop-hover {\n    background-color: var(--drop-file-hover);\n    transition: background-color 0.1s;\n  }\n  &:hover {\n    background-color: var(--drop-hover);\n  }\n  &:active {\n    background-color: var(--drop-active);\n  }\n}\n.file-input, label, .content {\n  width: 100%;\n  height: 100%;\n}\n\n.file-input-hover-modal {\n  height: 50px;\n  width: 100%;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n  background-image: linear-gradient(to top, rgba(0,0,0,0.15), rgba(0,0,0,0.005));\n\n  transition: opacity 0.25s ease-out;\n  opacity: 0;\n  &.drop-hover {\n    opacity: 1;\n  }\n}\n</style>\n\n\n\n\n\n\n\n\n\n\n","import {DeepReadonly, Ref, watch} from \"vue\";\nimport {clearHome, home, openFolder, setScan} from \"./folders.js\";\nimport {allScansReady, currentScansNum, fileInputState, scansCount} from \"./state\";\nimport {debugMessageFromEntry} from \"./debug.js\";\nimport {WebFileEntry} from \"../components/file-input/WebFileEntry\";\n\n\nconst fileEntries: DeepReadonly<Ref<WebFileEntry[]>> = fileInputState.fileEntries;\n\nwatch(fileEntries, async () => {\n    clearHome();\n    allScansReady.value = false;\n    scansCount.value = fileEntries.value.length;\n    currentScansNum.value = 0;\n    for (const webFileEntry of fileEntries.value) {\n        currentScansNum.value++;\n        await setScan(webFileEntry.file, true);\n    }\n    if (fileEntries.value.length > 1) {\n        openFolder(home.value, true);\n        debugMessageFromEntry(home.value);\n    }\n    allScansReady.value = true;\n});\n","<template>\n  <div class=\"home\" @click=\"onClick\" @contextmenu=\"onContextMenu\" :class=\"{active: isHomeOpened}\" v-if=\"show\">\n    Home\n  </div>\n</template>\n\n<script setup>\nimport {home, openFolder, isHomeOpened, clearHome} from \"../core/folders.js\";\nimport {computed} from \"vue\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst show = computed(() => {\n  return home.value?.children?.length > 1;\n});\n\nfunction onClick() {\n  debugMessageFromEntry(home.value);\n  openFolder(home.value);\n}\nfunction onContextMenu(event) {\n  event.preventDefault();\n  clearHome();\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.home {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  min-height: 35px;\n\n  border: var(--gray-2) solid 1px;\n  border-right: 0;\n  border-left: 0;\n  box-sizing: border-box;\n  &:hover {\n    background-color: var(--drop-hover);\n    cursor: pointer;\n  }\n  &:active {\n    background-color: var(--drop-active);\n  }\n  &.active {\n    border-width: 2px;\n  }\n}\n</style>\n","<template>\n  <tr class=\"row\"\n      @click=\"onClick\"\n      @mousedown=\"onMousedown\"\n      @mouseover=\"onMouseover\"\n      @mouseleave=\"onMouseleave\"\n      :title=\"title\"\n      :class=\"{error, hoveredLink}\"\n  >\n      <td class=\"icon\">{{icon}}</td>\n      <td class=\"name\" :title=\"entry.getPathString(entry.root.meta)\">{{entry.name}}</td>\n      <td class=\"size\" :class=\"sizeClass\" :title=\"tripleSizeGroups(entry.size)\">{{size}}</td>\n      <td class=\"time\" :class=\"{[selectedTime]: true}\">{{time}}</td>\n<!--      <td class=\"type\">{{entry.type}}</td>-->\n<!--      <td class=\"filler\"></td>-->\n  </tr>\n</template>\n\n<script setup>\nimport {toRefs, computed, watchEffect, ref} from \"vue\";\nimport {openedFolder, openFolder} from \"../core/folders.js\";\nimport {bytesToSizeWinLike, dateToDayDateTimeString, isImage, isVideo, isAudio, tripleSizeGroups} from \"../util.js\";\nimport {hoveredEntry, selectedTime} from \"../core/entries.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst props = defineProps([\"entry\"]);\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst entry = toRefs(props).entry;\n\nconst size = computed(() => {\n  return entry.value.hasErrors ? \"\" : bytesToSizeWinLike(entry.value.size);\n});\n\nconst sizeClass = computed(() => {\n  if (size.value === \"0 B\") {\n    return \"Z\";\n  }\n  return size.value.split(\" \")[1];\n});\n\n\n/** @type {import(\"vue\").Ref<Boolean>} */\nconst error = computed(() => {\n  return entry.value.hasErrors;\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst time = computed(() => {\n  if (entry.value[selectedTime.value] === undefined) {\n    return \"\";\n  }\n\n  // todo tag:COMPUTED_TIME\n  // fucking slow on parsing\n  //\n  // let timeValue;\n  // if (computedFolderTime.value) {\n  //   timeValue = getMaxChildPropertyValue(entry.value, \"_\" + selectedTime.value, 128);\n  // } else {\n  //   timeValue = entry.value[selectedTime.value];\n  // }\n  // const time = dateToDayDateTimeString(timeValue, false);\n\n  const time = dateToDayDateTimeString(entry.value[selectedTime.value], false);\n  return time.slice(0, -3); // trim seconds\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst title = computed(() => {\n  if (entry.value.hasErrors) {\n    return JSON.stringify(entry.value.errors[0], null, \" \");\n  }\n  if (entry.value.type === \"symlink\") {\n    return entry.value.pathTo;\n  }\n});\n\n/** @type {import(\"vue\").Ref<String>} */\nconst icon = computed(() => {\n  const type = entry.value.type;\n  if (type === \"folder\") {\n    return \"📁\";\n  } else if (type === \"file\") {\n    const name = entry.value.name;\n    if (isVideo(name)) {\n      return \"🎦\";\n    } else if (isImage(name)) {\n      return \"🖼\";\n    } else if (isAudio(name)) {\n      return \"🎵\";\n    }\n    return \"📄\";\n  } else if (type === \"symlink\") {\n    return \"🔗\";\n  }\n  return \"👾\";\n});\n\nfunction onClick(event) {\n  debugMessageFromEntry(entry.value);\n\n  globalThis.c = globalThis.clicked = entry.value;\n\n  if (entry.value.type === \"folder\") {\n    openFolder(entry.value);\n  }\n}\n\n/** @param {MouseEvent} event */\nfunction onMousedown(event) {\n  const MIDDLE_BUTTON = 1;\n  const RIGHT_BUTTON = 2;\n  if (event.button === MIDDLE_BUTTON) {\n    event.preventDefault();\n    console.log(\n        entry.value.getPathString(entry.value.root.meta),\n        entry.value,\n    );\n\n    if (openedFolder.value !== entry.value.parent) {\n      openFolder(entry.value.parent);\n    }\n  }\n}\n\nfunction onMouseover(event) {\n  hoveredEntry.value = entry.value;\n}\nfunction onMouseleave(event) {\n  hoveredEntry.value = null;\n}\n\n// todo something for an infinite looped  folder\nconst hoveredLink = ref(false);\nwatchEffect(() => {\n  if (hoveredEntry.value?.type === \"symlink\") {\n    const pathTo = hoveredEntry.value.pathTo;\n    const fullPath = entry.value.getPathString(entry.value.root.meta);\n    hoveredLink.value = pathTo === fullPath;\n    return;\n  }\n  const noHardlinks = !hoveredEntry.value?.hardlinks;\n  if (hoveredLink.value && noHardlinks) {\n    hoveredLink.value = false;\n  }\n  if (noHardlinks) {\n    return;\n  }\n  hoveredLink.value = hoveredEntry.value.hardlinks.includes(entry.value);\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.row {\n  width: 100%;\n  min-height: 28px;\n  display: flex;\n  align-items: center;\n  &:hover {\n    background-color: var(--blue-2);\n  }\n  &.hoveredLink:not(:hover) {\n    background-color: var(--blue-4);\n  }\n  * {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n  }\n  td {\n    &.icon {\n      border-left: 2px solid transparent;\n      width: 24px;\n      text-align: center;\n      user-select: none;\n    }\n    &.name {\n      display: block;\n      //width: 880px; // gets it from the parent\n      white-space: pre; // to display tailing spaces\n    }\n    &.size {\n      text-align: end;\n      min-width: 72px;\n      &.Z {\n        color: #888;\n      }\n      &.B {\n        color: #666;\n      }\n      &.KB {\n        color: #0b0;\n      }\n      &.MB {\n        color: #0070dd;\n      }\n      &.GB {\n        color: #a335ee;\n      }\n      &.TB {\n        color: #ff8000;\n      }\n    }\n    &.time {\n      text-align: end;\n      width: 140px;\n      color: #777;\n    }\n    &.type {\n      text-align: end;\n      width: 58px;\n      user-select: none;\n    }\n    //&.filler {\n    //  width: inherit;\n    //}\n  }\n  &.error {\n    .icon {\n      border-left: 2px solid red;\n    }\n  }\n}\n</style>\n","<template>\n<div class=\"intersection\" ref=\"intersection\"></div>\n</template>\n\n<script setup>\nimport {onBeforeUnmount, onMounted, ref} from \"vue\";\nimport {count, limit} from \"../core/entries.js\";\n\n/** @param {IntersectionObserverEntry[]} entries */\nconst callback = (entries) => {\n  const [entry] = entries;\n  if (entry.isIntersecting) {\n    if (count.value > limit.value) {\n      limit.value = limit.value + 50;\n    }\n  }\n}\nconst observer = new IntersectionObserver(callback);\n\n/** @type {import(\"vue\").Ref<HTMLElement>} */\nconst intersection = ref(null);\n\nonMounted(() => {\n  observer.observe(intersection.value);\n});\nonBeforeUnmount(() => {\n  observer.disconnect();\n});\n</script>\n\n<style scoped>\n.intersection {\n  width: 100%;\n  position: relative;\n  bottom: 120px;\n}\n</style>\n","<template>\n  <div class=\"content\"\n       @contextmenu=\"onContextMenu\"\n  >\n    <table class=\"rows\" v-if=\"listLimited.length\">\n      <tbody>\n        <Row v-for=\"entry of listLimited\" :entry=\"entry\" :key=\"`${entry.pathString}//${entry.size}`\"/>\n        <IntersectionRow/>\n      </tbody>\n    </table>\n    <div class=\"empty-message\" v-if=\"empty && !error\">\n      <span>The folder is empty.</span>\n    </div>\n    <div class=\"error-message\" v-if=\"error\">\n      <div>\n        <h2>Error</h2>\n        <table>\n          <tbody>\n            <tr>\n              <td>syscall</td>\n              <td><pre>{{error.syscall}}</pre></td>\n            </tr>\n            <tr>\n              <td>code</td>\n              <td><pre>{{error.code}}</pre></td>\n            </tr>\n            <tr>\n              <td>errno</td>\n              <td><pre>{{error.errno}}</pre></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport Row from \"./Row.vue\";\nimport IntersectionRow from \"./IntersectionRow.vue\";\nimport {goBack, empty, openedFolder} from \"../core/folders.js\";\nimport {listLimited} from \"../core/entries.js\";\nimport {computed, onMounted, ref, onBeforeMount} from \"vue\";\n\n/** @type {import(\"vue\").ComputedRef<ScanError>} */\nconst error = computed(() => {\n  if (openedFolder.value.hasErrors) {\n    return openedFolder.value.errors[0];\n  }\n  return false;\n});\n\nfunction onContextMenu(event) {\n  event.preventDefault();\n  goBack();\n}\n\nconst nameElemWidth = ref();\nonMounted(() => {\n  resizeNameElem();\n  window.addEventListener(\"resize\", resizeNameElem);\n});\nonBeforeMount(() => {\n  window.removeEventListener(\"resize\", resizeNameElem);\n});\nfunction resizeNameElem() {\n  const w = document.body.offsetWidth;\n  const tabsWidthOff = w <= 720 ? 113 : 0;\n  if (w < 1280) {\n    let px = 893 - (1280 - w) + tabsWidthOff;\n    px = px < 140 ? 140 : px;\n    nameElemWidth.value = `${px}px`;\n  } else {\n    nameElemWidth.value = \"893px\";\n  }\n}\n</script>\n\n\n<style lang=\"scss\" scoped>\n::v-deep(.row .name) {\n  width: v-bind(nameElemWidth);\n}\n\n.content {\n  width: 100%;\n  overflow: auto;\n  .rows {\n    width: 100%;\n    overflow: auto;\n  }\n  .empty-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--gray-2);\n  }\n  .error-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    color: var(--red-1);\n    div {\n      h2 {\n        margin: 0;\n        padding-bottom: 6px;\n        padding-left: 2px;\n      }\n      pre {\n        display: inline;\n      }\n      td {\n        padding-right: 3px;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"status\">\n    <span>Items count: {{count}}</span>\n    <span v-show=\"hoveredEntry\">. Hover item's size: {{size}}</span>\n  </div>\n</template>\n\n<script setup>\nimport {count, hoveredEntry} from \"../core/entries.js\";\nimport {computed} from \"vue\";\nimport {bytesToSizeWinLike} from \"../util.js\";\n\nconst size = computed(() => hoveredEntry.value?.size && bytesToSizeWinLike(hoveredEntry.value.size));\n</script>\n\n<style scoped>\n.status {\n  padding: 2px 2px 2px 6px;\n}\n</style>\n","<template>\n  <div class=\"switch\">\n    <button\n        class=\"order-by-name\"\n        title=\"Order by name\"\n        @click=\"onClick('name')\"\n        :class=\"{active: orderBy === 'name'}\"\n    >{{ orders.name  ? \"N\" : \"n\"}}</button>\n    <button\n        class=\"order-by-size\"\n        title=\"Order by size\"\n        @click=\"onClick('size')\"\n        :class=\"{active: orderBy === 'size'}\"\n    >{{ orders.size  ? \"S\" : \"s\"}}</button>\n    <button\n        class=\"order-by-time\"\n        :title=\"'Order by ' + selectedTime\"\n        @click=\"onClick('time')\"\n        @contextmenu.prevent=\"toggleTimeType\"\n        :class=\"{active: orderBy === 'time', [selectedTime]: true}\"\n    >{{ orders.time ? \"D\" : \"d\"}}</button>\n  </div>\n</template>\n\n<script setup>\nimport {orderBy, toggleOrder, orders, selectedTime} from \"../core/entries.js\";\n\n// todo optimise reversing.\n// todo cancel sorting (for large arrays) on new click while sorting\n\nfunction toggleTimeType() {\n  selectedTime.value = selectedTime.value === \"mtime\" ? \"btime\" : \"mtime\";\n}\n\n/** @param {\"name\"|\"size\"|\"time\"} value */\nfunction onClick(value) {\n  if (orderBy.value === value) {\n    toggleOrder();\n  }\n  orderBy.value = value;\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.switch {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\nbutton.active {\n  font-weight: bold;\n}\n.btime {\n  font-style: italic;\n}\n\nbutton {\n  width: 22px;\n  margin: 1px 3px;\n  padding: 2px 6px;\n  outline-width: 1px;\n  outline-color: var(--blue-1);\n  border: 1px solid var(--gray-2);\n  box-sizing: border-box;\n  background-color: var(--gray-1);\n  &:hover {\n    border-bottom: var(--blue-1) solid 1px;\n    background: var(--blue-2);\n  }\n  &:active {\n    background: var(--blue-3);\n  }\n}\n</style>\n","<template>\n  <div class=\"guide\">\n    <div class=\"text-wrapper\">\n      <h2>No scan selected</h2>\n      <div>Use your own directory scan file (created with\n        <a href=\"https://github.com/AlttiRi/keep-lister#how-to-use\" target=\"_blank\">the scanner</a>).\n      </div>\n      <div class=\"\">Or use the demo scans to take a look at the program's work <span class=\"gray\">(just click on the link)</span>:\n        <ul>\n          <li><a href=\"./?filepath=https://alttiri.github.io/json-flat-scans/windows-admin.json.gz\">Win 10 scan (as Admin)</a></li>\n          <li><a href=\"./?filepath=https://alttiri.github.io/json-flat-scans/ubuntu-admin.json.gz\">Ubuntu scan (as Root)</a></li>\n          <li><a href=\"./?filepath=https://alttiri.github.io/json-flat-scans/linux-master.json.gz\">Linux Source Code scan</a></li>\n        </ul>\n      </div>\n      <div class=\"gray\">Also it supports mega.nz folder links (https://mega.nz/folder/ABcd12#XXX).<br>\n        Just paste them in the search field.</div>\n      <div>For more info see the <a href=\"https://github.com/AlttiRi/keep-lister#keeplister\" target=\"_blank\">Readme</a>.</div>\n    </div>\n  </div>\n</template>\n\n<script setup>\n\n</script>\n\n<style lang=\"scss\" scoped>\n.guide {\n  animation: appear 2s;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 15px;\n  .text-wrapper {\n    min-width: 50%;\n  }\n  div {\n    margin-top: 15px;\n  }\n  .gray {\n    color: #666666;\n  }\n}\n\n.text-wrapper {\n  animation: fadein 1.5s linear 1 forwards;\n}\n@keyframes fadein {\n  0% { opacity: 0; }\n  50% { opacity: 0; }\n  100% { opacity: 1; }\n}\n</style>\n","<template>\n  <div class=\"inner-modal\">\n    <slot></slot>\n  </div>\n</template>\n\n<script setup>\n</script>\n\n<style lang=\"scss\" scoped>\n.inner-modal {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n","<template>\n  <div class=\"memory-consuming-component\"\n       v-if=\"isSupported\"\n       :style=\"{width: percent + '%'}\"\n       :title=\"'Heap size: ' + formattedSize + (showHint ? '\\n' + hint : '')\"\n       @mousedown=\"onMousedown\"\n  >\n    <div class=\"visible\"\n        :class=\"{over100}\"\n    ></div>\n    <div class=\"invisible\"></div>\n  </div>\n</template>\n\n<script setup>\nimport {bytesToSizeWinLike} from \"../util.js\";\nimport {computed, ref, onMounted, onBeforeUnmount} from \"vue\";\n\n\n/** @type {import(\"vue\").Ref<{jsHeapSizeLimit: number, totalJSHeapSize: number, usedJSHeapSize: number}>} */\nconst memory = ref(performance.memory);\nconst jsHeapSizeLimit = computed(() => memory.value.jsHeapSizeLimit);\nconst totalJSHeapSize = computed(() => memory.value.totalJSHeapSize);\nconst usedJSHeapSize  = computed(() => memory.value.usedJSHeapSize);\n\nconst intervalId = ref(null);\nconst over100 = ref(false);\nconst showHint = ref(false);\nconst hint = \"Use middle mouse button click to clear the console.\";\n\nconst percent = computed(() => {\n  const percent = totalJSHeapSize.value / (jsHeapSizeLimit.value / 100);\n  over100.value = percent > 100;\n  return over100.value ? 100 : percent;\n});\n\nconst formattedSize = computed(() => bytesToSizeWinLike(totalJSHeapSize.value));\nconst isSupported = computed(() => memory.value);\n\nonMounted(() => {\n  if (!isSupported.value) {\n    return;\n  }\n  intervalId.value = setInterval(() => {\n    memory.value = performance.memory;\n  }, 1000);\n});\nonBeforeUnmount(() => {\n  if (intervalId.value) {\n    clearInterval(intervalId.value);\n  }\n});\n\n/** @param {MouseEvent} event */\nfunction onMousedown(event) {\n  const LEFT_BUTTON = 0;\n  const MIDDLE_BUTTON = 1;\n  const RIGHT_BUTTON = 2;\n  if (event.button === LEFT_BUTTON) {\n    showHint.value = true;\n  }\n  if (event.button === MIDDLE_BUTTON) {\n    event.preventDefault();\n    showHint.value = false;\n    console.clear();\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.memory-consuming-component {\n  position: absolute;\n  left: 0;\n  top: 0;\n  > div {\n    width: 100%;\n  }\n  .visible {\n    background-color: #415aff;\n    height: 2px;\n    &.over100 {\n      background-color: #e30000;\n    }\n  }\n  &:active .visible {\n    background-color: #415aff80;\n  }\n  .invisible {\n    height: 3px;\n  }\n}\n</style>\n","<template>\n  <div class=\"scan-parsing-progress-component\"\n       v-if=\"scanParsing || show100\"\n       :style=\"{width: scanParsingProgress + '%'}\"\n  >\n    <div class=\"visible\"></div>\n  </div>\n</template>\n\n<script setup>\nimport {ref, watchEffect} from \"vue\";\nimport {sleep} from \"../util.js\";\nimport {scanParsing, scanParsingProgress} from \"../core/state\";\n\nconst show100 = ref(false);\nwatchEffect(async () => {\n  if (scanParsingProgress.value === 100) {\n    show100.value = true;\n    await sleep(16);\n    show100.value = false;\n  }\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.scan-parsing-progress-component {\n  pointer-events: none;\n  position: absolute;\n  left: 0;\n  top: 0;\n  > div {\n    width: 100%;\n  }\n  .visible {\n    background-color: var(--blue-1);\n    height: 4px;\n  }\n}\n</style>\n","<template>\n  <div class=\"main\">\n    <MemoryConsuming/>\n    <ScanProgressBar/>\n    <Switch     style=\"grid-area: switch;\"/>\n    <AddressBar style=\"grid-area: address;\"/>\n    <Search     style=\"grid-area: search;\"/>\n    <Tabs       style=\"grid-area: tabs;\"/>\n    <Guide      style=\"grid-area: content;\" v-if=\"showGuide\"/>\n    <InnerModal style=\"grid-area: content;\" v-else-if=\"scanParsing && searchAwaiting\">\n      [Search]: Scan parsing awaiting ({{currentScansNum}} of {{scansCount}})\n    </InnerModal>\n    <Content    style=\"grid-area: content;\" v-else/>\n    <Status     style=\"grid-area: status;\"/>\n    <Debug      style=\"grid-area: debug;\"/>\n    <a class=\"readme\" title=\"Open Readme\" href=\"https://github.com/AlttiRi/keep-lister#keeplister\" target=\"_blank\"><i>i</i></a>\n  </div>\n</template>\n\n<script setup>\nimport AddressBar from \"./AddressBar.vue\";\nimport Search from \"./Search.vue\";\nimport Tabs from \"./Tabs.vue\";\nimport Content from \"./Content.vue\";\nimport Status from \"./Status.vue\";\nimport Switch from \"./Switch.vue\";\nimport Debug from \"./Debug.vue\";\nimport Guide from \"./Guide.vue\";\nimport InnerModal from \"./InnerModal.vue\";\nimport MemoryConsuming from \"./MemoryConsuming.vue\";\nimport ScanProgressBar from \"./ScanProgressBar.vue\";\nimport {computed, onMounted} from \"vue\";\nimport {rootMeta, setScan} from \"../core/folders.js\";\nimport {search} from \"../core/search.js\";\nimport {bytesToSize, bytesToSizeWinLike} from \"../util.js\";\nimport {orderBy, toggleOrder} from \"../core/entries.js\";\nimport {handleMegaUrl} from \"../core/mega-nz.js\";\nimport {scanParsing, searchAwaiting, scansCount, currentScansNum} from \"../core/state\";\n\nglobalThis.bytesToSize = bytesToSize;\nglobalThis.bytesToSizeWinLike = bytesToSizeWinLike;\n\n\n// some kind of hack, but okay // don't show if a file selected, or remote scan is loading\nconst showGuide = computed(() => rootMeta.value === undefined && !new URL(location.href).searchParams.get(\"filepath\") || rootMeta.value === null);\n\n\n// Already opened directory, no need to open with input\nonMounted(async () => {\n  const url = new URL(location.href);\n  const filepath = url.searchParams.get(\"filepath\");\n  const sort = url.searchParams.get(\"sort\") || url.searchParams.get(\"order\");\n  if ([\"name\", \"size\", \"time\"].includes(sort)) {\n    orderBy.value = sort;\n    if ([\"true\", \"1\"].includes(url.searchParams.get(\"desc\"))) {\n      toggleOrder();\n    }\n  }\n  if (filepath) {\n    /** @type {Response} */\n    const response = await fetch(filepath);\n    await setScan(response);\n  }\n  const hash = url.hash.slice(1);\n  if (hash.startsWith(\"https://mega.nz/\")) {\n    await handleMegaUrl(hash);\n  }\n  const _search = url.searchParams.get(\"search\");\n  if (_search) {\n    search.value = _search;\n  }\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.main {\n  grid-template-areas: \"switch address search \"\n                       \"tabs   content content\"\n                       \"status status  status \"\n                       \"debug  debug   debug  \";\n\n  display: grid;\n  grid-template-columns: 7em 2fr 1fr;\n  grid-template-rows:    2em 1fr;\n\n  @media screen and (max-width: 720px) {\n    grid-template-areas: \"switch  search  search \"\n                         \"address address address\"\n                         \"content content content\"\n                         \"status  status  status \"\n                         \"debug   debug   debug  \"\n                         \"tabs    tabs    tabs   \";\n    grid-template-rows:  2em 2em 1fr;\n  }\n\n  height: 720px;\n  max-height: 100vh;\n  width: 1280px;\n  max-width: 100%;\n  box-sizing: border-box;\n\n  grid-gap: 1px;\n  border: 1px solid var(--gray-2);\n  background-color: var(--gray-2);\n  * {\n    background-color: white;\n  }\n}\n.readme {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  padding: 2px 8px;\n  margin: 1px;\n  color: darkgray;\n  text-decoration: none;\n}\n</style>\n","import {createApp} from \"vue\";\nimport App from \"./App.vue\";\n\ncreateApp(App).mount(\"#app\");\n"],"file":"index.js"}