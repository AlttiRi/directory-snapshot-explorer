{"version":3,"file":"index.js","sources":["node-modules:///vite/modulepreload-polyfill","source-maps:///util.js","source-maps:///core/entries.js","source-maps:///core/debug.js","source-maps:///core/entry.js","source-maps:///core/state.js","node-modules:///vite/preload-helper","source-maps:///core/mega-nz.js","source-maps:///core/search.js","source-maps:///core/scan-parser.js","source-maps:///core/folders.js","source-maps:///components/AddressBar_Base.vue","source-maps:///components/AddressBar_Folder.vue","source-maps:///components/AddressBar.vue","source-maps:///components/Search.vue","source-maps:///components/file-input/FileEntry.js","source-maps:///components/file-input/file-input-state.js","source-maps:///components/file-input/FileInputDefaultHoverText.vue","source-maps:///components/file-input/FileInputDefaultText.vue","source-maps:///components/file-input/FileInput.vue","source-maps:///components/FileInputWrapper.vue","source-maps:///components/Row.vue","source-maps:///components/IntersectionRow.vue","source-maps:///components/Content.vue","source-maps:///components/Status.vue","source-maps:///components/Switch.vue","source-maps:///components/MemoryConsuming.vue","source-maps:///components/ScanProgressBar.vue","source-maps:///components/Main.vue","source-maps:///main.js"],"sourcesContent":["const p = function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n};__VITE_IS_MODERN__&&p();","export const setImmediate = globalThis.setImmediate || /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\nexport function sleep(ms) {\n    if (ms === undefined) {\n        return new Promise(resolve => setImmediate(resolve));\n    }\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport const shuffle = () => Math.random() >= 0.5 ? -1 : 1;\n\nconst videoExtensions = [\"mp4\", \"webm\", \"mkv\", \"avi\", \"mov\", \"m4v\", \"m4v\", \"mpg\", \"mpeg\", \"wmv\", \"flv\"];\nexport function isVideo(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return videoExtensions.includes(ext.toLowerCase());\n}\nconst imageExtensions = [\"png\", \"jpg\", \"jpeg\", \"jfif\", \"gif\", \"tiff\", \"webp\"];\nexport function isImage(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return imageExtensions.includes(ext.toLowerCase());\n}\nconst audioExtensions = [\"mp3\", \"flac\", \"wav\", \"wma\", \"aac\"];\nexport function isAudio(filename) {\n    const {ext} = filename.match(/(?<ext>[^.]+)$/).groups;\n    return audioExtensions.includes(ext.toLowerCase());\n}\n\nexport function debounce(runnable, ms = 50) {\n    let timerId;\n    return function() {\n        // console.log({timerId});\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            runnable.apply(this, arguments);\n            timerId = null;\n        }, ms);\n    }\n}\n\nexport function isString(input) {\n    return typeof input === \"string\" || input instanceof String;\n}\n\nexport function firefoxDateFix(dateValue) {\n    return isString(dateValue) ? dateValue.replace(/(?<y>\\d{4})\\.(?<m>\\d{2})\\.(?<d>\\d{2})/, \"$<y>-$<m>-$<d>\") : dateValue;\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10\"\nexport function dateToDayDateString(dateValue, utc = true) {\n    dateValue = firefoxDateFix(dateValue);\n    const _date = new Date(dateValue);\n    if (_date.toString() === \"Invalid Date\") {\n        console.warn(\"Invalid Date value: \", dateValue);\n    }\n    function pad2(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n    const _utc = utc ? \"UTC\" : \"\";\n    const year  = _date[`get${_utc}FullYear`]();\n    const month = _date[`get${_utc}Month`]() + 1;\n    const date  = _date[`get${_utc}Date`]();\n\n    return year + \".\" + pad2(month) + \".\" + pad2(date);\n}\n\n// \"Sun, 10 Jan 2021 22:22:22 GMT\" -> \"2021.01.10 22:22:22Z\"\nexport function dateToDayDateTimeString(dateValue, utc = true) {\n    dateValue = firefoxDateFix(dateValue);\n    const _date = new Date(dateValue);\n    function pad2(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n    const _utc = utc ? \"UTC\" : \"\";\n    const hours    = _date[`get${_utc}Hours`]();\n    const minutes  = _date[`get${_utc}Minutes`]();\n    const seconds  = _date[`get${_utc}Seconds`]();\n\n    const time = pad2(hours)+ \":\" + pad2(minutes) + \":\" + pad2(seconds);\n    return dateToDayDateString(_date, utc) + \" \" + time + (utc ? \"Z\" : \"\");\n}\n\n\nexport function structuredClone(object) {\n    return new Promise(resolve => {\n        const {port1, port2} = new MessageChannel();\n        port1.onmessage = function(message) {\n            resolve(message.data);\n        };\n        port2.postMessage(object);\n    });\n}\n\nexport function appendScript(src, integrity) {\n    return new Promise((resolve, reject) => {\n        const script = document.createElement(\"script\");\n        script.onload = resolve;\n        script.onerror = event => reject({message: \"Failed to load script\", src, integrity, event});\n        script.src = src;\n        script.async = true;\n        if (integrity) {\n            script.integrity = integrity;\n            script.crossOrigin = \"anonymous\";\n        }\n        document.body.append(script);\n    });\n}\n\n/**\n * `chunkSize` is 65536, ReadableStream uses the same size.\n * There is no speed difference between using of different the chunk's sizes.\n * @param {ArrayBuffer|Uint8Array} arrayBuffer\n * @param {Number} [chunkSize=65536]\n * @return {Generator<Uint8Array>}\n */\nexport function *iterateArrayBuffer(arrayBuffer, chunkSize = 65536) {\n    const buffer = new Uint8Array(arrayBuffer);\n    let index = 0;\n    while (true) {\n        const chunk = buffer.subarray(index, index + chunkSize);\n        if (!chunk.length) {\n            break;\n        }\n        yield chunk;\n        index += chunkSize;\n    }\n}\n\n/**\n * @param {Response|ReadableStream|Blob} dataSource\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateAsyncDataSource(dataSource) {\n    if (dataSource instanceof Response) {\n        dataSource = dataSource.body;\n    }\n    if (dataSource instanceof ReadableStream) {\n        yield *iterateReadableStream(dataSource);\n    } else if (dataSource instanceof Blob) {\n        for (const part of iterateBlob(dataSource)) {\n            yield await part;\n        }\n    }\n}\n\n\n/**\n * @param {ReadableStream} stream\n * @return {AsyncGenerator<Uint8Array>}\n */\nexport async function *iterateReadableStream(stream) {\n    const reader = stream.getReader();\n    while (true) {\n        const {done, /** @type {Uint8Array} */ value} = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\n\n/**\n * Iterates Blob (or File).\n * Note: `chunkSize` affects the execution speed\n * @param {Blob} blob\n * @param {Number} [chunkSize=2097152]\n * @return {Generator<Promise<Uint8Array>>|AsyncGenerator<Uint8Array>}\n */\nexport function *iterateBlob(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        return new Uint8Array(await blob.arrayBuffer());\n    }\n}\n\n/**\n * Format bytes to human readable format.\n * Trims the tailing zeros.\n *\n * {@link https://stackoverflow.com/a/18650828/11468937}\n * @param {Number} bytes\n * @param {Number} [decimals=2]\n * @returns {String}\n */\nexport function bytesToSize(bytes, decimals = 2) {\n    if (bytes === 0) { return \"0 B\"; }\n    const k = 1024;\n    decimals = decimals < 0 ? 0 : decimals;\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n}\n\n/**\n * Formats bytes mostly like Windows does,\n * but in some rare cases the result is different.\n * Check the file with tests.\n * @see win-like-file-sizes.test.js\n * @param {Number} bytes\n * @return {string}\n */\nexport function bytesToSizeWinLike(bytes) {\n    if (bytes < 1024) { return bytes + \" B\"; }\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n    let i = Math.floor(Math.log(bytes) / Math.log(1024));\n    let result = bytes / Math.pow(1024, i);\n    if (result >= 1000) {\n        i++;\n        result /= 1024;\n    }\n    return toTruncPrecision3(result) + \" \" + sizes[i];\n}\n\n/**\n * @see trunc-with-precision-3.test.js\n * @param {Number} number\n * @return {string}\n */\nexport function toTruncPrecision3(number) {\n    let result;\n    if (number < 10) {\n        result = Math.trunc(number * 100) / 100;\n    } else if (number < 100) {\n        result = Math.trunc(number * 10) / 10;\n    } else if (number < 1000) {\n        result = Math.trunc(number);\n    }\n    if (number < 0.1) {\n        return result.toPrecision(1);\n    } else if (number < 1) {\n        return result.toPrecision(2);\n    }\n    return result.toPrecision(3);\n}\n\n/**\n * @param {Uint8Array[]} arrays\n * @return {Uint8Array}\n */\nexport function concat(arrays) {\n    const totalLength = arrays.reduce((acc, value) => acc + value.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const array of arrays) {\n        result.set(array, offset);\n        offset += array.length;\n    }\n    return result;\n}\n\nexport function red(text) {\n    return [`%c${text}`,  \"color: #f44336; font-weight: bold;\"];\n}\nexport function orange(text) {\n    return [`%c${text}`,  \"color: #ff9800; font-weight: bold;\"];\n}\nexport function green(text) {\n    return [`%c${text}`,  \"color: #4caf50; font-weight: bold;\"];\n}\nexport function cyan(text) {\n    return [`%c${text}`,  \"color: #00bcd4; font-weight: bold;\"];\n}\nexport function blue(text) {\n    return [`%c${text}`,  \"color: #2196f3; font-weight: bold;\"];\n}\n","import {computed, ref} from \"vue\";\nimport {search, searchResult} from \"./search.js\";\nimport {openedFolder} from \"./folders.js\";\n\n\nexport const sort = ref(true);\n\n/** @type {import(\"vue\").Ref<(\"mtime\"|\"btime\")>} */\nexport const selectedTime = ref(\"mtime\");\n/** @type {import(\"vue\").Ref<(\"name\"|\"size\"|\"time\")>} */\nexport const orderBy = ref(\"name\");\nexport const orders = ref({\n    name: false,\n    size: false,\n    time: false,\n});\nexport const reverseOrder = computed(() => orders.value[orderBy.value]);\nexport function toggleOrder() {\n    orders.value[orderBy.value] = !orders.value[orderBy.value];\n}\n\nconst {compare} = new Intl.Collator(undefined, {\n    numeric: true,\n    sensitivity: \"accent\",\n});\n\n// // todo create the list variable (search result -> the list), (opened dir entries -> the list)\n// export const reactiveComparator = computed(() => {\n//     const k = reverseOrder.value ? -1 : 1;\n//     if (sort.value) {\n//         if (orderBy.value === \"name\") {\n//             return (pre, cur) => compare(pre.name, cur.name) * k;\n//         } else if (orderBy.value === \"size\") {\n//             return (pre, cur) => (pre.size - cur.size) * k;\n//         } else if (orderBy.value === \"mtime\") {\n//             return (pre, cur) => (pre.mtime - cur.mtime) * k;\n//         }\n//     }\n//     return (pre, cur) => 0;\n// });\n\nexport function comparator(pre, cur) {\n    const k = reverseOrder.value ? -1 : 1;\n    if (sort.value) {\n        if (orderBy.value === \"name\") {\n            return compare(pre.name, cur.name) * k;\n        } else if (orderBy.value === \"size\") {\n            return (pre.size - cur.size) * k;\n        } else if (orderBy.value === \"time\") {\n            const timeName = selectedTime.value;\n            return (pre[timeName] - cur[timeName]) * k;\n        }\n    }\n    return 0;\n}\n\n// grouped by type\nexport const entries = computed(() => {\n    return [\n        ...openedFolder.value.folders.sort(comparator),\n        ...openedFolder.value.files.sort(comparator),\n        ...openedFolder.value.symlinks.sort(comparator),\n        ...openedFolder.value.fifos.sort(comparator),\n        ...openedFolder.value.charDevs.sort(comparator),\n        ...openedFolder.value.blockDevs.sort(comparator),\n        ...openedFolder.value.sockets.sort(comparator),\n    ];\n});\n\n\n/** @type {import(\"vue\").Ref<Number>} */\nexport const limit = ref(50);\n\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const list = computed(() => {\n    if (search.value.length) {\n        return searchResult.value;\n    }\n    return entries.value;\n});\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const listLimited = computed(() => {\n    return list.value.slice(0, limit.value);\n});\n/** @type {import(\"vue\").ComputedRef<Number>} */\nexport const count = computed(() => {\n    if (searchResult.value.length > limit.value) {\n        return searchResult.value.length;\n    }\n    return list.value.length;\n});\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nexport const hoveredEntry = ref(null);\n","import {ref, toRaw, isProxy} from \"vue\";\nimport {bytesToSizeWinLike, dateToDayDateTimeString} from \"../util.js\";\n\nexport const debugMessage = ref(\"\");\nexport function addMessage(message) {\n    debugMessage.value = message;\n}\nexport function appendMessage(message) {\n    debugMessage.value += message;\n}\n\n/**\n * @param {SimpleEntry} entry\n */\nexport function debugMessageFromEntry(entry) {\n    console.log(isProxy(entry) ? \"Proxy:\" : \"Raw:\", toRaw(entry));\n    if (entry.hasErrors) {\n        debugMessage.value = \"\";\n    } else {\n        const name = `\"` + entry.name.slice(0, 20) + (entry.name.length < 20 ? \"\" : \"...\") + `\"`;\n\n        let messages = [];\n        if (entry.mtime !== undefined) {\n            messages.push(\"mtime \" + `\"${dateToDayDateTimeString(entry.mtime, false)}\"`);\n        }\n        if (entry.btime !== undefined) {\n            messages.push(\"btime \" + `\"${dateToDayDateTimeString(entry.btime, false)}\"`);\n        }\n        messages = [...messages, name, `${entry.size} (${bytesToSizeWinLike(entry.size)})`];\n        debugMessage.value = messages.join(\" — \");\n    }\n}\n","/** @type {ScanEntryType[]} */\nimport {sleep} from \"../util.js\";\n\nexport const entryTypes = [\"folder\", \"file\", \"symlink\", \"fifo\", \"charDev\", \"blockDev\", \"socket\"];\n\nexport class SimpleEntry {\n    // [Symbol.toStringTag] = \"SimpleEntry\"; // Disables reactivity, BTW.\n    /**\n     * @param {SerializableScanEntry} entry\n     * @param {SimpleEntry|null} parent\n     * @param {Map<Number, SimpleScanError>} [errorsIDMap]\n     */\n    constructor(entry, parent, errorsIDMap) {\n        /** @type {String} */\n        this.name = entry.name;\n        /** @type {SimpleEntry|null} */\n        this.parent = parent;\n        /** @type {ScanEntryType} */\n        this.type = entry.type;\n\n        if (entry.size) {\n            /** @type {Number|undefined} */\n            this._size = entry.size;\n        }\n        if (entry.mtime) {\n            /** @type {Number|undefined} */\n            this._mtime = entry.mtime;\n        }\n        if (entry.btime) {\n            /** @type {Number|undefined} */\n            this.btime = entry.btime;\n        }\n\n        if (entry.errors) {\n            /** @type {SimpleScanError[]}|undefined} */\n            this.errors = entry.errors.map(id => errorsIDMap.get(id));\n        }\n\n        if (entry.pathTo) {\n            /** @type {String|undefined} */\n            this.pathTo = entry.pathTo;\n        }\n        if (entry.content) {\n            /** @type {String|undefined} */\n            this.content = entry.content;\n        }\n\n        parent?.addChild(this);\n    }\n    /** @param {SimpleEntry} entry */\n    addChild(entry) {\n        if (!this.children) {\n            /**\n             * `undefined` if there is no child\n             * @type {SimpleEntry[]|undefined}\n             */\n            this.children = [];\n        }\n        this.children.push(entry);\n        this.increaseContentSize(entry.size);\n    }\n    /** @param {SimpleEntry[]} entries\n     *  @param {Number} total */\n    addHardlinks(entries, total) {\n        /** @type {SimpleEntry[]|undefined} */\n        this.hardlinks = entries;\n        /** @type {Number|undefined} */\n        this.hardlinksTotal = total;\n    }\n\n    increaseContentSize(size) {\n        if (!size) {\n            return;\n        }\n        if (!this._contentSize) {\n            this._contentSize = 0;\n        }\n        this._contentSize += size;\n        if (this.parent && size) {\n            this.parent.increaseContentSize(size);\n        }\n    }\n\n    /** @return {Number|undefined} */\n    get mtime() {\n        if (this._mtime !== undefined) {\n            return this._mtime;\n        }\n        if (this.type === \"folder\" && this.children) { // Note: it's recursive // todo: an optional deep limit\n            let time = Number.MIN_SAFE_INTEGER;\n            for (const child of this.children) {\n                if (child.mtime > time) { // `child.mtime !== undefined` is not necessary\n                    time = child.mtime;\n                }\n            }\n            if (time !== Number.MIN_SAFE_INTEGER) {\n                return time;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Note: the folder size is computed on the creation step.\n     * @return {Number}\n     */\n    get size() {\n        if (this.type === \"folder\") {\n            return this._contentSize || 0;\n        }\n        return this._size || 0;\n    }\n\n    /** @return {SimpleEntry[]} */\n    get folders() {\n        return this.children?.filter(e => e.type === \"folder\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get files() {\n        return this.children?.filter(e => e.type === \"file\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get symlinks() {\n        return this.children?.filter(e => e.type === \"symlink\") || [];\n    }\n\n    /** @return {SimpleEntry[]} */\n    get fifos() {\n        return this.children?.filter(e => e.type === \"fifo\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get charDevs() {\n        return this.children?.filter(e => e.type === \"charDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get blockDevs() {\n        return this.children?.filter(e => e.type === \"blockDev\") || [];\n    }\n    /** @return {SimpleEntry[]} */\n    get sockets() {\n        return this.children?.filter(e => e.type === \"socket\") || [];\n    }\n\n    /** @return {Boolean} */\n    get isEmpty() {\n        return !Boolean(this.children?.length);\n    }\n    /** @return {Boolean} */\n    get hasErrors() {\n        return Boolean(this.errors?.length);\n    }\n    /** @return {SimpleEntry} */\n    get root() {\n        if (!this.parent) {\n            return this;\n        }\n        return this.parent.root;\n    }\n    /** @return {SimpleEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n\n    get contentTypesStats() {\n        return this.getContentTypesStats();\n    }\n    _getContentTypesStats(deep = true, result = {}, target = this) {\n        if (target.type === \"folder\" && target.children) {\n            for (const child of target.children) {\n                if (!result[child.type]) {\n                    result[child.type] = 1;\n                } else {\n                    result[child.type]++;\n                }\n                if (child.type === \"folder\" && deep) {\n                    this._getContentTypesStats(deep, result, child);\n                }\n            }\n            return result;\n        }\n    }\n    getContentTypesStats(deep = true) {\n        console.time(\"getContentTypesStats\");\n        const result = this._getContentTypesStats(deep);\n        console.timeEnd(\"getContentTypesStats\");\n        return result;\n    }\n\n    /** @return {Generator<SimpleEntry>} */\n    *[Symbol.iterator]() {\n        yield this;\n        if (this.children) {\n            for (const child of this.children) {\n                yield * child;\n            }\n        }\n    }\n\n    /** @return {SimpleEntry[]} */\n    flat() {\n        return [...this];\n    }\n\n    /**\n     * @param {SimpleEntry[]} entries\n     * @return {SimpleEntry[]}\n     */\n    static flat(entries) {\n        return entries.map(e => [...e]).flat();\n    }\n\n    get pathString() {\n        return this.getPathString();\n    }\n\n    /**\n     * @param {ScanMeta} [meta]\n     * @return {string}\n     */\n    getPathString(meta) {\n        const names = this.path.map(e => e.name);\n        let pathStr;\n        if (meta) {\n            pathStr = [...meta.path, ...names].join(meta.separator || \"/\");\n        } else {\n            pathStr = names.join(\"/\");\n        }\n        if (pathStr.startsWith(\"//\")) {\n            return pathStr.slice(1);\n        }\n        return pathStr;\n    }\n}\n\n/**\n * Like `ScanError`, but without `path`.\n * @typedef {Object} SimpleScanError\n * @property {String} code\n * @property {String} syscall\n * @property {Number} errno\n **/\n\nexport class EntryStreamParser {\n    constructor() {\n        this.rootId = 0;\n        /** @type {Map<Number, SimpleEntry>} */\n        this.map = new Map();\n        /** @type {Map<String, SimpleEntry[]>} */\n        this.hidMap = new Map();\n    }\n\n    /** @param {ScanMeta} meta */\n    setMeta(meta) {\n        /** @type {ScanMeta} */\n        this.meta = meta;\n        /** @type {Object<String, Number>} */\n        const errorsMap = meta.errorsMap;\n        if (!errorsMap) {\n            return;\n        }\n        /** @type {Map<Number, SimpleScanError>|undefined} */\n        this.errorsIDMap = new Map(Object.entries(errorsMap)\n            .map(([k, v]) => {\n                const [code, syscall, errno] = k.split(\":\");\n                return [v, {code, syscall, errno: Number(errno)}];\n            }));\n    }\n\n    /** @param {SerializableScanEntry[]} sEntriesPart\n     * @return {{root: SimpleEntry, rootUpdated: boolean, processed: number}}\n     */\n    parse(sEntriesPart) {\n        let rootUpdated = false;\n        for (const entry of sEntriesPart) {\n            /** @type {SimpleEntry|null}*/\n            const parent = this.map.get(entry.pid) ?? null;\n            const simpleEntry = new SimpleEntry(entry, parent, this.errorsIDMap);\n            if (entry.type === \"folder\") {\n                this.map.set(entry.id, simpleEntry);\n            }\n            if (entry.hid) {\n                const array = this.hidMap.get(entry.hid) || [];\n                this.hidMap.set(entry.hid, [...array, simpleEntry]);\n            }\n            if (entry.pid === this.rootId) {\n                rootUpdated = true;\n            }\n        }\n        return {\n            root: this.map.get(this.rootId),\n            rootUpdated,\n            processed: sEntriesPart.length,\n        }\n    }\n\n    processHIDMapAsync() {\n        if (!this.hidMap.size) {\n            return;\n        }\n        console.log(\"[hidMap]:\", this.hidMap);\n        console.time(\"hidMap\");\n        processHIDMapAsync(this.hidMap)\n            .then(() => console.timeEnd(\"hidMap\"));\n    }\n}\n\nasync function processHIDMapAsync(hidMap) {\n    let i = 0;\n    let time = 0; // `0` to do `sleep` on the first iteration\n\n    for (const [hid, simpleEntries] of hidMap.entries()) {\n        if (!(i++ % 1000)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n            }\n        }\n\n        /** @type {Number}*/\n        const totalLinks = Number(hid.split(\":\")[1]);\n        simpleEntries.forEach(e => {\n            e.addHardlinks(simpleEntries, totalLinks);\n        });\n    }\n}\n\n/** @type {SimpleEntry} */\nexport const folderDummy = new SimpleEntry({\n    type: \"folder\",\n    name: \"\",\n    pid: null,\n}, null);\n","import {ref} from \"vue\";\n\nexport const scanParsing         = ref(false);\nexport const scanParsingProgress = ref(0);\nexport const searching           = ref(false);\nexport const searchAwaiting      = ref(false);\n","const scriptRel = 'modulepreload';const seen = {};const base = './';export const __vitePreload = function preload(baseModule, deps) {\n    // @ts-ignore\n    if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {\n        return baseModule();\n    }\n    return Promise.all(deps.map((dep) => {\n        // @ts-ignore\n        dep = `${base}${dep}`;\n        // @ts-ignore\n        if (dep in seen)\n            return;\n        // @ts-ignore\n        seen[dep] = true;\n        const isCss = dep.endsWith('.css');\n        const cssSelector = isCss ? '[rel=\"stylesheet\"]' : '';\n        // @ts-ignore check if the file is already preloaded by SSR markup\n        if (document.querySelector(`link[href=\"${dep}\"]${cssSelector}`)) {\n            return;\n        }\n        // @ts-ignore\n        const link = document.createElement('link');\n        // @ts-ignore\n        link.rel = isCss ? 'stylesheet' : scriptRel;\n        if (!isCss) {\n            link.as = 'script';\n            link.crossOrigin = '';\n        }\n        link.href = dep;\n        // @ts-ignore\n        document.head.appendChild(link);\n        if (isCss) {\n            return new Promise((res, rej) => {\n                link.addEventListener('load', res);\n                link.addEventListener('error', rej);\n            });\n        }\n    })).then(() => baseModule());\n}","import {SimpleEntry} from \"./entry.js\";\nimport {meta, openFolder, root} from \"./folders.js\";\nimport {addMessage} from \"./debug.js\";\nimport {dateToDayDateTimeString} from \"../util.js\";\n\n// Some special\nexport async function handleMegaUrl(url) {\n    globalThis.Mega = await import(\"https://alttiri.github.io/meganz-api/meganz-api.standalone.es.js\");\n    // globalThis.Mega.MegaApi.encryptedName = true;\n\n    let node;\n    try {\n        node = await globalThis.Mega.node(url);\n    } catch (e) {\n        addMessage(e);\n        return;\n    }\n    console.log(node);\n\n    let result = parseMegaNode(node);\n    result._url = url;\n    console.log(result);\n\n    const special = {\n        url,\n        id: result._id,\n        ownerId: result._ownerId,\n        btime: result.btime && dateToDayDateTimeString(result.btime),\n        mtime: result.mtime && dateToDayDateTimeString(result.mtime),\n    };\n\n    if (result.type !== \"folder\") { // if it's a share of 1 file\n        const emptyRootFolder = new SimpleEntry({\n            type: \"folder\",\n            name: \"\",\n            pid: null\n        }, null);\n        emptyRootFolder.addChild(result);\n        result = emptyRootFolder;\n    }\n\n    root.value = result;\n    meta.value = {special};\n    openFolder(root.value);\n}\n\n/** @return {SerializableScanEntry} */\nfunction nodeToSEntry(node) {\n    return {\n        name: node.name === null ? \"[encrypted]\" : node.name,\n        size: node.size,\n        btime: node.creationDate * 1000,\n        mtime: node.modificationDate * 1000,\n        id: node.id,\n        type: (node.type === \"rootFolder\" || node.type === \"folder\") ? \"folder\" : \"file\",\n        pid: node.parentId,\n    };\n}\n\nfunction toSEntry(megaNode, parent) {\n    /** @type {SerializableScanEntry}   */\n    const ssEntry = nodeToSEntry(megaNode);\n    const sEntry = new SimpleEntry(ssEntry, parent);\n    sEntry._id = megaNode.id;\n    sEntry._ownerId = megaNode.ownerId;\n    return sEntry;\n}\n\nfunction parseMegaNode(megaNode, parent = null) {\n    const sEntry = toSEntry(megaNode, parent);\n    if (sEntry.type === \"folder\") {\n        for (const mNode of [...megaNode.folders, ...megaNode.files]) {\n            parseMegaNode(mNode, sEntry);\n        }\n    }\n    return sEntry;\n}\n","import {isReactive, ref, shallowRef, toRaw, watch, watchEffect, triggerRef} from \"vue\";\nimport {blue, bytesToSizeWinLike, debounce, sleep} from \"../util.js\";\nimport {openedFolder} from \"./folders.js\";\nimport {comparator, limit, orderBy, reverseOrder, selectedTime} from \"./entries.js\";\nimport * as debug from \"./debug.js\";\nimport {entryTypes} from \"./entry.js\";\nimport {scanParsing, searchAwaiting, searching} from \"./state.js\";\nimport {handleMegaUrl} from \"./mega-nz.js\";\n\n/** @type {import(\"vue\").Ref<string>} */\nexport const search = ref(\"\"); // [v-model]\nexport function clearSearch() {\n    search.value = \"\";\n}\n\n/** @type {import(\"vue\").ShallowRef<SimpleEntry[]>} */\nexport const searchResult = shallowRef([]);\nfunction clearSearchResult() {\n    setSearchResult([]);\n}\n/** * @param {SimpleEntry[]} result */\nfunction setSearchResult(result) {\n    /** @type {SimpleEntry[]} */\n    const rawResult = toRaw(result);\n    searchResult.value = rawResult;\n    limit.value = 50;\n\n    addSearchResultToGlobalThis(rawResult);\n}\n\nwatch([orderBy, reverseOrder, selectedTime], () => {\n    sortSearch();\n});\n\nexport function sortSearch() {\n    //todo sort by parts\n    const time = Date.now();\n    searchResult.value.sort(comparator);\n    const timeTotal = Date.now() - time;\n    console.log(\"[search][sort][time]\", timeTotal, \"ms\");\n    triggerRef(searchResult);\n    return timeTotal;\n}\n\n/** @param {SimpleEntry[]} rawResult */\nfunction addSearchResultToGlobalThis(rawResult) {\n    /** @type {SimpleEntry[]} */\n    globalThis.search = rawResult;\n    console.log(\"globalThis.search:\", rawResult);\n    Object.defineProperty(globalThis.search, \"download\", {\n        get() {\n            console.log(\"download\"); // todo\n        }\n    });\n    Object.defineProperty(globalThis.search, \"names\", {\n        get() {\n            return globalThis.search.map(entry => entry.name);\n        }\n    });\n    Object.defineProperty(globalThis.search, \"namelist\", {\n        get() {\n            return globalThis.search.map(entry => entry.name).join(\"\\n\");\n        }\n    });\n}\n\nlet resolve = () => {};\nlet scanParsingCompleted = Promise.resolve(true);\nwatchEffect(() => {\n    if (scanParsing.value) {\n        resolve(false);\n        scanParsingCompleted = new Promise(r => resolve = r);\n    } else {\n        resolve(true);\n    }\n});\n\nfunction simplify(input) {\n    // todo .normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\")\n    //  (It required to use a cache since it's a slow operation, and\n    //   only for the normalized values (not just lower cased) in order to save the memory consuming.)\n    // \"đ Crème Bruląśćńżółźćęéйeё\".normalize(\"NFD\").replace(/\\p{Diacritic}/gu, \"\")\n    return input\n        .toLowerCase();\n}\n\nwindow.addEventListener(\"storage\", event => {\n    if (event.key !== \"search-sync\") {\n        return;\n    }\n    document.querySelector(\"input\").value = event.newValue;\n    document.querySelector(\"input\").dispatchEvent(new Event(\"input\"));\n});\n\n//todo check linked list perf for large search\nconst performSearchDebounced = debounce(performSearch, 300);\nasync function performSearch() {\n    const searchSync = new URL(location.href).searchParams.get(\"searchSync\");\n    if (searchSync) {\n        localStorage.setItem(\"search-sync\", search.value);\n        document.title = `Search...`;\n    }\n\n    // Await while the scan parsing is completed, return `false` if there is a new `performSearch` call while parsing.\n    if (false === await scanParsingCompleted) {\n        return;\n    }\n\n    const folder = openedFolder.value;\n    const request = search.value;\n\n    // Do unProxy. Up to x40 in comparison with default reactive ref.\n    const folderRaw = isReactive(folder) ? toRaw(folder) : folder;\n\n    const time1 = performance.now();\n    searching.value = true;\n    const {result, search: searchText} = await searcher(folderRaw, request);\n    searching.value = false;\n    searchAwaiting.value = false;\n    if (!result) {\n        return;\n    }\n    const searchTime = performance.now() - time1;\n    debug.addMessage(`Search time: ${searchTime.toFixed(2)} ms; `);\n    await sleep();\n\n    setSearchResult(result);\n    const sortTime = sortSearch();\n    debug.appendMessage(`Sort time: ${sortTime.toFixed(2)} ms; `);\n    await sleep();\n\n    console.time(\"search result size computing\");\n    const resultSet = new Set(result);\n    const allSize = result.reduce((acc, val) => computeEntrySize(val, resultSet) + acc, 0);\n    const filesSize = result.filter(entry => entry.type !== \"folder\").reduce((acc, val) => val.size + acc, 0);\n    console.timeEnd(\"search result size computing\");\n    console.log({allSize, filesSize});\n\n    debug.appendMessage(`${result.length} items; size: ${bytesToSizeWinLike(filesSize)} (${bytesToSizeWinLike(allSize)});  search: ${searchText}`);\n\n    if (searchSync) {\n        document.title = `[${result.length}] found`;\n    }\n}\n\n\n/**\n * The recursive size computing of an `SimpleEntry`.\n * Skips the entries of `excludeSet`.\n * @param {SimpleEntry} entry\n * @param {Set<SimpleEntry>} excludeSet\n * @return {Number}\n */\nfunction computeEntrySize(entry, excludeSet) {\n    if (entry.type !== \"folder\") {\n        return entry.size;\n    }\n    let childrenSize = 0;\n    for (const child of entry.children || []) {\n        if (excludeSet.has(child)) {\n            continue;\n        }\n        if (child.type === \"folder\") {\n            childrenSize += computeEntrySize(child, excludeSet);\n        } else {\n            childrenSize += child.size;\n        }\n    }\n    return childrenSize;\n}\n\n/**\n * @param {SimpleEntry} folder\n * @param {string} search\n * @return {Promise<{result: SimpleEntry[], search: string}>}\n */\nasync function searcher(folder, search) {\n    console.log(\"[search]      \", search);\n\n    let strict;\n    if (search.startsWith(\"//\")) {\n        strict = true;\n        search = search.slice(2);\n    } else {\n        strict = false;\n        const normalized = simplify(search);\n        if (normalized !== search) {\n            console.log(\"[search][norm]\", normalized);\n            search = normalized;\n        }\n    }\n\n    let searchHelp = null;\n\n    /** @type {\"includes\"|\"startsWith\"|\"endsWith\"|\"===\"} */\n    let subStringMatcher = \"includes\";\n\n    // Simplified glob search.\n    // For \"startsWith\", \"endsWith\" and \"full match\" search.\n    // /*/*.html     - ends with \".html\"\n    // ///*/*.html   - ends with \".html\" case sensitive\n    // /*/.*         - starts with \".\"\n    // /8/.*         - starts with \".\" (the same, just to no need to use Shift key)\n    // /*/index.html - matches \"index.html\"\n    const isSimpleGlobSearch = search.startsWith(\"/*/\") || search.startsWith(\"/8/\");\n    if (isSimpleGlobSearch) {\n        const subSearch = search.slice(\"/*/\".length);\n        const starts = subSearch.startsWith(\"*\");\n        const ends = subSearch.endsWith(\"*\");\n\n        if (starts && ends) {\n            subStringMatcher = \"includes\";\n            search = subSearch.slice(1, -1);\n            searchHelp = `includes \"${search}\"`;\n        } else\n        if (starts) {\n            subStringMatcher = \"endsWith\";\n            search = subSearch.slice(1);\n            searchHelp = `ends with \"${search}\"`;\n        } else\n        if (ends) {\n            subStringMatcher = \"startsWith\";\n            search = subSearch.slice(0, -1);\n            searchHelp = `starts with \"${search}\"`;\n        } else {\n            subStringMatcher = \"===\";\n            search = subSearch;\n            searchHelp = `matches \"${search}\"`;\n        }\n    }\n\n    /** @type {function(String, String): Boolean} */\n    let stringMatcher;\n    if (strict) {\n        if (subStringMatcher === \"===\") {\n            stringMatcher = (string, substring) => string === substring;\n        } else {\n            stringMatcher = (string, substring) => string[subStringMatcher](substring);\n        }\n    } else {\n        if (subStringMatcher === \"===\") {\n            stringMatcher = (string, substring) => simplify(string) === substring;\n        } else {\n            stringMatcher = (string, substring) => simplify(string)[subStringMatcher](substring);\n        }\n    }\n\n    function justSearch(substring) {\n        return findAll(folder, (entry) => {\n            return stringMatcher(entry.name, substring);\n        });\n    }\n\n    if ([\"https://\", \"http://\"].some(prefix => search.startsWith(prefix))) {\n        const url = new URL(search);\n\n        if (url.hostname === \"www.youtube.com\" && url.pathname === \"/watch\") {\n            search = url.searchParams.get(\"v\");\n        } else {\n            const pathnameEndsWithSlash = url.pathname.length > 1 && url.pathname.endsWith(\"/\");\n            const pathname = pathnameEndsWithSlash ? url.pathname.slice(0, -1) : url.pathname;\n            const resourceFullName = pathname.match(/[^\\/]+$/)?.[0];\n            if (!resourceFullName) {\n                return {result: [], search};\n            }\n            const {\n                name: resName,\n                ext: resExt, // [note] it can be not the file extension, but a part of a nickname (inst url, for example)\n            } = resourceFullName.match(/(?<name>.+)(\\.(?<ext>.+))$/)?.groups || {name: resourceFullName};\n            search = resName + ((pathnameEndsWithSlash && resExt) ? `.${resExt}` : \"\");\n        }\n\n        const result = await justSearch(search);\n        return {result, search};\n    }\n\n\n    /**\n     * @example\n     * /size:0       - find 0 byte size entries\n     * /size/120     - the same, find 120 bytes size entries\n     * /size:120+80  - find from 120 to 200\n     * /size:120+-20 - find from 100 to 120\n     * /size:120~20  - find from  80 to 140\n     * /size:120-220 - find from 120 to 220\n     * /size:220-120 - find from 120 to 220\n     * /size:^2      - size.toString() starts with \"2\"\n     * /size:%2      - size.toString() includes    \"2\"\n     * /size:$0      - size.toString() ends with   \"0\"\n     * /s/0          - find 0 byte size entries, just a short form\n     * /s/120 900    - find 120900 bytes size entries\n     * /s/120,900    - find 120900 bytes size entries\n     *\n     * /size:120~    - find from 120 -5% to 120 +5%\n     * /size:120~~   - find from 120-10% to 120+10%\n     * /size:120~~~  - find from 120-15% to 120+15%\n     *\n     * /sizek:5      - find 5 KB ± 0.1 KB\n     * /sizek:50     - find 50 KB  ± 1 KB\n     * /sizek:500    - find 500 KB ± 1 KB\n     * /sizem:5      - find 5 MB ± 0.1 MB\n     * /sizeg/50     - find 50 GB ± 1 GB\n     *\n     * /size:5m      - find 5 MB ± 0.1 MB\n     *\n     * /s/12.9       - find 12 bytes size entries\n     * /sk/12.9      - find 12.9 KB ± 1 KB\n     *\n     * /sizek:5!     - find 5 KB + (0 - 0.01) KB\n     * /sizek:5!!    - find 5 KB + (0 - 0.001) KB\n     * /s/5k!!       - find 5 KB + (0 - 0.001) KB\n     * /sizem:50!    - find 50 MB + (0 - 0.1) MB\n     * /sizem:50!!   - find 50 MB + (0 - 0.01) MB\n     */\n    const r1 = `\\\\/s(ize)?(?<defaultPrefix>b|k|m|g|t)?[:\\\\/]`;\n    if (search.match(new RegExp(r1))) {\n        const r2   = `(?<extra1>(?<caret>\\\\^)|(?<dollar>\\\\$)|(?<percent>%))?`;\n        const r3   = `((?<sizeString1>\\\\s*\\\\d[\\\\d\\\\s\\\\,]*)((?<dotDecimal1>\\\\.(?<decimal1>\\\\d+)?))?(?<prefix1>b|k|m|g|t)?(?<exclamations>!+)?)`;\n\n        const r4_1 = `(?<extra2>(?<plus>\\\\+)|(?<minus>\\\\-)|(?<tildes>\\\\~+))`;\n        const r4_2 = `((?<sizeString2>\\\\s*-?\\\\s*\\\\d[\\\\d\\\\s\\\\,]*)((?<dotDecimal2>\\\\.(?<decimal2>\\\\d+)?))?(?<prefix2>b|k|m|g|t)?)?`;\n        const r4   = `(?<range>${r4_1}${r4_2})?`;\n\n        const regex = new RegExp(r1 + r2 + r3 + r4);\n\n        const {\n            /** @type {\"b\"|\"k\"|\"m\"|\"g\"|\"t\"|undefined} */\n            defaultPrefix,\n\n            /** @type {String|undefined} */\n            caret,\n            /** @type {String|undefined} */\n            dollar,\n            /** @type {String|undefined} */\n            percent,\n\n            /** @type {String|undefined} */\n            sizeString1,\n            /** @type {String|undefined} */\n            decimal1,\n            /** @type {String|undefined} */\n            prefix1,\n            /** @type {String|undefined} */\n            exclamations,\n\n            /** @type {String|undefined} */\n            plus,\n            /** @type {String|undefined} */\n            minus,\n            /** @type {String|undefined} */\n            tildes,\n\n            /** @type {String|undefined} */\n            sizeString2,\n            /** @type {String|undefined} */\n            decimal2,\n            /** @type {String|undefined} */\n            prefix2,\n\n        } = search.match(regex)?.groups || {};\n\n        if (sizeString1) {\n            console.log({\n                defaultPrefix,\n                extra1: {caret, dollar, percent},\n                sizeString1, decimal1, prefix1, exclamations,\n                extra2: {plus, minus, tildes, sizeString2, decimal2, prefix2},\n            });\n\n            let text;\n            let result;\n\n            let sizeNum = Number(sizeString1.replaceAll(/[\\s,]/g, \"\"));\n            const size = sizeNum.toString();\n\n            let size2Num = sizeString2 && Number(sizeString2.replaceAll(/[\\s,]/g, \"\"));\n            const size2 = size2Num?.toString();\n\n\n            const dec1 = decimal1 ? Number(\"0.\" + decimal1) : 0;\n            const dec2 = decimal2 ? Number(\"0.\" + decimal2) : 0;\n            sizeNum  = multiplyByPrefix(sizeNum  + dec1, prefix1 || defaultPrefix);\n            size2Num = multiplyByPrefix(size2Num + dec2, prefix2 || defaultPrefix);\n\n\n            /**\n             * @param {Number} a\n             * @param {Number} b\n             * @return {Promise<void>}\n             */\n            async function rangeSearch(a, b) {\n                const {_min, max} = a < b ? {_min: a, max: b} : {_min: b, max: a};\n                const min = Math.max(0, _min);\n                text = `Size search from ${bytesToSizeWinLike(min)} to ${bytesToSizeWinLike(max)}`;\n                result = await findAll(folder, entry => {\n                    return entry.size >= min && entry.size <= max;\n                });\n            }\n            function multiplyByPrefix(value, prefix = \"b\") {\n                if (value === undefined) {\n                    return;\n                }\n                const prefixes = [\"b\", \"k\", \"m\", \"g\", \"t\"];\n                return Math.trunc(value * (1024 ** prefixes.indexOf(prefix)));\n            }\n\n\n            if (caret) { // ^\n                text = `Size search starts with \"${size}\"`;\n                result = await findAll(folder, entry => {\n                    return entry.size.toString().startsWith(size);\n                });\n            } else\n            if (dollar) { // $\n                text = `Size search ends with \"${size}\"`;\n                result = await findAll(folder, entry => {\n                    return entry.size.toString().endsWith(size);\n                });\n            } else\n            if (percent) { // %\n                text = `Size search includes \"${size}\"`;\n                result = await findAll(folder, entry => {\n                    return entry.size.toString().includes(size);\n                });\n            } else\n            if (plus && size2) { // +\n                await rangeSearch(sizeNum, sizeNum + size2Num);\n            } else\n            if (minus && size2) { // -\n                await rangeSearch(sizeNum, size2Num);\n            } else\n            if (tildes) {  // ~ // ~~ // ~~~\n                if (size2) {\n                    await rangeSearch(sizeNum - size2Num, sizeNum + size2Num);\n                } else {\n                    const count = tildes.length;\n                    const diff = Math.trunc(sizeNum * 5 * count / 100);\n                    await rangeSearch(sizeNum - diff, sizeNum + diff);\n                }\n            } else { // Default\n                const prefix = prefix1 || defaultPrefix;\n                if (prefix && prefix !== \"b\") {\n\n                    let orders = size.length;\n                    let diff = multiplyByPrefix(1, prefix);\n                    if (orders === 1) {\n                        diff = Math.trunc(diff / 10);\n                    }\n\n                    let from = sizeNum - diff;\n                    let to   = sizeNum + diff;\n                    if (exclamations) {\n                        from = sizeNum;\n                        if (exclamations.length > 1) {\n                            to = sizeNum + Math.trunc(diff / 10);\n                        }\n                    }\n                    await rangeSearch(from, to);\n                } else {\n                    text = `Size search ${bytesToSizeWinLike(sizeNum)}`;\n                    result = await findAll(folder, entry => {\n                        return entry.size === sizeNum;\n                    });\n                }\n            }\n            console.log(...blue(text));\n            return {result, search: text};\n        } else {\n            const text = \"No size to search\";\n            console.log(...blue(text));\n            return {result: [], search: text};\n        }\n    }\n    if (search.startsWith(\"/\")) {\n        const {type, word} = search.match(/\\/type:(?<type>[^\\/]+)\\/?(?<word>[^\\/]*)/)?.groups || {};\n        if (type) {\n            console.log({type, word});\n            if (entryTypes.includes(type)) {\n                const result = await findAll(folder, entry => {\n                    return entry.type === type && stringMatcher(entry.name, word);\n                });\n                return {result, search};\n            }\n        }\n    } else\n    if (search.includes(\" \")) {\n        const parts = search.split(\" \").filter(o => o);\n        if (parts.length > 1) {\n            let result = await justSearch(parts.shift());\n            let curWord;\n            while (curWord = parts.shift()) {\n                result = result.filter(entry => stringMatcher(entry.name, curWord));\n            }\n            return {result, search};\n        }\n    }\n    return {result: await justSearch(search), search: (searchHelp || search)};\n}\n\nwatch(search, async (newValue, oldValue) => {\n    const isEmptyString = !newValue;\n    if (isEmptyString) {\n        clearSearchResult();\n        return;\n    }\n    searchAwaiting.value = true;\n\n    // In order to \"no debounce by paste event\"\n    if (newValue.length - oldValue.length > 1) {\n        if (newValue.startsWith(\"https://mega.nz/\")) {\n            await handleMegaUrl(newValue);\n            return;\n        }\n        await performSearch();\n    } else {\n        await performSearchDebounced();\n    }\n});\n\n/**\n * @param {SimpleEntry} folder\n * @param {function(SimpleEntry)} predicate\n * @return {Promise<SimpleEntry[]>}\n */\nasync function findAll(folder, predicate) {\n    let res = [];\n    let time = Date.now();\n    for (const entries of listAllEntries(folder)) {\n        const curTime = Date.now();\n        if (curTime - time > 15) {\n            time = curTime;\n            await sleep();\n        }\n        for (const entry of entries) {\n            if (predicate(entry)) {\n                res.push(entry);\n            }\n        }\n    }\n    return res;\n}\n\n/**\n * List all entries by parts.\n * @param {SimpleEntry} folder\n * @return {Generator<SimpleEntry[]>}\n */\nfunction *listAllEntries(folder) {\n    const partSize = 1000;\n    /** @type {SimpleEntry[]} */\n    let list = [];\n    /** @param {SimpleEntry} folderEntry */\n    function *takePart(folderEntry) {\n        for (const entry of (folderEntry.children || [])) {\n            if (entry.type === \"folder\") {\n                yield *takePart(entry);\n            }\n            list.push(entry);\n            if (list.length === partSize) {\n                yield list;\n                list = [];\n            }\n        }\n    }\n    yield *takePart(folder);\n    yield list;\n}\n","import {EntryStreamParser} from \"./entry.js\";\nimport {appendScript, iterateAsyncDataSource, sleep} from \"../util.js\";\n\n\n/**\n * @param {Blob|Response} input\n * @return {AsyncGenerator<{meta:ScanMeta, root: SimpleEntry, rootUpdated: boolean, processed: number}>}\n */\nexport async function *parseScan(input) {\n    const parser = new EntryStreamParser();\n\n    let contentType;\n    if (input instanceof Response) {\n        contentType = input.headers.get(\"content-type\");\n    } else if (input instanceof Blob) {\n        contentType = input.type;\n    }\n    /** @type {ScanMeta} */\n    let meta;\n    if (isGZip(contentType)) {\n        console.log(\"parseGZippedJSONScan\");\n        for await (const obj of parseGZippedJSONScan(input)) {\n            if (!meta) {\n                meta = /** @type {ScanMeta} */ obj.shift();\n                parser.setMeta(meta);\n            }\n            yield {meta, ...parser.parse(/** @type {SerializableScanEntry[]} */ obj)};\n        }\n    } else if (isJSON(contentType)) {\n        console.log(\"streamParseJSONScan\");\n        for await (const array of streamParseJSONScan(input)) {\n            if (!meta) {\n                meta = /** @type {ScanMeta} */ array.shift();\n                parser.setMeta(meta);\n            }\n            yield {meta, ...parser.parse(/** @type {SerializableScanEntry[]} */ array)};\n        }\n    }\n    parser.processHIDMapAsync();\n}\n\n\n/**\n * @param {Response|ReadableStream|Blob} input\n * @return {AsyncGenerator<FlatScanResultEntry[]>}\n */\nasync function *streamParseJSONScan(input) {\n    const decoder = new TextDecoder();\n    const textParser = new TextParser();\n    let i = 0, time = 0;\n    for await (const uint8Array of iterateAsyncDataSource(input)) {\n        if (!(i++ % 10)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        const scanResultEntries = textParser.parsePart(textPart);\n        if (scanResultEntries.length) {\n            yield scanResultEntries;\n        }\n    }\n}\n\n/**\n * @param {Response|Blob} input\n * @return {AsyncGenerator<FlatScanResultEntry[]>}\n */\nasync function *parseGZippedJSONScan(input) {\n    const decoder = new TextDecoder();\n    const textParser = new TextParser();\n    let i = 0, time = 0;\n    for await (const uint8Array of unGZipAsyncIterator(input)) {\n        if (!(i++ % 20)) {\n            const timeNow = Date.now();\n            if (timeNow - time > 15) {\n                time = timeNow;\n                await sleep();\n                // console.log(\"sleep\", i);\n            }\n        }\n        const textPart = decoder.decode(uint8Array, {stream: true});\n        const scanResultEntries = textParser.parsePart(textPart);\n        if (scanResultEntries.length) {\n            yield scanResultEntries;\n        }\n    }\n}\n\n/**\n * @param {Response|ReadableStream|Blob} input\n * @return {Generator<Uint8Array>}\n */\nasync function *unGZipAsyncIterator(input) {\n    if (!isPakoLoaded()) {\n        await loadPako();\n    }\n    let chunks = [];\n    const inflator = new pako.Inflate();\n    pako.Inflate.prototype.onData = function (chunk) {\n        chunks.push(chunk);\n    };\n    for await (const u8Array of iterateAsyncDataSource(input)) {\n        inflator.push(u8Array);\n        for (const chunk of chunks) {\n            yield chunk;\n        }\n        chunks = [];\n    }\n    yield inflator.result;\n    if (inflator.err) {\n        console.error(inflator.msg);\n    }\n}\n\n\nexport class TextParser {\n    buffer = \"\";\n    startHandled = false;\n    metaLines = [];\n    objects = [];\n\n    trimComma(text) {\n        return text.endsWith(\",\") ? text.slice(0, -1) : text;\n    }\n\n    handleStart(line) {\n        if (line === \"[\") { // the first line\n            return;\n        }\n        if (line === \"\") { // meta is separated from the main content by \"\\n\"\n            this.objects.push(this.metaLines.join(\"\"));\n            this.startHandled = true;\n            return;\n        }\n        this.metaLines.push(line);\n    }\n\n    /**\n     * @param {String} line\n     * @param isLastLine\n     */\n    handleLine(line, isLastLine) {\n        if (isLastLine) {\n            this.buffer += line;\n            return;\n        }\n        if (this.buffer) {\n            this.objects.push(this.buffer + line);\n            this.buffer = \"\";\n        } else {\n            this.objects.push(line);\n        }\n    }\n\n    /**\n     * May return an empty array\n     * @param {String} textPart\n     * @return {FlatScanResultEntry[]}\n     * */\n    parsePart(textPart) {\n        const isLastPart = textPart.endsWith(\"\\n]\");\n        /** @type {String[]} */\n        const lines = textPart.split(\"\\n\");\n\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            const isLastLine = i === lines.length - 1;\n\n            if (isLastLine && isLastPart) {\n                continue;\n            }\n\n            if (!this.startHandled) {\n                this.handleStart(line, isLastLine);\n            } else {\n                this.handleLine(line, isLastLine);\n            }\n        }\n        try {\n            /** @type {FlatScanResultEntry[]} */\n            const result = JSON.parse(`[${this.trimComma(this.objects.join(\"\"))}]`);\n            this.objects = [];\n            return result;\n        } catch (e) {\n            console.log(`[${this.trimComma(this.objects.join(\"\"))}]`);\n            console.log(this.objects);\n            console.log(this, {isLastPart, textPart});\n            throw e;\n        }\n\n    }\n\n}\n\n\nlet pakoIsLoaded = false;\nasync function loadPako() {\n    if (!pakoIsLoaded) {\n        const src = \"https://cdn.jsdelivr.net/npm/pako@2.0.4/dist/pako_inflate.min.js\";\n        const integrity = \"sha256-ZIKs3+RZEULSy0dR6c/mke8V9unZm9vuh05TqvtMdGU=\";\n        await appendScript(src, integrity);\n        pakoIsLoaded = true;\n        console.log(\"pako is loaded\");\n    }\n}\nfunction isPakoLoaded() {\n    return pakoIsLoaded;\n}\n\n\n/**\n * \"application/x-gzip\"\n * \"application/gzip\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isGZip(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?gzip/));\n}\n\n/**\n * \"application/json\"\n * \"application/json; charset=utf-8\"\n * @param contentType\n * @return {Boolean}\n */\nfunction isJSON(contentType) {\n    return Boolean(contentType.match(/^application\\/.*?json/));\n}\n","import {computed, ref, watch, shallowRef, triggerRef} from \"vue\";\nimport {clearSearch} from \"./search.js\";\nimport {folderDummy} from \"./entry.js\";\nimport {dateToDayDateString, sleep} from \"../util.js\";\nimport {addMessage} from \"./debug.js\";\nimport {parseScan} from \"./scan-parser.js\";\nimport {limit} from \"./entries.js\";\nimport {scanParsing, scanParsingProgress} from \"./state.js\";\n\n\n/**\n * @typedef {Object} SpecialMeta\n * @property {Object} [special]\n */\n/**\n * @typedef {ScanMeta & SpecialMeta} FolderMeta\n */\n// Well, IDEA does not support `{ScanMeta & SpecialMeta}` correctly\n// todo make a class for it\n\n/** @type {import(\"vue\").ShallowRef<FolderMeta>} */\nexport const meta = shallowRef(null);\n/** @type {import(\"vue\").ShallowRef<SimpleEntry>} */\nexport const root = shallowRef(null);\n\n\nfunction updateParsingState() {\n    triggerRef(openedFolder);\n}\n\nclass ExecutionState {\n    constructor() {\n        this.abortRequested = false;\n        this._promise = Promise.resolve();\n        this._resolve = () => {};\n    }\n    abort() {\n        this.abortRequested = true;\n        return this._promise;\n    }\n    start() {\n        this._promise = new Promise(r => this._resolve = r);\n    }\n    abortIfRequested() {\n        if (!execution.abortRequested) {\n            return false;\n        }\n        this.abortRequested = false;\n        this._resolve();\n        return true;\n    }\n}\nconst execution = new ExecutionState();\n/**\n * @param {Blob|Response} input\n * @return {Promise<Boolean>}\n */\nexport async function setScan(input) {\n    if (scanParsing.value) {\n        await execution.abort();\n    }\n    scanParsingProgress.value = 0;\n    scanParsing.value = true;\n    execution.start();\n\n    let metaInited = false;\n    let rootInited = false;\n\n    const startTime = Date.now();\n    let time = Date.now();\n    let processedTotal = 0;\n    let total;\n    for await (const {meta: scanMeta, root: rootEntry, rootUpdated: rootContentUpdated, processed} of parseScan(input)) {\n        processedTotal += processed;\n        if (total) {\n            const percentStr = (processedTotal / total * 100).toPrecision(3);\n            scanParsingProgress.value = Number(percentStr);\n        }\n\n        if (execution.abortIfRequested()) {\n            console.log(`[setScan][time][aborted]`, Date.now() - startTime, \"ms\");\n            return false;\n        }\n        if (!metaInited && scanMeta) {\n            meta.value = scanMeta;\n            metaInited = true;\n            total = scanMeta.total;\n            processedTotal -= 1;\n        }\n        if (!rootInited && rootEntry) {\n            root.value = rootEntry;\n            globalThis.root = rootEntry;\n            openFolder(rootEntry);\n            rootInited = true;\n        }\n        const now = Date.now();\n        if (rootContentUpdated || now - time > 50) {\n            time = now;\n            updateParsingState();\n            await sleep();\n        }\n    }\n    updateParsingState();\n    console.log(`[setScan][time]:`, Date.now() - startTime, \"ms\");\n\n    scanParsing.value = false;\n    return true;\n}\n\n/** @type {import(\"vue\").ComputedRef<string>} */\nexport const separator = computed(() => {\n    return meta.value?.separator || \"/\";\n});\n/** @type {import(\"vue\").ComputedRef<string[]>} */\nexport const scanRootPath = computed(() => {\n    return meta.value?.path || [];\n});\n\n\n/** @type {import(\"vue\").ShallowRef<SimpleEntry>} */\nexport const openedFolder = shallowRef(folderDummy);\n/** @type {import(\"vue\").ComputedRef<SimpleEntry[]>} */\nexport const openedFolders = computed(() => {\n    return openedFolder.value.path;\n});\n\n/** @param {SimpleEntry} entry */\nexport function openFolder(entry) {\n    clearSearch();\n    openedFolder.value = entry;\n    limit.value = 50;\n\n    /** @type {SimpleEntry} */\n    globalThis.folder = entry;\n    console.log(\"globalThis.folder:\", entry);\n}\nObject.defineProperty(globalThis, \"flat\", {\n    get() {\n        return globalThis.folder?.flat();\n    }\n});\n\nexport function goBack() {\n    if (openedFolder.value.parent) {\n        openFolder(openedFolder.value.parent);\n    }\n}\n/** @type {import(\"vue\").ComputedRef<Boolean>} */\nexport const empty = computed(() => root.value && openedFolder.value.isEmpty);\n\n\nwatch(meta, async (newValue, oldValue) => {\n    console.log(\"[meta]:\", meta.value);\n    const {files, folders, symlinks, errors, total, scanDate} = meta.value;\n    if (meta.value.scanDate) {\n        addMessage(\n            `files: \"${files}\" folders: \"${folders}\", symlinks: \"${symlinks}\", ` +\n            `errors: \"${errors}\", total: \"${total}\", scanDate: \"${dateToDayDateString(scanDate)}\"`\n        );\n    }\n});\n","<template>\n  <span class=\"scanPath\">\n    <span class=\"parts\" @click=\"goToRoot\" :title=\"title\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"spaced separator\" v-if=\"showSep\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\n//todo title\nimport {computed} from \"vue\";\nimport {scanRootPath, openedFolders, separator, openedFolder, openFolder, meta} from \"../core/folders.js\";\nimport {dateToDayDateString} from \"../util.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst title = computed(() => {\n  if (!meta.value) {\n    return;\n  }\n\n  const {\n      files, folders, symlinks,\n      charDevs, blockDevs, fifos, sockets,\n      total,\n      platform, scanDate\n  } = meta.value;\n\n  function doString(o) {\n    function pad(str) {\n      const count = 3 - Math.trunc((str.length/4));\n      return str + \"\\t\".repeat(count);\n    }\n    return Object.entries(o)\n        .filter(([k, v]) => v !== undefined)\n        .map(([k, v]) => pad(k) + \": \" + v)\n        .join(\"\\n\");\n  }\n  const commonFiles = doString({files, folders, symlinks});\n  const unusualFiles = doString({charDevs, blockDevs, fifos, sockets});\n  const additional = doString({total, platform, scanDate: (scanDate ? dateToDayDateString(scanDate) : undefined)});\n  const special = doString(meta.value.special || {});\n\n  let result;\n  if (platform !== \"win32\") {\n    result = [commonFiles, unusualFiles, additional, special].filter(v => v).join(\"\\n\");\n  } else {\n    result = [commonFiles, additional, special].filter(v => v).join(\"\\n\");\n  }\n  console.log(result);\n  return result;\n});\n\nconst root = computed(() => {\n  const scanPath = [...scanRootPath.value, openedFolder.value.root.name];\n  const str = scanPath.join(separator.value);\n  if (str.startsWith(\"//\")) { // for unix\n    return str.slice(1);\n  }\n  if (meta.value?.platform === \"win32\") { // uppercase win drive letter // todo remove as unnecessary\n    return str[0].toUpperCase() + str.slice(1);\n  }\n  return str;\n});\nconst part1 = computed(() => {\n  return [...root.value].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...root.value].slice(-1).join(\"\");\n});\nconst showSep = computed(() => {\n  return (openedFolders.value.length - 1) && root.value !== \"/\";\n});\n\nfunction goToRoot() {\n  const root = openedFolder.value.root;\n  debugMessageFromEntry(root);\n  openFolder(root);\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.scanPath {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n  <span class=\"opened-folder\">\n    <span class=\"parts\" @click=\"onClick\">\n      <span class=\"part\"       >{{part1}}</span>\n      <span class=\"part spaced\">{{part2}}</span>\n    </span>\n    <span class=\"separator spaced\" v-if=\"!isLast\">{{separator}}</span>\n  </span>\n</template>\n\n<script setup>\nimport {computed, toRefs} from \"vue\";\nimport {openFolder, separator} from \"../core/folders.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst props = defineProps([\"index\", \"count\", \"entry\"]);\nconst {index, count, entry} = toRefs(props);\n\nconst isLast = computed(() => {\n  return index.value + 1 === count.value;\n});\nconst part1 = computed(() => {\n  return [...entry.value.name].slice(0, -1).join(\"\"); // if ends with surrogate pair\n});\nconst part2 = computed(() => {\n  return [...entry.value.name].slice(-1).join(\"\");\n});\n\nfunction onClick() {\n  debugMessageFromEntry(entry.value);\n  openFolder(entry.value);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.opened-folder {\n  height: 100%;\n  display: flex;\n  align-items: center;\n  .parts {\n    height: 100%;\n    display: flex;\n    align-items: center;\n\n    width: 100%;\n    overflow-x: hidden;\n    text-overflow: ellipsis;\n    white-space: pre; /* to display tailing spaces */\n\n    cursor: pointer;\n    box-sizing: border-box;\n    border-bottom: transparent solid 1px;\n    &:hover {\n      background-color: var(--blue-2);\n      border-bottom: 1px solid var(--blue-1);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n    .part { // to use with max-width limitation // not works with  `display: contents;`\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: pre;\n    }\n    .part {\n      display: contents; // for correct selection by double click\n    }\n  }\n  .spaced {\n    letter-spacing: 2px;\n  }\n}\n</style>\n","<template>\n<div class=\"address\" @contextmenu=\"onContextmenu\">\n  <AddressBar_Part>\n    <AddressBar_Base/>\n  </AddressBar_Part>\n  <AddressBar_Part\n      v-for=\"(folder, i) of openedFolders.slice(1)\"\n  >\n    <AddressBar_Folder\n        :entry=\"folder\"\n        :index=\"i\"\n        :count=\"openedFolders.slice(1).length\"\n    />\n  </AddressBar_Part>\n</div>\n</template>\n\n<script setup>\nimport AddressBar_Base from \"./AddressBar_Base.vue\";\nimport AddressBar_Folder from \"./AddressBar_Folder.vue\";\nimport AddressBar_Part from \"./AddressBar_Part.vue\";\nimport {meta, openedFolder, openedFolders, separator} from \"../core/folders.js\";\n\n/** @param {MouseEvent} event */\nasync function onContextmenu(event) {\n  event.preventDefault();\n  const folderPath = [...meta.value.path, ...openedFolder.value.path.map(entry => entry.name)].join(separator.value);\n  console.log(\"Copy to clipboard:\", folderPath);\n  await navigator.clipboard.writeText(folderPath);\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.address {\n  display: flex;\n  overflow-x: scroll;\n  padding-left: 6px;\n\n  scrollbar-width: none; // firefox\n  &::-webkit-scrollbar {\n    -webkit-appearance: none;\n    width: 0;\n    height: 0;\n    background: transparent;\n    display: none;\n  }\n  &:active { // todo only on onContextmenu event do it\n    border-right: var(--blue-1) solid 1px;\n  }\n}\n</style>\n","<template>\n  <div class=\"search-wrapper\">\n    <div class=\"search\">\n      <input id=\"json-scan-search-input\" type=\"text\" v-model=\"search\" ref=\"inputRef\" @focus=\"onFocus\">\n      <button @click=\"onClearClick\">Clear</button>\n    </div>\n    <label for=\"json-scan-search-input\" class=\"fuck-off-lighthouse\">.</label>\n  </div>\n</template>\n\n<script setup>\nimport {search, clearSearch} from \"../core/search.js\";\nimport {ref} from \"vue\";\n\nconst inputRef = ref();\nfunction onClearClick() {\n  clearSearch();\n  inputRef.value.focus();\n}\n\n//todo focus on double shift\n</script>\n\n<style lang=\"scss\" scoped>\n/** reset */\ninput { padding: 0 0; }\nbutton { padding: 0 0; }\n\n.fuck-off-lighthouse {\n  position: absolute;\n  top:-1000px;\n  left:-1000px;\n}\n.search-wrapper {\n  display: contents;\n}\n\n.search {\n  display: flex;\n  height: 100%;\n  label {\n    display: contents;\n  }\n  input {\n    height: 100%;\n    flex-grow: 2;\n    border: none;\n    padding-left: 6px;\n    border-bottom: transparent solid 1px;\n    box-sizing: border-box;\n    &:focus, &:hover {\n      outline: none;\n      border-bottom: var(--blue-1) solid 1px;\n    }\n  }\n  button {\n    height: 100%;\n    padding: 0 6px;\n    //outline: none;\n    outline-width: 1px;\n    outline-color: var(--blue-1);\n    border: none;\n    border-bottom: transparent solid 1px;\n    border-left: var(--gray-2) solid 1px;\n    box-sizing: border-box;\n    background-color: var(--gray-1);\n    &:hover {\n      border-bottom: var(--blue-1) solid 1px;\n      background: var(--blue-2);\n    }\n    &:active {\n      background: var(--blue-3);\n    }\n  }\n}\n</style>\n","export class FileEntry {\n    /**\n     * @param {Object} init\n     * @param {File} [init.file]\n     * @param {\"file\"|\"folder\"} init.type\n     * @param {FileEntry} [init.parent]\n     * @param {String} [init.name]\n     */\n    constructor({file, parent, type, name}) {\n        if (file) {\n            /** @type {File|undefined} */\n            this.file = file;\n        }\n        if (parent) {\n            /** @type {FileEntry|undefined} */\n            this.parent = parent;\n            parent.addChild(this);\n        }\n        if (name) {\n            /** @type {String} */\n            this._name = name;\n        }\n        /** @type {\"file\"|\"folder\"} */\n        this.type = type;\n    }\n\n    get name() {\n        return this._name || this.file?.name;\n    }\n\n    /** @param {FileEntry} entry */\n    addChild(entry) {\n        if (!this.children) {\n            /**\n             * `undefined` if there is no child\n             * @type {FileEntry[]|undefined}\n             */\n            this.children = [];\n        }\n        this.children.push(entry);\n        this.increaseContentSize(entry.size);\n    }\n\n    /** @private\n     *  @param {Number} size  */\n    increaseContentSize(size) {\n        if (!size) {\n            return;\n        }\n        if (!this._contentSize) {\n            /** @type {Number}\n             *  @private  */\n            this._contentSize = 0;\n        }\n        this._contentSize += size;\n        if (this.parent/* && size*/) {\n            this.parent.increaseContentSize(size);\n        }\n    }\n\n    /**\n     * Note: the folder size is computed on the creation step.\n     * @return {Number}\n     */\n    get size() {\n        if (this.type === \"folder\") {\n            return this._contentSize || 0;\n        }\n        return this.file?.size || 0;\n    }\n\n    get mtime() {\n        return this.file?.lastModified || 0;\n    }\n\n    /** @return {FileEntry[]} */\n    get path() {\n        if (!this.parent) {\n            return [this];\n        }\n        return [...this.parent.path, this];\n    }\n\n    /** @return {Generator<FileEntry>} */\n    *[Symbol.iterator]() {\n        yield this;\n        if (this.children) {\n            for (const child of this.children) {\n                yield * child;\n            }\n        }\n    }\n\n    /** @return {FileEntry[]} */\n    flat() {\n        return [...this];\n    }\n\n    /**\n     * @param {FileEntry[]} entries\n     * @return {FileEntry[]}\n     */\n    static flat(entries) {\n        return entries.map(e => [...e]).flat();\n    }\n\n    /**\n     * @param {DataTransferItem[]} dtItems\n     * @return {Promise<FileEntry[]>}\n     */\n    static async fromDataTransferItems(dtItems) {\n        const fileSystemEntries = await dtItemsToFileSystemEntries(dtItems);\n        console.log(\"[fileSystemEntries]:\", fileSystemEntries);\n        /** @type {FileEntry[]} */\n        const result = [];\n        for (const fileSystemEntry of fileSystemEntries) {\n            result.push(await fromFileSystemEntry(fileSystemEntry));\n        }\n        return result;\n    }\n\n    /**\n     * @param {File[]} files\n     * @return {FileEntry[]}\n     */\n    static fromFiles(files) {\n        /** @type {FileEntry[]} */\n        const result = [];\n        for (const file of files) {\n            result.push(new FileEntry({file, type: \"file\"}));\n        }\n        return result;\n    }\n}\n\n/**\n * @param {FileSystemEntry} fsEntry\n * @param {FileEntry|null} parent\n * @return {Promise<FileEntry|null>}\n */\nasync function fromFileSystemEntry(fsEntry, parent = null) {\n    if (fsEntry.isFile) {\n        try {\n            const file = await toFile(/** @type {FileSystemFileEntry} */ fsEntry);\n            return new FileEntry({file, type: \"file\", parent});\n        } catch (e) { // For example, for long path \\\\?\\M:\\...\n            console.error(\"[fromFileSystemEntry][error]\", fsEntry.name, e);\n            return null;\n        }\n    } else if (fsEntry.isDirectory) {\n        const dirEntry = new FileEntry({type: \"folder\", parent, name: fsEntry.name});\n        /** @type {AsyncGenerator<FileSystemEntry>} */\n        const entries = readFileSystemDirectoryEntry(/** @type {FileSystemDirectoryEntry} */ fsEntry);\n        for await (const entry of entries) {\n            // The entries will be attached to the parent (`dirEntry`).\n            await fromFileSystemEntry(entry, dirEntry);\n        }\n        return dirEntry;\n    }\n}\n\n/**\n * Works only with a http server\n * @param {FileSystemFileEntry} fsFileEntry\n * @return {Promise<File>}\n */\nfunction toFile(fsFileEntry) {\n    return new Promise((resolve, reject) => fsFileEntry.file(resolve, reject));\n}\n\n/**\n * @param {FileSystemDirectoryEntry} fsDirEntry\n * @return {AsyncGenerator<FileSystemEntry>}\n */\nasync function * readFileSystemDirectoryEntry(fsDirEntry) {\n    const reader = fsDirEntry.createReader();\n    let part = [];\n    do {\n        part = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));\n        for (const entry of part) {\n            yield entry;\n        }\n    } while (part.length);\n}\n\n/**\n * @param {DataTransferItem[]} dtItems\n * @return {Promise<FileSystemEntry[]>}\n */\nasync function dtItemsToFileSystemEntries(dtItems) {\n    const result = [];\n    for (const entry of dtItems) {\n        result.push(await dtItemToFileSystemEntry(entry));\n    }\n    return result;\n}\n\n/**\n * @param {DataTransferItem} entry\n * @return {Promise<FileSystemEntry>}\n */\nasync function dtItemToFileSystemEntry(entry) {\n    return entry.webkitGetAsEntry();\n}\n","import {ref, computed, watchEffect, toRaw} from \"vue\";\nimport {FileEntry} from \"./FileEntry.js\";\n\n/** @type {import(\"vue\").Ref<File[]>} */\nconst files = ref([]);\n/** @type {import(\"vue\").Ref<DataTransferItem[]>} */\nconst dtItems = ref([]);\n\n/** @type {import(\"vue\").Ref<Boolean>} */\nexport const dropHover = ref(false);\n/** @type {import(\"vue\").Ref<Number>} */\nexport const dropHoverItemCount = ref(0);\n/** @type {import(\"vue\").Ref<String[]>} */\nexport const dropHoverTypes = ref([]);\n\n/** @type {import(\"vue\").Ref<FileEntry[]>} */\nexport const fileEntries = ref([]);\n/** @type {import(\"vue\").Ref<Boolean>} */\nexport const parsing = ref(false);\nwatchEffect(async () => {\n    const time = Date.now();\n    parsing.value = true;\n    if (dtItems.value.length) {\n        fileEntries.value = await FileEntry.fromDataTransferItems(dtItems.value);\n    } else {\n        fileEntries.value = FileEntry.fromFiles(files.value);\n    }\n    parsing.value = false;\n    console.log(\"[FileEntry parsing][time]:\", Date.now() - time, \"ms\");\n    console.log(\"[fileEntries]\", toRaw(fileEntries.value));\n});\n\n/** @type {import(\"vue\").ComputedRef<FileEntry>} */\nexport const file = computed(() => {\n    return fileEntries.value[0];\n});\n/** @type {import(\"vue\").ComputedRef<Number>} */\nexport const count = computed(() => {\n    return fileEntries.value.length;\n});\n\n/** @param {DataTransfer} dataTransfer */\nexport function setDataTransferHover(dataTransfer) {\n    const count = dataTransfer.items.length;\n    const allTypes = [...dataTransfer.items].map(item => item.type);\n    const types = [...new Set(allTypes)];\n\n    dropHoverItemCount.value = count;\n    dropHoverTypes.value = types;\n    console.log(\"[setDataTransferHover]:\", count, types);\n}\nexport function resetDataTransferHover() {\n    dropHoverItemCount.value = 0;\n    dropHoverTypes.value = [];\n}\n\n/** @param {DataTransfer} dataTransfer */\nexport function setDataTransfer(dataTransfer) {\n    console.log(dataTransfer);\n    setFiles(dataTransfer.files);\n    setDtItems(dataTransfer.items);\n}\n/** @param {FileList} filelist */\nexport function setFiles(filelist) {\n    /** @type {File[]} */\n    const _files = [...filelist];\n    files.value = _files;\n    console.log(\"[setFiles]:\", _files);\n}\n/** @param {DataTransferItemList} items */\nexport function setDtItems(items) {\n    /** @type {DataTransferItem[]} */\n    const _dtItems = [...items];\n    dtItems.value = _dtItems;\n    console.log(\"[setDtItems]:\", _dtItems); // bug in chromium: `type` and `kind` is \"\" in the console when expand the array.\n\n    console.log(_dtItems[0].kind);\n    console.log(_dtItems[0].type);\n}\nexport function resetDtItems() {\n    dtItems.value = [];\n}\n","<template>\n  <div class=\"default-hover-text\">{{text}}</div>\n</template>\n\n<script setup>\nimport {computed} from \"vue\";\nimport {dropHoverItemCount} from \"./file-input-state.js\";\nconst text = computed(() => {\n  const postfix = dropHoverItemCount.value > 1 ? \"s\" : \"\";\n  return `Drop ${dropHoverItemCount.value} file${postfix}`;\n});\n</script>\n\n<style scoped>\n.default-hover-text {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n</style>\n","<template>\n  <div class=\"default-prompt-text\" :title=\"names\">\n    <div class=\"parsing\" v-if=\"parsing\">Parsing...</div>\n    <div v-else-if=\"count\">{{count}} file{{count > 1 ? \"s\" : \"\"}}</div>\n    <div v-else style=\"display: contents\"><slot>Select file</slot></div>\n  </div>\n</template>\n\n<script setup>\n//todo split to 2 comps\n//todo use props\n\nimport {count, fileEntries, parsing} from \"./file-input-state.js\";\nimport {computed} from \"vue\";\nconst names = computed(() => {\n  return fileEntries.value.slice(0, 50).map(file => file.name).join(\"\\n\");\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.default-prompt-text {\n  width: inherit;\n  height: inherit;\n  max-width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  cursor: pointer;\n\n  &:hover {\n    //text-decoration: underline;\n  }\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n</style>\n","<template>\n<div\n    class=\"file-input\"\n    ref=\"fileInputElem\"\n    :class=\"{'drop-hover': dropHover}\"\n    tabindex=\"0\"\n    @keydown=\"onKeyDown\"\n>\n  <label>\n    <input type=\"file\"\n           :accept=\"accept\"\n           :multiple=\"multiple\"\n           @change=\"onFileInputChange\"\n           style=\"display: none\"\n    >\n\n    <span class=\"content hover\" v-if=\"dropHover\">\n      <slot name=\"hover\"><FileInputDefaultHoverText/></slot>\n    </span>\n    <span class=\"content selected\" v-else-if=\"file && !parsing\">\n      <slot name=\"selected\"><FileInputDefaultText/></slot>\n    </span>\n    <span class=\"content prompt\" v-else>\n      <slot name=\"prompt\"><FileInputDefaultText/></slot>\n    </span>\n\n  </label>\n  <teleport to=\"body\">\n    <div class=\"file-input-hover-modal\" :class=\"{'drop-hover': dropHover}\"></div>\n  </teleport>\n</div>\n</template>\n\n<script setup>\nimport FileInputDefaultHoverText from \"./FileInputDefaultHoverText.vue\";\nimport FileInputDefaultText from \"./FileInputDefaultText.vue\";\n\nimport {ref, toRefs, onMounted, computed} from \"vue\";\nimport {\n  parsing,\n  file,\n  dropHover,\n  setFiles,\n  setDataTransfer,\n  setDataTransferHover,\n  resetDataTransferHover, resetDtItems\n} from \"./file-input-state.js\";\n\nconst props = defineProps({\n  globalDropZone: {\n    type: Boolean,\n    default: true\n  },\n  accept: {\n    type: String,\n    default: \"*/*\"\n  },\n  multiple: {\n    type: Boolean,\n    default: true\n  },\n});\nconst {\n  /** @type {import(\"vue\").Ref<Boolean>} */\n  globalDropZone,\n} = toRefs(props);\n\n\n/** @param {Event} event */\nfunction onFileInputChange(event) {\n  const fileElem = event.target;\n  setFiles(fileElem.files);\n  resetDtItems();\n}\n\n\n/** @type {import(\"vue\").Ref<HTMLElement|null>} */\nconst fileInputElem = ref(null);\n/** @type {import(\"vue\").Ref<HTMLElement>} */\nconst dropZone = computed(() => {\n  if (globalDropZone.value) {\n    return document.body;\n  }\n  return fileInputElem.value;\n});\nonMounted(() => {\n  if (!globalDropZone.value) {\n    disableDragOverNotDropZone();\n  }\n  initListeners();\n});\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nfunction initListeners() {\n  dropZone.value.addEventListener(\"drop\", onDrop);\n  dropZone.value.addEventListener(\"dragover\", onDragOver);\n  dropZone.value.addEventListener(\"dragleave\", onDragLeave);\n  dropZone.value.addEventListener(\"dragenter\", onDragEnter);\n}\nfunction onDrop(event) {\n  stopEvent(event);\n  dropHover.value = false;\n  setDataTransfer(event.dataTransfer);\n}\nfunction onDragOver(event) {\n  stopEvent(event);\n  event.dataTransfer.dropEffect = \"copy\";\n}\nfunction onDragEnter(event) {\n  stopEvent(event);\n  if (!dropHover.value) {\n    dropHover.value = true;\n  } else {\n    return;\n  }\n  setDataTransferHover(event.dataTransfer);\n}\nfunction onDragLeave(event) {\n  stopEvent(event);\n  if (!dropZone.value.contains(event.relatedTarget)) {\n    dropHover.value = false;\n    resetDataTransferHover();\n  }\n}\n\nfunction disableDragOverNotDropZone() {\n  /** @param {DragEvent} event */\n  const dragOverCallback = event => {\n    if (!dropZone.value.contains(event.target)) {\n      stopEvent(event);\n      event.dataTransfer.dropEffect = \"none\";\n    }\n  };\n  document.body.addEventListener(\"dragover\", dragOverCallback);\n}\n\nfunction onKeyDown(event) {\n  if (event.key === \"Enter\") {\n    fileInputElem.value.querySelector(\"label\").click();\n  }\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.file-input {\n  transition: background-color 0.1s;\n  border: solid 1px var(--file-input-border);\n  box-sizing: border-box;\n  &.drop-hover {\n    background-color: var(--drop-file-hover);\n    transition: background-color 0.1s;\n  }\n  &:hover {\n    background-color: var(--drop-hover);\n  }\n  &:active {\n    background-color: var(--drop-active);\n  }\n}\n.file-input, label, .content {\n  width: 100%;\n  height: 100%;\n}\n\n.file-input-hover-modal {\n  height: 50px;\n  width: 100%;\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n  background-image: linear-gradient(to top, rgba(0,0,0,0.15), rgba(0,0,0,0.005));\n\n  transition: opacity 0.25s ease-out;\n  opacity: 0;\n  &.drop-hover {\n    opacity: 1;\n  }\n}\n</style>\n\n\n\n\n\n\n\n\n\n\n","<template>\n  <div class=\"file-input-wrapper\">\n    <FileInput :accept=\"`application/json,application/gzip`\" :multiple=\"false\"/>\n  </div>\n</template>\n\n<script setup>\nimport {setScan} from \"../core/folders.js\";\n\nimport {watch} from \"vue\";\nimport FileInput from \"./file-input/FileInput.vue\";\nimport {file} from \"./file-input/file-input-state.js\";\n\nwatch(file, () => {\n  if (file.value) {\n    void setScan(file.value.file);\n  }\n});\n</script>\n\n<style lang=\"scss\" scoped>\n\n::v-deep(.file-input) {\n  border-right: 0;\n  border-left:  0;\n  outline-width: 1px;\n  outline-color: var(--blue-1);\n}\n.file-input-wrapper {\n  display: grid;\n  justify-content: center;\n  grid-template-columns: 100%;\n  grid-template-rows: 100%;\n  width: 100%;\n  min-height: 35px;\n}\n</style>\n","<template>\n  <tr class=\"row\"\n      @click=\"onClick\"\n      @mousedown=\"onMousedown\"\n      @mouseover=\"onMouseover\"\n      @mouseleave=\"onMouseleave\"\n      :title=\"title\"\n      :class=\"{error}\"\n  >\n      <td class=\"icon\">{{icon}}</td>\n      <td class=\"name\">{{entry.name}}</td>\n      <td class=\"size\" :class=\"sizeClass\">{{size}}</td>\n      <td class=\"time\" :class=\"{[selectedTime]: true}\">{{time}}</td>\n<!--      <td class=\"type\">{{entry.type}}</td>-->\n<!--      <td class=\"filler\"></td>-->\n  </tr>\n</template>\n\n<script setup>\nimport {toRefs, computed} from \"vue\";\nimport {meta, openedFolder, openFolder} from \"../core/folders.js\";\nimport {bytesToSizeWinLike, dateToDayDateTimeString, isImage, isVideo, isAudio} from \"../util.js\";\nimport {hoveredEntry, selectedTime} from \"../core/entries.js\";\nimport {debugMessageFromEntry} from \"../core/debug.js\";\n\nconst props = defineProps([\"entry\"]);\n\n/** @type {import(\"vue\").Ref<SimpleEntry>} */\nconst entry = toRefs(props).entry;\n\nconst size = computed(() => {\n  return entry.value.hasErrors ? \"\" : bytesToSizeWinLike(entry.value.size);\n});\n\nconst sizeClass = computed(() => {\n  if (size.value === \"0 B\") {\n    return \"Z\";\n  }\n  return size.value.split(\" \")[1];\n});\n\n\n/** @type {import(\"vue\").Ref<Boolean>} */\nconst error = computed(() => {\n  return entry.value.hasErrors;\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst time = computed(() => {\n  if (entry.value[selectedTime.value] === undefined) {\n    return \"\";\n  }\n  const time = dateToDayDateTimeString(entry.value[selectedTime.value], false);\n  return time.slice(0, -3); // trim seconds\n});\n\n/** @type {import(\"vue\").ComputedRef<String>} */\nconst title = computed(() => {\n  if (entry.value.hasErrors) {\n    return JSON.stringify(entry.value.errors[0], null, \" \");\n  }\n  if (entry.value.type === \"symlink\") {\n    return entry.value.pathTo;\n  }\n});\n\n/** @type {import(\"vue\").Ref<String>} */\nconst icon = computed(() => {\n  const type = entry.value.type;\n  if (type === \"folder\") {\n    return \"📁\";\n  } else if (type === \"file\") {\n    const name = entry.value.name;\n    if (isVideo(name)) {\n      return \"🎦\";\n    } else if (isImage(name)) {\n      return \"🖼\";\n    } else if (isAudio(name)) {\n      return \"🎵\";\n    }\n    return \"📄\";\n  } else if (type === \"symlink\") {\n    return \"🔗\";\n  }\n  return \"👾\";\n});\n\nfunction onClick(event) {\n  debugMessageFromEntry(entry.value);\n\n  if (entry.value.type === \"folder\") {\n    openFolder(entry.value);\n  }\n}\n\n/** @param {MouseEvent} event */\nfunction onMousedown(event) {\n  const MIDDLE_BUTTON = 1;\n  const RIGHT_BUTTON = 2;\n  if (event.button === MIDDLE_BUTTON) {\n    event.preventDefault();\n    console.log(\n        entry.value,\n        entry.value.getPathString(meta.value)\n    );\n\n    if (openedFolder.value !== entry.value.parent) {\n      openFolder(entry.value.parent);\n    }\n  }\n}\n\nfunction onMouseover(event) {\n  hoveredEntry.value = entry.value;\n}\nfunction onMouseleave(event) {\n  hoveredEntry.value = null;\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.row {\n  width: 100%;\n  min-height: 28px;\n  display: flex;\n  align-items: center;\n  &:hover {\n    background-color: var(--blue-2);\n  }\n  * {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n  }\n  td {\n    &.icon {\n      border-left: 2px solid transparent;\n      width: 24px;\n      text-align: center;\n      user-select: none;\n    }\n    &.name {\n      display: block;\n      //width: 880px; // gets it from the parent\n      white-space: pre; // to display tailing spaces\n    }\n    &.size {\n      text-align: end;\n      min-width: 80px;\n      &.Z {\n        color: #888;\n      }\n      &.B {\n        color: #666;\n      }\n      &.KB {\n        color: #0b0;\n      }\n      &.MB {\n        color: #0070dd;\n      }\n      &.GB {\n        color: #a335ee;\n      }\n      &.TB {\n        color: #ff8000;\n      }\n    }\n    &.time {\n      text-align: end;\n      width: 145px;\n      color: #777;\n    }\n    &.type {\n      text-align: end;\n      width: 58px;\n      user-select: none;\n    }\n    //&.filler {\n    //  width: inherit;\n    //}\n  }\n  &.error {\n    .icon {\n      border-left: 2px solid red;\n    }\n  }\n}\n</style>\n","<template>\n<div class=\"intersection\" ref=\"intersection\"></div>\n</template>\n\n<script setup>\nimport {onBeforeUnmount, onMounted, ref} from \"vue\";\nimport {count, limit} from \"../core/entries.js\";\n\n/** @param {IntersectionObserverEntry[]} entries */\nconst callback = (entries) => {\n  const [entry] = entries;\n  if (entry.isIntersecting) {\n    if (count.value > limit.value) {\n      limit.value = limit.value + 50;\n    }\n  }\n}\nconst observer = new IntersectionObserver(callback);\n\n/** @type {import(\"vue\").Ref<HTMLElement>} */\nconst intersection = ref(null);\n\nonMounted(() => {\n  observer.observe(intersection.value);\n});\nonBeforeUnmount(() => {\n  observer.disconnect();\n});\n</script>\n\n<style scoped>\n.intersection {\n  width: 100%;\n  position: relative;\n  bottom: 120px;\n}\n</style>\n","<template>\n  <div class=\"content\"\n       @contextmenu=\"onContextMenu\"\n  >\n    <table class=\"rows\" v-if=\"listLimited.length\">\n      <tbody>\n        <Row v-for=\"entry of listLimited\" :entry=\"entry\" :key=\"`${entry.pathString}//${entry.size}`\"/>\n        <IntersectionRow/>\n      </tbody>\n    </table>\n    <div class=\"empty-message\" v-if=\"empty && !error\">\n      <span>The folder is empty.</span>\n    </div>\n    <div class=\"error-message\" v-if=\"error\">\n      <div>\n        <h2>Error</h2>\n        <table>\n          <tr>\n            <td>syscall</td>\n            <td><pre>{{error.syscall}}</pre></td>\n          </tr>\n          <tr>\n            <td>code</td>\n            <td><pre>{{error.code}}</pre></td>\n          </tr>\n          <tr>\n            <td>errno</td>\n            <td><pre>{{error.errno}}</pre></td>\n          </tr>\n        </table>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport Row from \"./Row.vue\";\nimport IntersectionRow from \"./IntersectionRow.vue\";\nimport {goBack, empty, openedFolder} from \"../core/folders.js\";\nimport {listLimited} from \"../core/entries.js\";\nimport {computed, onMounted, ref} from \"vue\";\n\n/** @type {import(\"vue\").ComputedRef<ScanError>} */\nconst error = computed(() => {\n  if (openedFolder.value.hasErrors) {\n    return openedFolder.value.errors[0];\n  }\n  return false;\n});\n\nfunction onContextMenu(event) {\n  event.preventDefault();\n  goBack();\n}\n\nconst nameElemWidth = ref(\"880px\");\nonMounted(() => {\n  const w = document.body.offsetWidth;\n  if (w < 1280) {\n    let px = 880 - (1280 - w);\n    px = px < 140 ? 140 : px;\n    nameElemWidth.value = `${px}px`;\n  }\n});\n\n</script>\n\n\n<style lang=\"scss\" scoped>\n::v-deep(.row .name) {\n  width: v-bind(nameElemWidth);\n}\n\n.content {\n  width: 100%;\n  overflow: auto;\n  .rows {\n    width: 100%;\n    overflow: auto;\n  }\n  .empty-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: var(--gray-2);\n  }\n  .error-message {\n    height: 100%;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    flex-direction: column;\n    color: var(--red-1);\n    div {\n      h2 {\n        margin: 0;\n        padding-bottom: 6px;\n        padding-left: 2px;\n      }\n      pre {\n        display: inline;\n      }\n      td {\n        padding-right: 3px;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div class=\"status\">\n    <span>Items count: {{count}}</span>\n    <span v-show=\"hoveredEntry\">. Hover item's size: {{size}}</span>\n  </div>\n</template>\n\n<script setup>\nimport {count, hoveredEntry} from \"../core/entries.js\";\nimport {computed} from \"vue\";\nimport {bytesToSizeWinLike} from \"../util.js\";\n\nconst size = computed(() => hoveredEntry.value?.size && bytesToSizeWinLike(hoveredEntry.value.size));\n</script>\n\n<style scoped>\n.status {\n  padding: 2px 2px 2px 6px;\n}\n</style>\n","<template>\n  <div class=\"switch\">\n    <button\n        class=\"order-by-name\"\n        title=\"Order by name\"\n        @click=\"onClick('name')\"\n        :class=\"{active: orderBy === 'name'}\"\n    >{{ orders.name  ? \"N\" : \"n\"}}</button>\n    <button\n        class=\"order-by-size\"\n        title=\"Order by size\"\n        @click=\"onClick('size')\"\n        :class=\"{active: orderBy === 'size'}\"\n    >{{ orders.size  ? \"S\" : \"s\"}}</button>\n    <button\n        class=\"order-by-time\"\n        :title=\"'Order by ' + selectedTime\"\n        @click=\"onClick('time')\"\n        @contextmenu.prevent=\"toggleTimeType\"\n        :class=\"{active: orderBy === 'time', [selectedTime]: true}\"\n    >{{ orders.time ? \"D\" : \"d\"}}</button>\n  </div>\n</template>\n\n<script setup>\nimport {orderBy, toggleOrder, orders, selectedTime} from \"../core/entries.js\";\n\n// todo optimise reversing.\n// todo cancel sorting (for large arrays) on new click while sorting\n\nfunction toggleTimeType() {\n  selectedTime.value = selectedTime.value === \"mtime\" ? \"btime\" : \"mtime\";\n}\n\n/** @param {\"name\"|\"size\"|\"time\"} value */\nfunction onClick(value) {\n  if (orderBy.value === value) {\n    toggleOrder();\n  }\n  orderBy.value = value;\n}\n\n</script>\n\n<style lang=\"scss\" scoped>\n.switch {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\nbutton.active {\n  font-weight: bold;\n}\n.btime {\n  font-style: italic;\n}\n\nbutton {\n  width: 22px;\n  margin: 1px 3px;\n  padding: 2px 6px;\n  outline-width: 1px;\n  outline-color: var(--blue-1);\n  border: 1px solid var(--gray-2);\n  box-sizing: border-box;\n  background-color: var(--gray-1);\n  &:hover {\n    border-bottom: var(--blue-1) solid 1px;\n    background: var(--blue-2);\n  }\n  &:active {\n    background: var(--blue-3);\n  }\n}\n</style>\n","<template>\n  <div class=\"memory-consuming-component\"\n       v-if=\"isSupported\"\n       :style=\"{width: percent + '%'}\"\n       :title=\"'Heap size: ' + formattedSize + (showHint ? '\\n' + hint : '')\"\n       @mousedown=\"onMousedown\"\n  >\n    <div class=\"visible\"\n        :class=\"{over100}\"\n    ></div>\n    <div class=\"invisible\"></div>\n  </div>\n</template>\n\n<script setup>\nimport {bytesToSizeWinLike} from \"../util.js\";\nimport {computed, ref, onMounted, onBeforeUnmount} from \"vue\";\n\n\n/** @type {import(\"vue\").Ref<{jsHeapSizeLimit: number, totalJSHeapSize: number, usedJSHeapSize: number}>} */\nconst memory = ref(performance.memory);\nconst jsHeapSizeLimit = computed(() => memory.value.jsHeapSizeLimit);\nconst totalJSHeapSize = computed(() => memory.value.totalJSHeapSize);\nconst usedJSHeapSize  = computed(() => memory.value.usedJSHeapSize);\n\nconst intervalId = ref(null);\nconst over100 = ref(false);\nconst showHint = ref(false);\nconst hint = \"Use middle mouse button click to clear the console.\";\n\nconst percent = computed(() => {\n  const percent = totalJSHeapSize.value / (jsHeapSizeLimit.value / 100);\n  over100.value = percent > 100;\n  return over100.value ? 100 : percent;\n});\n\nconst formattedSize = computed(() => bytesToSizeWinLike(totalJSHeapSize.value));\nconst isSupported = computed(() => memory.value);\n\nonMounted(() => {\n  if (!isSupported.value) {\n    return;\n  }\n  intervalId.value = setInterval(() => {\n    memory.value = performance.memory;\n  }, 1000);\n});\nonBeforeUnmount(() => {\n  if (intervalId.value) {\n    clearInterval(intervalId.value);\n  }\n});\n\n/** @param {MouseEvent} event */\nfunction onMousedown(event) {\n  const LEFT_BUTTON = 0;\n  const MIDDLE_BUTTON = 1;\n  const RIGHT_BUTTON = 2;\n  if (event.button === LEFT_BUTTON) {\n    showHint.value = true;\n  }\n  if (event.button === MIDDLE_BUTTON) {\n    event.preventDefault();\n    showHint.value = false;\n    console.clear();\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.memory-consuming-component {\n  position: absolute;\n  left: 0;\n  top: 0;\n  > div {\n    width: 100%;\n  }\n  .visible {\n    background-color: #415aff;\n    height: 2px;\n    &.over100 {\n      background-color: #e30000;\n    }\n  }\n  &:active .visible {\n    background-color: #415aff80;\n  }\n  .invisible {\n    height: 3px;\n  }\n}\n</style>\n","<template>\n  <div class=\"scan-parsing-progress-component\"\n       v-if=\"scanParsing || show100\"\n       :style=\"{width: scanParsingProgress + '%'}\"\n  >\n    <div class=\"visible\"></div>\n  </div>\n</template>\n\n<script setup>\nimport {scanParsing, scanParsingProgress} from \"../core/state.js\";\nimport {ref, watchEffect} from \"vue\";\nimport {sleep} from \"../util.js\";\n\nconst show100 = ref(false);\nwatchEffect(async () => {\n  if (scanParsingProgress.value === 100) {\n    show100.value = true;\n    await sleep(16);\n    show100.value = false;\n  }\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.scan-parsing-progress-component {\n  pointer-events: none;\n  position: absolute;\n  left: 0;\n  top: 0;\n  > div {\n    width: 100%;\n  }\n  .visible {\n    background-color: var(--blue-1);\n    height: 4px;\n  }\n}\n</style>\n","<template>\n  <div class=\"main\">\n    <MemoryConsuming/>\n    <ScanProgressBar/>\n    <Switch     style=\"grid-area: switch;\"/>\n    <AddressBar style=\"grid-area: address;\"/>\n    <Search     style=\"grid-area: search;\"/>\n    <Tabs       style=\"grid-area: tabs;\"/>\n    <Guide      style=\"grid-area: content;\" v-if=\"showGuide\"/>\n    <InnerModal style=\"grid-area: content;\" v-else-if=\"scanParsing && searchAwaiting\">\n      [Search]: Scan parsing awaiting\n    </InnerModal>\n    <Content    style=\"grid-area: content;\" v-else/>\n    <Status     style=\"grid-area: status;\"/>\n    <Debug      style=\"grid-area: debug;\"/>\n    <a class=\"readme\" title=\"Open Readme\" href=\"https://github.com/AlttiRi/directory-snapshot-explorer#file-manager-snapshot-explorer\" target=\"_blank\"><i>i</i></a>\n  </div>\n</template>\n\n<script setup>\nimport AddressBar from \"./AddressBar.vue\";\nimport Search from \"./Search.vue\";\nimport Tabs from \"./Tabs.vue\";\nimport Content from \"./Content.vue\";\nimport Status from \"./Status.vue\";\nimport Switch from \"./Switch.vue\";\nimport Debug from \"./Debug.vue\";\nimport Guide from \"./Guide.vue\";\nimport InnerModal from \"./InnerModal.vue\";\nimport MemoryConsuming from \"./MemoryConsuming.vue\";\nimport ScanProgressBar from \"./ScanProgressBar.vue\";\nimport {computed, onMounted} from \"vue\";\nimport {meta, setScan} from \"../core/folders.js\";\nimport {search} from \"../core/search.js\";\nimport {bytesToSize, bytesToSizeWinLike} from \"../util.js\";\nimport {scanParsing, searchAwaiting} from \"../core/state.js\";\nimport {orderBy, toggleOrder} from \"../core/entries.js\";\nimport {handleMegaUrl} from \"../core/mega-nz.js\";\n\nglobalThis.bytesToSize = bytesToSize;\nglobalThis.bytesToSizeWinLike = bytesToSizeWinLike;\n\n\n// some kind of hack, but okay // don't show if a file selected, or remote scan is loading\nconst showGuide = computed(() => !meta.value && !new URL(location.href).searchParams.get(\"filepath\"));\n\n\n// Already opened directory, no need to open with input\nonMounted(async () => {\n  const url = new URL(location.href);\n  const filepath = url.searchParams.get(\"filepath\");\n  const sort = url.searchParams.get(\"sort\") || url.searchParams.get(\"order\");\n  if ([\"name\", \"size\", \"time\"].includes(sort)) {\n    orderBy.value = sort;\n    if ([\"true\", \"1\"].includes(url.searchParams.get(\"desc\"))) {\n      toggleOrder();\n    }\n  }\n  if (filepath) {\n    /** @type {Response} */\n    const response = await fetch(filepath);\n    await setScan(response);\n  }\n  const hash = url.hash.slice(1);\n  if (hash.startsWith(\"https://mega.nz/\")) {\n    await handleMegaUrl(hash);\n  }\n  const _search = url.searchParams.get(\"search\");\n  if (_search) {\n    search.value = _search;\n  }\n});\n\n</script>\n\n<style lang=\"scss\" scoped>\n.main {\n  grid-template-areas: \"switch address search \"\n                       \"tabs   content content\"\n                       \"status status  status \"\n                       \"debug  debug   debug  \";\n\n  display: grid;\n  grid-template-columns: 7em 2fr 1fr;\n  grid-template-rows:    2em 1fr;\n\n  height: 720px;\n  max-height: 100vh;\n  width: 1280px;\n  max-width: 100%;\n  box-sizing: border-box;\n\n  grid-gap: 1px;\n  border: 1px solid var(--gray-2);\n  background-color: var(--gray-2);\n  * {\n    background-color: white;\n  }\n}\n.readme {\n  position: absolute;\n  bottom: 0;\n  right: 0;\n  padding: 2px 8px;\n  margin: 1px;\n  color: darkgray;\n  text-decoration: none;\n}\n</style>\n","import {createApp} from \"vue\";\nimport App from \"./App.vue\";\n\ncreateApp(App).mount(\"#app\");\n"],"names":["relList","document","createElement","supports","link","querySelectorAll","processPreload","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","ep","fetchOpts","script","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","fetch","href","p","setImmediate","globalThis","port1","port2","MessageChannel","queue","onmessage","shift","callback","postMessage","push","sleep","ms","Promise","resolve2","setTimeout","videoExtensions","imageExtensions","audioExtensions","firefoxDateFix","dateValue","input","String","replace","dateToDayDateString","utc","_date","Date","pad2","str","toString","padStart","console","warn","_utc","year","month","date","dateToDayDateTimeString","hours","minutes","seconds","time","async","iterateAsyncDataSource","dataSource","Response","body","ReadableStream","stream","reader","getReader","done","value","read","iterateReadableStream","Blob","part","blob","chunkSize","index","blobChunk","slice","size","blob2","Uint8Array","arrayBuffer","iterateBlob","bytesToSize","bytes","decimals","i","Math","floor","log","Number","parseFloat","pow","toFixed","bytesToSizeWinLike","result","number","trunc","toPrecision","toTruncPrecision3","blue","text","sort","ref","selectedTime","orderBy","orders","name","reverseOrder","computed","toggleOrder","compare","Intl","Collator","numeric","sensitivity","comparator","pre","cur","k","timeName","entries","openedFolder","folders","files","symlinks","fifos","charDevs","blockDevs","sockets","limit","list","search","length","searchResult","listLimited","count","hoveredEntry","debugMessage","addMessage","message","appendMessage","debugMessageFromEntry","entry","isProxy","toRaw","hasErrors","messages","mtime","btime","join","entryTypes","SimpleEntry","constructor","parent","errorsIDMap","this","_size","_mtime","errors","map","id","get","pathTo","content","addChild","children","increaseContentSize","addHardlinks","entries2","total","hardlinks","hardlinksTotal","_contentSize","MIN_SAFE_INTEGER","child","_a","filter","e","isEmpty","Boolean","root","path","contentTypesStats","getContentTypesStats","_getContentTypesStats","deep","target","timeEnd","Symbol","iterator","flat","pathString","getPathString","meta2","names","pathStr","separator","startsWith","EntryStreamParser","rootId","Map","hidMap","setMeta","meta","errorsMap","Object","v","code","syscall","errno","split","parse","sEntriesPart","rootUpdated","pid","simpleEntry","set","hid","array","processed","processHIDMapAsync","simpleEntries","timeNow","now","totalLinks","forEach","then","folderDummy","scanParsing","scanParsingProgress","searching","searchAwaiting","seen","handleMegaUrl","url","baseModule","deps","Mega","import","all","dep","isCss","endsWith","cssSelector","querySelector","as","crossOrigin","head","appendChild","res","rej","addEventListener","parseMegaNode","_url","special","_id","ownerId","_ownerId","emptyRootFolder","openFolder","megaNode","sEntry","ssEntry","creationDate","modificationDate","parentId","toSEntry","mNode","clearSearch","shallowRef","setSearchResult","rawResult","defineProperty","addSearchResultToGlobalThis","sortSearch","timeTotal","triggerRef","watch","resolve","scanParsingCompleted","simplify","toLowerCase","watchEffect","r","window","event","key","newValue","dispatchEvent","Event","performSearchDebounced","runnable","timerId","clearTimeout","apply","arguments","debounce","performSearch","searchSync","URL","location","searchParams","localStorage","setItem","title","folder","request","folderRaw","isReactive","time1","performance","searchText","search2","strict","normalized","searchHelp","subStringMatcher","subSearch","starts","ends","stringMatcher","string","substring","justSearch","findAll","some","prefix","hostname","pathname","pathnameEndsWithSlash","resourceFullName","match","resName","ext","resExt","_b","groups","r1","RegExp","regex","defaultPrefix","caret","dollar","percent","sizeString1","decimal1","prefix1","exclamations","plus","minus","tildes","sizeString2","decimal2","prefix2","_c","multiplyByPrefix","prefixes","indexOf","extra1","extra2","sizeNum","replaceAll","size2Num","size2","dec1","dec2","rangeSearch","a","b","_min","max","min","includes","count2","diff","orders2","from","to","word","parts","o","curWord","searcher","resultSet","Set","allSize","reduce","acc","val","computeEntrySize","filesSize","debug.appendMessage","excludeSet","childrenSize","has","predicate","partSize","list2","takePart","folderEntry","listAllEntries","curTime","parseScan","parser","contentType","headers","isGZip","obj","decoder","TextDecoder","textParser","TextParser","uint8Array","pakoIsLoaded","src","reject","onload","onerror","append","appendScript","loadPako","chunks","inflator","pako","Inflate","prototype","onData","chunk","u8Array","err","error","msg","unGZipAsyncIterator","textPart","decode","scanResultEntries","parsePart","parseGZippedJSONScan","isJSON","streamParseJSONScan","oldValue","__publicField","trimComma","handleStart","line","objects","metaLines","startHandled","handleLine","isLastLine","buffer","isLastPart","lines","JSON","updateParsingState","execution","abortRequested","_promise","_resolve","abort","start","abortIfRequested","setScan","metaInited","rootInited","startTime","processedTotal","scanMeta","rootEntry","rootContentUpdated","percentStr","scanRootPath","openedFolders","empty","files2","scanDate","platform","doString","repeat","pad","commonFiles","unusualFiles","additional","root2","toUpperCase","part1","part2","showSep","goToRoot","root3","toRefs","props","isLast","onClick","onContextmenu","preventDefault","folderPath","navigator","clipboard","writeText","inputRef","onClearClick","focus","FileEntry","file","file2","_name","lastModified","fromDataTransferItems","dtItems2","fileSystemEntries","dtItemToFileSystemEntry","dtItemsToFileSystemEntries","fileSystemEntry","fromFileSystemEntry","fromFiles","fsEntry","isFile","fsFileEntry","isDirectory","dirEntry","fsDirEntry","createReader","readEntries","readFileSystemDirectoryEntry","webkitGetAsEntry","dtItems","dropHover","dropHoverItemCount","dropHoverTypes","fileEntries","parsing","setDataTransfer","dataTransfer","setFiles","items","_dtItems","kind","setDtItems","filelist","_files","postfix","globalDropZone","onFileInputChange","fileInputElem","dropZone","stopEvent","stopPropagation","onDrop","onDragOver","dropEffect","onDragEnter","allTypes","item","types","setDataTransferHover","onDragLeave","contains","relatedTarget","onKeyDown","click","onMounted","dragOverCallback","disableDragOverNotDropZone","sizeClass","stringify","icon","filename","isVideo","isImage","isAudio","onMousedown","button","onMouseover","onMouseleave","observer","IntersectionObserver","isIntersecting","intersection","onBeforeUnmount","disconnect","onContextMenu","nameElemWidth","w","offsetWidth","px","toggleTimeType","memory","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","intervalId","over100","showHint","percent2","formattedSize","isSupported","clear","setInterval","clearInterval","show100","showGuide","filepath","sort2","response","hash","_search","createApp","mount"],"mappings":"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"}